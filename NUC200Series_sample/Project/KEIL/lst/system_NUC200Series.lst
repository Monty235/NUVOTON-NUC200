L 1 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\system_NUC200Series.c"
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 7 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\system_NUC200Series.c" 2
N#include "NUC200Series.h"
L 1 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 1
N    /*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                             */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#ifndef __NUC200Series_H__
N#define __NUC200Series_H__
N
N              
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N*/
N 
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                       */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                       */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                   */
N
N/******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
N  BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */ 
N  WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
N  EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
N  EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
N  GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
N  GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
N  PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
N  PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
N  TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
N  TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
N  TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
N  TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
N  UART02_IRQn               = 12,      /*!< UART0/UART2 Interrupt                                */
N  UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
N  SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
N  SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
N  SPI2_IRQn                 = 16,       /*!< SPI2 Interrupt                                       */
N  SPI3_IRQn                 = 17,       /*!< SPI3 Interrupt                                       */
N  I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
N  I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
N  CAN0_IRQn                 = 20,       /*!< CAN0 Interrupt                                       */
N  CAN1_IRQn                 = 21,       /*!< CAN1 Interrupt                                       */
N  SC012_IRQn                = 22,       /*!< SC0/SC1/SC2 Interrupt                                */
N  USBD_IRQn                 = 23,       /*!< USB device Interrupt                                 */
N  PS2_IRQn                  = 24,       /*!< PS/2 device Interrupt                                */
N  ACMP_IRQn                 = 25,       /*!< ACMP0 Interrupt                                      */
N  PDMA_IRQn                 = 26,       /*!< PDMA Interrupt                                       */
N  I2S_IRQn                  = 27,       /*!< I2S Interrupt                                        */
N  PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
N  ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
N  IRC_IRQn                  = 30,       /*!< IRC TRIM Interrupt                                   */
N  RTC_IRQn                  = 31        /*!< RTC Interrupt                                        */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
L 1 "..\..\LibNUC200Series\CMSIS\CM0\CoreSupport\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM0_CORE_H__
N#define __CM0_CORE_H__
N
N/** @addtogroup CMSIS_CM0_core_definitions CM0 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM0_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | __CM0_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x00)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    2               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM0_core_register CMSIS CM0 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM0_NVIC CMSIS CM0 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                      /*!< (Offset: 0x000) Interrupt Set Enable Register            */
X  volatile uint32_t ISER[1];                       
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                      /*!< (Offset: 0x080) Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                       
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                      /*!< (Offset: 0x100) Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                       
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                      /*!< (Offset: 0x180) Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                       
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IPR[8];                       /*!< (Offset: 0x3EC) Interrupt Priority Register              */
X  volatile uint32_t IPR[8];                        
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM0_NVIC */
N
N
N/** @addtogroup CMSIS_CM0_SCB CMSIS CM0 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N       uint32_t RESERVED0;                                      
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N       uint32_t RESERVED1;                                      
N  __IO uint32_t SHP[2];                       /*!< Offset: 0x1C  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                        
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N       uint32_t RESERVED2[2];                                   
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N} SCB_Type;                                                
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFul << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM0_SCB */
N
N
N/** @addtogroup CMSIS_CM0_SysTick CMSIS CM0 SysTick
N  memory mapped structure for SysTick
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM0_SysTick */
N
N
N/** @addtogroup CMSIS_CM0_CoreDebug CMSIS CM0 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_DWTENA_Pos         24                                             /*!< CoreDebug DEMCR: DWTENA Position */
N#define CoreDebug_DEMCR_DWTENA_Msk         (1ul << CoreDebug_DEMCR_DWTENA_Pos)            /*!< CoreDebug DEMCR: DWTENA Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM0_CoreDebug */
N
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N/*@}*/ /* end of group CMSIS_CM0_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5030076 < 400000)
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S
S
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM0_Core_FunctionInterface CMSIS CM0 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N/* ##########################   NVIC functions  #################################### */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn   The positive number of the external interrupt to disable
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) | 
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IPR[_IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N                                                               
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) | 
N                   SysTick_CTRL_TICKINT_Msk   | 
X                   (1ul << 1)   | 
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      | 
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1ul << 2));
N  __DSB();                                                                             /* Ensure completion of memory access */              
X  __dsb(0);                                                                                            
N  while(1);                                                                            /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM0_Core_FunctionInterface */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM0_core_definitions */
N
N#endif /* __CM0_CORE_H__ */
N
N/*lint -restore */
L 75 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "system_NUC200Series.h"              /* NUC200 System                                          */
L 1 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\system_NUC200Series.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __SYSTEM_NUC1xx_H
N#define __SYSTEM_NUC1xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N//#define DEBUG_ENABLE_SEMIHOST   /* To enable semihosted. !!!The SEMIHOSTED of startup_NUC1xx.s must be {TRUE} */
N
N/* Using UART0 or UART1 */  
N#define DEBUG_PORT   UART0
N
N/**
N *
N * @details    This is used to enable PLL to speed up booting at startup. Remove it will cause system using 
N *             default clock source (External crystal or internal 22.1184MHz IRC).
N *             Enable this option will casue system booting in 50MHz(By XTAL) or 50.1918MHz(By IRC22M) according to
N *             user configuration setting in CONFIG0
N *             
N */
N#define INIT_SYSCLK_AT_BOOTING
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __XTAL      (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __RTC_XTAL  (32768UL)       /*!< External Crystal Clock Frequency 32.768KHz */
N#define __IRC22M    (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __IRC10K    (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __HSI       (50000000UL)     /*!< PLL default output is 50MHz */
N
Nextern uint32_t SystemCoreClock;                   /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;                       /*!< Cycles per micro second              */
Nextern uint32_t PllClock;                          /*!< PLL Output Clock Frequency           */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system
N *         Initialise GPIO directions and values
N */
Nextern void SystemInit(void);
N
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 76 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/*-------------------------------- Device Specific Peripheral registers structures ---------------------*/
N/** @addtogroup NUC200 NUC200 Peripheral Register
N  NUC200 Series Peripheral Control Registers
N  @{
N */
N
N
N/*--------------------- General Purpose I/O (GPIO) ---------------------*/
N/** @addtogroup NUC200_GPIO NUC200 GPIO
N  Memory Mapped Structure for NUC200 Series General Purpose I/O
N  @{
N */
Ntypedef struct
N{
N    /**
N     * PMD
N     * ===================================================================================================
N     * Offset: 0x00  GPIO Port [A/B/C/D/E/F] I/O Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  PMD;                         
X    volatile uint32_t  PMD;                         
N
N    /**
N     * OFFD
N     * ===================================================================================================
N     * Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  OFFD;                        
X    volatile uint32_t  OFFD;                        
N
N    /**
N     * DOUT
N     * ===================================================================================================
N     * Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DOUT;                        
X    volatile uint32_t  DOUT;                        
N
N    /**
N     * DMASK
N     * ===================================================================================================
N     * Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DMASK;                       
X    volatile uint32_t  DMASK;                       
N
N    /**
N     * PIN
N     * ===================================================================================================
N     * Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  PIN;                         
X    volatile const  uint32_t  PIN;                         
N
N    /**
N     * DBEN
N     * ===================================================================================================
N     * Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DBEN;                        
X    volatile uint32_t  DBEN;                        
N
N    /**
N     * IMD
N     * ===================================================================================================
N     * Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  IMD;                         
X    volatile uint32_t  IMD;                         
N
N    /**
N     * IEN
N     * ===================================================================================================
N     * Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  IEN;                         
X    volatile uint32_t  IEN;                         
N
N    /**
N     * ISRC
N     * ===================================================================================================
N     * Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  ISRC;                        
X    volatile uint32_t  ISRC;                        
N} GPIO_T;                                  
N                                                
Ntypedef struct                                  
N{                                               
N    /**
N     * DBNCECON
N     * ===================================================================================================
N     * Offset: 0x180 Interrupt De-bounce Cycle Control
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DBNCECON;                    
X    volatile uint32_t  DBNCECON;                    
N} GPIO_DBNCECON_T;
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD15_Pos          30                                          /*!< GPIO PMD: PMD15 Position */
N#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)               /*!< GPIO PMD: PMD15 Mask */
N
N#define GPIO_PMD_PMD14_Pos          28                                          /*!< GPIO PMD: PMD14 Position */
N#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)               /*!< GPIO PMD: PMD14 Mask */
N
N#define GPIO_PMD_PMD13_Pos          26                                          /*!< GPIO PMD: PMD13 Position */
N#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)               /*!< GPIO PMD: PMD13 Mask */
N
N#define GPIO_PMD_PMD12_Pos          24                                          /*!< GPIO PMD: PMD12 Position */
N#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)               /*!< GPIO PMD: PMD12 Mask */
N
N#define GPIO_PMD_PMD11_Pos          22                                          /*!< GPIO PMD: PMD11 Position */
N#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)               /*!< GPIO PMD: PMD11 Mask */
N
N#define GPIO_PMD_PMD10_Pos          20                                          /*!< GPIO PMD: PMD10 Position */
N#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)               /*!< GPIO PMD: PMD10 Mask */
N
N#define GPIO_PMD_PMD9_Pos           18                                          /*!< GPIO PMD: PMD9 Position */
N#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)                /*!< GPIO PMD: PMD9 Mask */
N
N#define GPIO_PMD_PMD8_Pos           16                                          /*!< GPIO PMD: PMD8 Position */
N#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)                /*!< GPIO PMD: PMD8 Mask */
N
N#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO PMD: PMD7 Position */
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO PMD: PMD7 Mask */
N
N#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO PMD: PMD6 Position */    
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO PMD: PMD6 Mask */
N
N#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO PMD: PMD5 Position */
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO PMD: PMD5 Mask */
N
N#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO PMD: PMD4 Position */
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO PMD: PMD4 Mask */
N
N#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO PMD: PMD3 Position */
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO PMD: PMD3 Mask */
N
N#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO PMD: PMD2 Position */
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO PMD: PMD2 Mask */
N
N#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO PMD: PMD1 Position */
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO PMD: PMD1 Mask */
N
N#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO PMD: PMD0 Position */
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO PMD: PMD0 Mask */
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO OFFD: OFFD Position */
N#define GPIO_OFFD_OFFD_Msk          (0xFFFFul << GPIO_OFFD_OFFD_Pos)            /*!< GPIO OFFD: OFFD Mask */
N
N/* GPIO DOUT Bit Field Definitions */                                           
N#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO DOUT: DOUT Position */
N#define GPIO_DOUT_DOUT_Msk          (0xFFFFul << GPIO_DOUT_DOUT_Pos)            /*!< GPIO DOUT: DOUT Mask */
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO DMASK: DMASK Position */
N#define GPIO_DMASK_DMASK_Msk        (0xFFFFul << GPIO_DMASK_DMASK_Pos)          /*!< GPIO DMASK: DMASK Mask */
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO PIN: PIN Position */   
N#define GPIO_PIN_PIN_Msk            (0xFFFFul << GPIO_PIN_PIN_Pos)              /*!< GPIO PIN: PIN Mask */
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO DBEN: DBEN Position */
N#define GPIO_DBEN_DBEN_Msk          (0xFFFFul << GPIO_DBEN_DBEN_Pos)            /*!< GPIO DBEN: DBEN Mask */
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO IMD: IMD Position */
N#define GPIO_IMD_IMD_Msk            (0xFFFFul << GPIO_IMD_IMD_Pos)              /*!< GPIO IMD: IMD Mask */
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO IEN: IR_EN Position */
N#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)            /*!< GPIO IEN: IR_EN Mask */
N
N#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO IEN: IF_EN Position */
N#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)            /*!< GPIO IEN: IF_EN Mask */
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO ISRC: ISRC Position */
N#define GPIO_ISRC_ISRC_Msk          (0xFFFFul << GPIO_ISRC_ISRC_Pos)            /*!< GPIO ISRC: ISRC Mask */
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO DBNCECON: ICLK_ON  Position */
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO DBNCECON: ICLK_ON  Mask */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO DBNCECON: DBCLKSRC Position */
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO DBNCECON: DBCLKSRC Mask */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO DBNCECON: DBCLKSEL Position */
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO DBNCECON: DBCLKSEL Mask */
N/*@}*/ /* end of group NUC200_GPIO */
N
N
N
N/*------------------------- UART Interface Controller ------------------------*/
N
N/** @addtogroup NUC200_UART NUC200 UART
N  Memory Mapped Structure for NUC200 Series UART Serial Interface Controller
N  @{
N */
Ntypedef struct
N{
N                                
N    union {                             
N    __IO uint32_t DATA;                 
X    volatile uint32_t DATA;                 
N
N    /**
N     * THR
N     * ===================================================================================================
N     * Offset: 0x00 Transmit Holding DATA
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |          |bitTransmittedData
N     * |        |          |Transmit Holding Register
N     * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB 
N     * |        |          |first).
N     */    
N    __IO uint32_t THR;                  
X    volatile uint32_t THR;                  
N
N    /**
N     * RBR
N     * ===================================================================================================
N     * Offset: 0x00 Receive Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |          |Receive Buffer Register
N     * |        |          |By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).
N     */    
N    __IO uint32_t RBR;                  
X    volatile uint32_t RBR;                  
N    };
N
N    /**
N     * IER
N     * ===================================================================================================
N     * Offset: 0x04  UART Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable.
N     * |        |          |0 = Mask off INT_RDA
N     * |        |          |1 = Enable INT_RDA
N     * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable
N     * |        |          |0 = Mask off INT_THRE
N     * |        |          |1 = Enable INT_THRE
N     * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable 
N     * |        |          |0 = Mask off INT_RLS
N     * |        |          |1 = Enable INT_RLS
N     * |[3]     |Modem_IEN |Modem Status Interrupt Enable 
N     * |        |          |0 = Mask off INT_MOS
N     * |        |          |1 = Enable INT_MOS
N     * |[4]     |RTO_IEN   |Rx Time out Interrupt Enable
N     * |        |          |0 = Mask off INT_tout
N     * |        |          |1 = Enable INT_tout 
N     * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable
N     * |        |          |0 = Mask off INT_Buf_err
N     * |        |          |1 = Enable INT_Buf_err
N     * |[6]     |Wake_EN   |Wake up CPU function enable 
N     * |        |          |0 = Disable UART wake up CPU function
N     * |        |          |1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS 
N     * |        |          |change will wake up CPU from deep sleep mode.
N     * |[11]    |Time_Out_EN|Time-Out Counter Enable
N     * |        |          |1 = Enable Time-out counter.
N     * |        |          |0 = Disable Time-out counter.
N     * |[12]    |Auto_RTS_EN|RTS Auto Flow Control Enable 
N     * |        |          |1 = Enable RTS auto flow control.
N     * |        |          |0 = Disable RTS auto flow control.
N     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR 
N     * |[RTS_Tri_Lev], the UART will dessert RTS signal.|[13]      |Auto_CTS_EN
N     * |        |          |CTS Auto Flow Control Enable
N     * |        |          |1 = Enable CTS auto flow control.
N     * |        |          |0 = Disable CTS auto flow control.
N     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input 
N     * |        |          |assert (UART will not send data to device until CTS is asserted).
N     */    
N    __IO uint32_t IER;                  
X    volatile uint32_t IER;                  
N
N    /**
N     * FCR
N     * ===================================================================================================
N     * Offset: 0x08  UART FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RFR       |Rx Software Reset
N     * |        |          |When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are 
N     * |        |          |cleared.
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
N     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
N     * |[2]     |TFR       |Tx Software Reset
N     * |        |          |When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are 
N     * |        |          |cleared.
N     * |        |          |0 = Writing 0 to this bit has no effect.
N     * |        |          |1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
N     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
N     * |[7:4]   |RFITL     |Word Length Select
N     * |        |          |INTR_RDA Tigger Level(Bytes)
N     * |        |          |0000 = 01 Bytes
N     * |        |          |0001 = 04 Bytes
N     * |        |          |0010 = 08 Bytes
N     * |        |          |0011 = 14 Bytes
N     * |[8]     |RX_DIS    |Receiver Disable register.
N     * |        |          |The receiver is disabled or not (set 1 is disable receiver)
N     * |        |          |1: Disable Receiver
N     * |        |          |0: Enable Receiver
N     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before 
N     * |        |          |RS-485 enable function in UA_FUN_SEL. FUN_SEL is programmed.
N     * |[19:16] |RTS_Tri_Lev|Word Length Select
N     * |        |          |0000 = 01 Bytes
N     * |        |          |0001 = 04 Bytes
N     * |        |          |0010 = 08 Bytes
N     * |        |          |0011 = 14 Bytes
N     */    
N    __IO uint32_t FCR;                  
X    volatile uint32_t FCR;                  
N
N    /**
N     * LCR
N     * ===================================================================================================
N     * Offset: 0x0C  UART Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WLS       |Word Length Select
N     * |        |          |00 = 5 bits
N     * |        |          |01 = 6 bits
N     * |        |          |10 = 7 bits
N     * |        |          |11 = 8 bits
N     * |[2]     |NSB       |Number of "STOP bit"
N     * |        |          |0= One "STOP bit" is generated in the transmitted data
N     * |        |          |1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
N     * |        |          |Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.
N     * |[3]     |PBE       |Parity Bit Enable
N     * |        |          |0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
N     * |        |          |1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
N     * |[4]     |EPE       |Even Parity Enable
N     * |        |          |0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
N     * |        |          |1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
N     * |        |          |This bit has effect only when bit 3 (parity bit enable) is set.
N     * |[5]     |SPE       |Stick Parity Enable 
N     * |        |          |0 = Disable stick parity 
N     * |        |          |1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When 
N     * |        |          |PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.
N     * |[6]     |BCB       |Break Control Bit 
N     * |        |          |When this bit is set to logic 1, the serial data output (Tx) is forced to the Spacing State (logic 0). This bit 
N     * |        |          |acts only on Tx and has no effect on the transmitter logic.
N     */    
N    __IO uint32_t LCR;                  
X    volatile uint32_t LCR;                  
N
N    /**
N     * MCR
N     * ===================================================================================================
N     * Offset: 0x10  UART Modem Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RTS       |RTS (Request-To-Send) Signal 
N     * |        |          |0: Drive RTS pin to logic 1 (If the Lev_RTS set to low level triggered).
N     * |        |          |1: Drive RTS pin to logic 0 (If the Lev_RTS set to low level triggered).
N     * |        |          |0: Drive RTS pin to logic 0 (If the Lev_RTS set to high level triggered).
N     * |        |          |1: Drive RTS pin to logic 1 (If the Lev_RTS set to high level triggered).
N     * |[9]     |Lev_RTS   |RTS Trigger Level 
N     * |        |          |This bit can change the RTS trigger level.
N     * |        |          |0= low level triggered
N     * |        |          |1= high level triggered
N     * |[13]    |RTS_St    |RTS Pin State 
N     * |        |          |This bit is the pin status of RTS.
N     */    
N    __IO uint32_t MCR;                  
X    volatile uint32_t MCR;                  
N
N    /**
N     * MSR
N     * ===================================================================================================
N     * Offset: 0x14  UART Modem Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DCTSF     |Detect CTS State Change Flag 
N     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU 
N     * |        |          |when IER [Modem_IEN].
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[4]     |CTS_St    |CTS Pin Status 
N     * |        |          |This bit is the pin status of CTS. 
N     * |[8]     |Lev_CTS   |CTS Trigger Level
N     * |        |          |This bit can change the CTS trigger level.
N     * |        |          |0= low level triggered
N     * |        |          |1= high level triggered
N     */    
N    __IO uint32_t MSR;                  
X    volatile uint32_t MSR;                  
N
N    /**
N     * FSR
N     * ===================================================================================================
N     * Offset: 0x18  UART FIFO Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |Rx_Over_IF|Rx overflow Error IF (Read Only) 
N     * |        |          |This bit is set when Rx FIFO overflow.
N     * |        |          |If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 16 bytes of 
N     * |        |          |UART0/UART1, this bit will be set.
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[3]     |RS-       |485_Add_Det
N     * |        |          |RS-485 Address Byte Detection Flag
N     * |        |          |This bit is set to logic 1 and set UA_RS-485_CSR [RS-485_Add_EN] whenever in RS-485 
N     * |        |          |mode the receiver detect any address byte received address byte character (bit9 = '1') bit", 
N     * |        |          |and it is reset whenever the CPU writes 1 to this bit.
N     * |        |          |Note: This field is used for RS-485 mode.
N     * |[4]     |PEF       |Parity Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", 
N     * |        |          |and is reset whenever the CPU writes 1 to this bit.
N     * |[5]     |FEF       |Framing Error Flag
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that 
N     * |        |          |is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset 
N     * |        |          |whenever the CPU writes 1 to this bit.
N     * |[6]     |BIF       |Break Interrupt Flag
N     * |        |          |This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" 
N     * |        |          |(logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data 
N     * |        |          |bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
N     * |[13:8]  |Rx_Pointer|Rx FIFO pointer (Read Only)
N     * |        |          |This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external 
N     * |        |          |device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer 
N     * |        |          |decreases one.
N     * |[14]    |Rx_Empty  |Receiver FIFO Empty (Read Only)
N     * |        |          |This bit initiate Rx FIFO empty or not.
N     * |        |          |When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be 
N     * |        |          |cleared when UART receives any new data.
N     * |[15]    |Rx_Full   |Receiver FIFO Full (Read Only)
N     * |        |          |This bit initiates Rx FIFO full or not.
N     * |        |          |This bit is set when Rx_Pointer is equal to 16(UART0/UART1), otherwise is cleared by 
N     * |        |          |hardware.
N     * |[21:16] |Tx_Pointer|TX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, 
N     * |        |          |Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift 
N     * |        |          |Register, Tx_Pointer decreases one.
N     * |[22]    |Tx_Empty  |Transmitter FIFO Empty (Read Only)
N     * |        |          |This bit indicates Tx FIFO empty or not.
N     * |        |          |When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware 
N     * |        |          |sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).
N     * |[23]    |Tx_Full   |Transmitter FIFO Full (Read Only)
N     * |        |          |This bit indicates Tx FIFO full or not.
N     * |        |          |This bit is set when Tx_Pointer is equal to 64/16(UART0/UART1), otherwise is cleared by 
N     * |        |          |hardware.
N     * |[24]    |Tx_Over_IF|Tx Overflow Error Interrupt Flag (Read Only)
N     * |        |          |If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
N     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
N     * |[28]    |TE_Flag   |Transmitter Empty Flag (Read Only)
N     * |        |          |Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte 
N     * |        |          |has been transmitted.
N     * |        |          |Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not 
N     * |        |          |completed.
N     * |        |          |NOTE: This bit is read only. 
N     */    
N    __IO uint32_t FSR;                  
X    volatile uint32_t FSR;                  
N
N    /**
N     * ISR
N     * ===================================================================================================
N     * Offset: 0x1C  UART Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only).
N     * |        |          |When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If 
N     * |        |          |IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
N     * |        |          |NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO 
N     * |        |          |drops below the threshold level (RFITL).
N     * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only). 
N     * |        |          |This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If 
N     * |        |          |IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and it will be cleared when writing data into THR (Tx FIFO not empty).
N     * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only).
N     * |        |          |In UART mode this bit is set when the Rx receive data have parity error, framing error or break 
N     * |        |          |error (at least one of 3 bits, BIF, FEF and PEF, is set). In RS-485 mode, the field includes RS-485 
N     * |        |          |Address Byte Detection Flag. If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS-485_Add_Det 
N     * |        |          |are cleared.
N     * |[3]     |Modem_IF  |MODEM Interrupt Flag (Read Only) 
N     * |        |          |This bit is set when the CTS pin has state change (DCTSF=1). If IER[Modem_IEN] is enabled, the 
N     * |        |          |Modem interrupt will be generated.
N     * |        |          |NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.
N     * |[4]     |Tout_IF   |Time Out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Rx FIFO is not empty and no activities occur in the Rx FIFO and the time 
N     * |        |          |out counter equal to TOIC. If IER [Tout_IEN] is enabled, the Tout interrupt will be generated. 
N     * |        |          |NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.
N     * |[5]     |Buf_Err_IF|Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When 
N     * |        |          |Buf_Err_IF is set, the transfer maybe not correct. If IER[Buf_Err_IEN] is enabled, the buffer error 
N     * |        |          |interrupt will be generated.
N     * |        |          |NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared. 
N     * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator to Interrupt Controller (INT_RDA).
N     * |        |          |An AND output with inputs of RDA_IEN and RDA_IF
N     * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller (INT_THRE).
N     * |        |          |An AND output with inputs of THRE_IEN and THRE_IF
N     * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator to Interrupt Controller (INT_RLS). 
N     * |        |          |An AND output with inputs of RLS_IEN and RLS_IF
N     * |        |          |Note: In RS-485 mode, the field includes RS-485 Address Byte Detection Flag.
N     * |[11]    |Modem_INT |MODEM Status Interrupt Indicator to Interrupt Controller (INT_MOS). 
N     * |        |          |An AND output with inputs of Modem_IEN and Modem_IF
N     * |[12]    |Tout_INT  |Time Out Interrupt Indicator to Interrupt Controller (INT_Tout)
N     * |        |          |An AND output with inputs of RTO_IEN and Tout_IF
N     * |[13]    |Buf_Err_INT|Buffer Error Interrupt Indicator to Interrupt Controller (INT_Buf_err)
N     * |        |          |An AND output with inputs of BUF_ERR_IEN and Buf_Err_IF
N     */    
N    __IO uint32_t ISR;                  
X    volatile uint32_t ISR;                  
N
N    /**
N     * TOR
N     * ===================================================================================================
N     * Offset: 0x20  UART Time Out Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:0]   |TOIC      |Time Out Interrupt Comparator
N     * |        |          |The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO 
N     * |        |          |receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out 
N     * |        |          |interrupt comparator (TOIC), a receiver time out interrupt (INT_TOUT) is generated if UA_IER[RTO_IEN]. 
N     * |        |          |A new incoming data word or RX FIFO empty clears INT_TOUT. 
N     * |[15:8]  |DLY       |TX Delay time value
N     * |        |          |This field is use to programming the transfer delay time between the last stop bit leaving the TX-FIFO 
N     * |        |          |and the de-assertion of by setting UA_TOR. DLY register.
N     */    
N    __IO uint32_t TOR;                  
X    volatile uint32_t TOR;                  
N
N    /**
N     * BAUD
N     * ===================================================================================================
N     * Offset: 0x24  UART Baud Rate Divisor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |BRD_LowByte|Baud Rate Divider 
N     * |        |          |The low byte of the baud rate divider
N     * |[15:8]  |BRD_HighByte|Baud Rate Divider 
N     * |        |          |The high byte of the baud rate divider
N     * |[27:24] |Divider_X |Divider X
N     * |        |          |The baud rate divider M = X+1.
N     * |[28]    |DIV_X_ONE |Divider X equal 1
N     * |        |          |0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must > 8)
N     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must > 3).
N     * |[29]    |DIV_X_EN  |Divider X Enable
N     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is  
N     * |        |          |Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
N     * |        |          |0 = Disable divider X (the equation of M = 16)
N     * |        |          |1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must > 8).
N     * |        |          |NOTE: When in IrDA mode, this bit must disable.
N     */    
N    __IO uint32_t BAUD;                 
X    volatile uint32_t BAUD;                 
N
N    /**
N     * IRCR
N     * ===================================================================================================
N     * Offset: 0x28  UART IrDA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |Tx_SELECT |Tx_SELECT
N     * |        |          |1: Enable IrDA transmitter
N     * |        |          |0: Enable IrDA receiver
N     * |[2]     |LB        |IrDA loop back mode for self test.
N     * |        |          |1: Enable IrDA loop back mode
N     * |        |          |0: Disable IrDA loop back mode
N     * |[5]     |INV_Tx    |INV_Tx
N     * |        |          |1= Inverse Tx output signal
N     * |        |          |0= No inversion
N     * |[6]     |INV_Rx    |INV_Rx
N     * |        |          |1= Inverse Rx input signal
N     * |        |          |0= No inversion
N     */    
N    __IO uint32_t IRCR;                 
X    volatile uint32_t IRCR;                 
N
N    /**
N     * ALT_CSR
N     * ===================================================================================================
N     * Offset: 0x2C  UART Alternate Control/Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |RS-485_NMM|RS-485 Normal Multi-drop Operation Mode (NMM)
N     * |        |          |1: Enable RS-485 Normal Multi-drop Operation Mode (NMM)
N     * |        |          |0: Disable RS-485 Normal Multi-drop Operation Mode (NMM)
N     * |        |          |Note: It can't be active with RS-485_AAD operation mode.
N     * |[9]     |RS-485_AAD|RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |1: Enable RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |0: Disable RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |Note: It can't be active with RS-485_NMM operation mode.
N     * |[10]    |RS-485_AUD|RS-485 Auto Direction Mode (AUD)
N     * |        |          |1: Enable RS-485 Auto Direction Mode (AUD)
N     * |        |          |0: Disable RS-485 Auto Direction Mode (AUD)
N     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N     * |[15]    |RS-485_Add_EN|RS-485 Address Detection Enable
N     * |        |          |This bit is use to enable RS-485 address detection mode. 
N     * |        |          |1: Enable address detection mode
N     * |        |          |0: Disable address detection mode 
N     * |        |          |Note: This field is used for RS-485 any operation mode.
N     * |[31:24] |ADDR_MATCH|Address match value register
N     * |        |          |This field contains the RS-485 address match values.
N     * |        |          |Note: This field is used for RS-485 auto address detection mode.
N     */    
N    __IO uint32_t ALT_CSR;               
X    volatile uint32_t ALT_CSR;               
N
N    /**
N     * FUN_SEL
N     * ===================================================================================================
N     * Offset: 0x30  UART Function Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FUN_SEL   |Function Select Enable
N     * |        |          |00 = UART Function.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Enable IrDA Function.
N     * |        |          |11 = Enable RS-485 Function.
N     */    
N    __IO uint32_t FUN_SEL;               
X    volatile uint32_t FUN_SEL;               
N    __IO uint32_t LIN_CTL; 
X    volatile uint32_t LIN_CTL; 
N    __IO uint32_t LIN_SR; 
X    volatile uint32_t LIN_SR; 
N} UART_T;
N
N
N
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos         0                                          /*!< UART THR: THR Position  */
N#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos         0                                          /*!< UART RBR: RBR Posistion */
N#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_DMA_RX_EN_Pos      15                                      /*!< UART IER: RX DMA Enable Posistion */  
N#define UART_IER_DMA_RX_EN_Msk      (1ul << UART_IER_DMA_RX_EN_Pos)         /*!< UART IER: RX DMA Enable Mask      */  
N
N#define UART_IER_DMA_TX_EN_Pos      14                                      /*!< UART IER: TX DMA Enable Posistion */  
N#define UART_IER_DMA_TX_EN_Msk      (1ul << UART_IER_DMA_TX_EN_Pos)         /*!< UART IER: TX DMA Enable Mask      */  
N
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART IER: AUTO_CTS_EN Posistion      */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART IER: AUTO_CTS_EN Mask           */
N
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART IER: AUTO_RTS_EN Posistion      */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART IER: TIME_OUT_EN Posistion      */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_LIN_RX_BRK_IEN_Pos 8                                       /*!< UART IER: LIN_RX_BRK_IEN Posistion   */
N#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)    /*!< UART IER: LIN_RX_BRK_IEN Mask        */
N
N#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART IER: WAKE_EN Posistion          */
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART IER: WAKE_EN Mask               */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART IER: BUF_ERR_IEN Posistion      */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART IER: RTO_IEN Posistion          */
N#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART IER: RTO_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART IER: MODEM_IEN Posistion        */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART IER: RLS_IEN Posistion          */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART IER: THRE_IEN Posistion         */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART MCR: RTS Mask                   */
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART MSR: DCTST Mask                 */
N
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_HW_LIN_RX_BREAK_INT_Pos   31                                           /*!< UART ISR: HW LIN_RX_BREAK_INT Position       */
N#define UART_ISR_HW_LIN_RX_BREAK_INT_Msk   (1ul << UART_ISR_HW_LIN_RX_BREAK_INT_Pos)    /*!< UART ISR: HW LIN_RX_BREAK_INT Mask           */
N
N#define UART_ISR_HW_BUF_ERR_INT_Pos        29                                       /*!< UART ISR: HW BUF_ERR_INT Position       */
N#define UART_ISR_HW_BUF_ERR_INT_Msk        (1ul << UART_ISR_HW_BUF_ERR_INT_Pos)     /*!< UART ISR: HW BUF_ERR_INT Mask           */
N
N#define UART_ISR_HW_TOUT_INT_Pos           28                                       /*!< UART ISR: HW TOUT_INT Position          */
N#define UART_ISR_HW_TOUT_INT_Msk           (1ul << UART_ISR_HW_TOUT_INT_Pos)        /*!< UART ISR: HW TOUT_INT Mask              */
N
N#define UART_ISR_HW_MODEM_INT_Pos          27                                       /*!< UART ISR: HW MODEM_INT Position         */
N#define UART_ISR_HW_MODEM_INT_Msk          (1ul << UART_ISR_HW_MODEM_INT_Pos)       /*!< UART ISR: HW MODEM_INT Mask             */
N    
N#define UART_ISR_HW_RLS_INT_Pos            26                                       /*!< UART ISR: HW RLS_INT Position           */
N#define UART_ISR_HW_RLS_INT_Msk            (1ul << UART_ISR_HW_RLS_INT_Pos)         /*!< UART ISR: HW RLS_INT Position           */
N
N#define UART_ISR_HW_LIN_RX_BREAK_IF_Pos    23                                       /*!< UART ISR: HW LIN_RX_BREAK_IF Position  */
N#define UART_ISR_HW_LIN_RX_BREAK_IF_Msk    (1ul << UART_ISR_HW_LIN_RX_BREAK_IF_Pos) /*!< UART ISR: HW LIN_RX_BREAK_IF Mask      */
N
N#define UART_ISR_HW_BUF_ERR_IF_Pos         21                                       /*!< UART ISR: HW BUF_ERR_IF Position       */
N#define UART_ISR_HW_BUF_ERR_IF_Msk         (1ul << UART_ISR_HW_BUF_ERR_IF_Pos)      /*!< UART ISR: HW BUF_ERR_IF Mask           */
N
N#define UART_ISR_HW_TOUT_IF_Pos            20                                       /*!< UART ISR: HW TOUT_IF Position          */
N#define UART_ISR_HW_TOUT_IF_Msk            (1ul << UART_ISR_HW_TOUT_IFF_Pos)        /*!< UART ISR: HW TOUT_IF Mask              */
N
N#define UART_ISR_HW_MODEM_IF_Pos           19                                       /*!< UART ISR: HW MODEM_IF Position         */
N#define UART_ISR_HW_MODEM_IF_Msk           (1ul << UART_ISR_HW_MODEM_IF_Pos)        /*!< UART ISR: HW MODEM_IF Mask             */
N
N#define UART_ISR_HW_RLS_IF_Pos             18                                       /*!< UART ISR: HW RLS_IF Position           */
N#define UART_ISR_HW_RLS_IF_Msk             (1ul << UART_ISR_HW_RLS_IF_Pos)          /*!< UART ISR: HW RLS_IF Mark               */
N
N#define UART_ISR_LIN_RX_BREAK_INT_Pos    15                                      /*!< UART ISR: LIN_RX_BREAK_INT Position       */
N#define UART_ISR_LIN_RX_BREAK_INT_Msk    (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)  /*!< UART ISR: LIN_RX_BREAK_INT Mask           */
N
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART ISR: RDA_INT Mask               */
N
N#define UART_ISR_LIN_RX_BREAK_IF_Pos 7                                      /*!< UART ISR: LIN RX BREAK IF Position   */
N#define UART_ISR_LIN_RX_BREAK_IF_Msk (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)  /*!< UART ISR: LIN RX BREAK IF Mask       */
N           
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART ISR: RDA_IF Mask                */
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos           8                                        /*!< UART TOR: DLY Position               */
N#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos          0                                        /*!< UART TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
N
N#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
N
N#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
N
N#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
N#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART ALT_CSR: RS485_NMM Mask         */
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART ALT_CSR: LIN TX Break Mode Enable Position     */
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART ALT_CSR: LIN TX Break Mode Enable Mask         */
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART ALT_CSR: LIN RX Enable Position     */
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART ALT_CSR: LIN RX Enable Mask         */
N
N#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART ALT_CSR: UART LIN Break Field Length Position     */
N#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART ALT_CSR: UART LIN Break Field Length Mask         */
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART FUN_SEL: FUN_SEL Mask           */
N
N/* UART LIN_CTL Bit Field Definitions */
N#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART LIN_CTL: LIN_PID Position       */
N#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART LIN_CTL: LIN_PID Mask           */
N
N#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART LIN_CTL: LIN_HEAD_SEL Position       */
N#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART LIN_CTL: LIN_HEAD_SEL Mask           */
N
N#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART LIN_CTL: LIN_BS_LEN Position       */
N#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART LIN_CTL: LIN_BS_LEN Mask           */
N
N#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART LIN_CTL: LIN_BKFL Position       */
N#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART LIN_CTL: LIN_BKFL Mask           */
N
N#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART LIN_CTL: BIT_ERR_EN Position       */
N#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART LIN_CTL: BIT_ERR_EN Mask           */
N
N#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART LIN_CTL: LIN_RX_DIS Position       */
N#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART LIN_CTL: LIN_RX_DIS Mask           */
N
N#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART LIN_CTL: LIN_BKDET_EN Position       */
N#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART LIN_CTL: LIN_BKDET_EN Mask           */
N
N#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART LIN_CTL: LIN_IDPEN Position       */
N#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART LIN_CTL: LIN_IDPEN Mask           */
N
N#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART LIN_CTL: LIN_SHD Position       */
N#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART LIN_CTL: LIN_SHD Mask           */
N
N#define UART_LIN_CTL_LIN_WAKE_EN_Pos    4                                          /*!< UART LIN_CTL: LIN_WAKE_EN Position       */
N#define UART_LIN_CTL_LIN_WAKE_EN_Msk    (1ul << UART_LIN_CTL_LIN_WAKE_EN_Pos)      /*!< UART LIN_CTL: LIN_WAKE_EN Mask           */
N
N#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART LIN_CTL: LINS_DUM_EN Position       */
N#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART LIN_CTL: LINS_DUM_EN Mask           */
N
N#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART LIN_CTL: LINS_ARS_EN Position       */
N#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART LIN_CTL: LINS_ARS_EN Mask           */
N
N#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART LIN_CTL: LINS_HDET_EN Position       */
N#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART LIN_CTL: LINS_HDET_EN Mask           */
N
N#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART LIN_CTL: LINS_EN Position       */
N#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART LIN_CTL: LINS_EN Mask           */
N
N/* UART LIN_SR Bit Field Definitions */
N#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART LIN_SR: LINS_SYNC_F Position       */
N#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART LIN_SR: LINS_SYNC_F Mask           */
N
N#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART LIN_SR: LINS_IDPERR_F Position       */
N#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART LIN_SR: LINS_IDPERR_F Mask           */
N
N#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART LIN_SR: LINS_HERR_F Position       */
N#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART LIN_SR: LINS_HERR_F Mask           */
N
N#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART LIN_SR: LINS_HDET_F Position       */
N#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART LIN_SR: LINS_HDET_F Mask           */
N
N/*@}*/ /* end of group NUC200_UART */
N
N
N/*----------------------------- Timer Controller (TMR) -----------------------------*/
N/** @addtogroup NUC200_TIMER NUC200 TIMER
N  Memory Mapped Structure for NUC200 Series Timer Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * TCSR
N     * ===================================================================================================
N     * Offset: 0x00  Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TCSR;                
X    volatile uint32_t  TCSR;                
N
N    /**
N     * TCMPR
N     * ===================================================================================================
N     * Offset: 0x04  Timer Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TCMPR;		        
X    volatile uint32_t  TCMPR;		        
N
N    /**
N     * TISR
N     * ===================================================================================================
N     * Offset: 0x08  Timer Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TISR;		        
X    volatile uint32_t  TISR;		        
N
N    /**
N     * TDR
N     * ===================================================================================================
N     * Offset: 0x0C  Timer Data Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  TDR;			        
X    volatile const  uint32_t  TDR;			        
N
N    /**
N     * TCAP
N     * ===================================================================================================
N     * Offset: 0x10  Timer Capture Data Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  TCAP;		        
X    volatile const  uint32_t  TCAP;		        
N
N    /**
N     * TEXCON
N     * ===================================================================================================
N     * Offset: 0x14  Timer External Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TEXCON;	            
X    volatile uint32_t  TEXCON;	            
N
N    /**
N     * TEXISR
N     * ===================================================================================================
N     * Offset: 0x18  Timer External Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  TEXISR;	            
X    volatile uint32_t  TEXISR;	            
N} TIMER_T;
N
N/* TIMER TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31											/*!< TIMER TCSR: DBGACK_TMR Position */
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER TCSR: DBGACK_TMR Mask */
N
N#define TIMER_TCSR_CEN_Pos          30											/*!< TIMER TCSR: CEN Position */
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)				    /*!< TIMER TCSR: CEN Mask */
N
N#define TIMER_TCSR_IE_Pos           29											/*!< TIMER TCSR: IE Position */
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)					/*!< TIMER TCSR: IE Mask */
N                                                                                 
N#define TIMER_TCSR_MODE_Pos         27											/*!< TIMER TCSR: MODE Position */
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)				/*!< TIMER TCSR: MODE Mask */
N
N#define TIMER_TCSR_CRST_Pos         26											/*!< TIMER TCSR: CRST Position */
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)				/*!< TIMER TCSR: CRST Mask */
N
N#define TIMER_TCSR_CACT_Pos         25											/*!< TIMER TCSR: CACT Position */
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)				/*!< TIMER TCSR: CACT Mask */
N
N#define TIMER_TCSR_CTB_Pos          24											/*!< TIMER TCSR: CTB Position */
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)					/*!< TIMER TCSR: CTB Mask */
N
N#define TIMER_TCSR_WAKE_EN_Pos      23											/*!< TIMER TCSR: WAKE_EN Position */
N#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)			    /*!< TIMER TCSR: WAKE_EN Mask */
N
N#define TIMER_TCSR_TDR_EN_Pos       16											/*!< TIMER TCSR: TDR_EN Position */
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)				/*!< TIMER TCSR: TDR_EN Mask */
N
N#define TIMER_TCSR_PRESCALE_Pos     0											/*!< TIMER TCSR: PRESCALE Position */
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)			/*!< TIMER TCSR: PRESCALE Mask */
N
N/* TIMER TCMPR Bit Field Definitions */
N#define TIMER_TCMP_TCMP_Pos         0											/*!< TIMER TCMPR: TCMP Position */
N#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)		    /*!< TIMER TCMPR: TCMP Mask */
N
N/* TIMER TISR Bit Field Definitions */
N#define TIMER_TISR_TWF_Pos          1											/*!< TIMER TISR: TWF Position */
N#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)					/*!< TIMER TISR: TWF Mask */
N
N#define TIMER_TISR_TIF_Pos          0											/*!< TIMER TISR: TIF Position */
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)					/*!< TIMER TISR: TIF Mask */
N
N/* TIMER TDR Bit Field Definitions */
N#define TIMER_TDR_TDR_Pos           0								            /*!< TIMER TDR: TDR Position */
N#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)	        /*!< TIMER TDR: TDR Mask */
N
N/* TIMER TCAP Bit Field Definitions */
N#define TIMER_TCAP_TCAP_Pos         0									        /*!< TIMER TCAP: TCAP Position */
N#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER TCAP: TCAP Mask */
N
N/* TIMER TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_TCDB_Pos       7											/*!< TIMER TEXCON: TCDB Position */
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)				/*!< TIMER TEXCON: TCDB Mask */
N
N#define TIMER_TEXCON_TEXDB_Pos      6											/*!< TIMER TEXCON: TEXDB Position */
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)				/*!< TIMER TEXCON: TEXDB Mask */
N
N#define TIMER_TEXCON_TEXIEN_Pos     5											/*!< TIMER TEXCON: TEXIEN Position */
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)			/*!< TIMER TEXCON: TEXIEN Mask */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4											/*!< TIMER TEXCON: RSTCAPSEL Position */
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)			/*!< TIMER TEXCON: RSTCAPSEL Mask */
N
N#define TIMER_TEXCON_TEXEN_Pos      3											/*!< TIMER TEXCON: TEXEN Position */
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)				/*!< TIMER TEXCON: TEXEN Mask */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1											/*!< TIMER TEXCON: TEX_EDGE Position */
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)		/*!< TIMER TEXCON: TEX_EDGE Mask */
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0											/*!< TIMER TEXCON: TX_PHASE Position */
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)			/*!< TIMER TEXCON: TX_PHASE Mask */
N
N/* TIMER TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0											/*!< TIMER TEXISR: TEXIF Position */
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)				/*!< TIMER TEXISR: TEXIF Mask */
N/*@}*/ /* end of group NUC200_TIMER */
N
N
N/*----------------------------- Watchdog Timer (WDT) -----------------------------*/
N/** @addtogroup NUC200_WDT NUC200 WDT
N  Memory Mapped Structure for NUC200 Series Watchdog Timer
N  @{
N */
Ntypedef struct
N{
N    /**
N     * WTCR
N     * ===================================================================================================
N     * Offset: 0x00  Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WTCR;                 
X    volatile uint32_t  WTCR;                 
N
N    /**
N     * WTCRALT
N     * ===================================================================================================
N     * Offset: 0x04  Watchdog Timer Alternative Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WTCRALT;              
X    volatile uint32_t  WTCRALT;              
N} WDT_T;
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT WTCR : DBGACK_WDT Position */
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT WTCR : DBGACK_WDT Mask */
N
N#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT WTCR : WTIS Position */
N#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT WTCR : WTIS Mask */
N
N#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT WTCR : WTE Position */
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT WTCR : WTE Mask */
N
N#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT WTCR : WTIE Position */
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT WTCR : WTIE Mask */
N
N#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT WTCR : WTWKF Position */
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT WTCR : WTWKF Mask */
N
N#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT WTCR : WTWKE Position */
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT WTCR : WTWKE Mask */
N
N#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT WTCR : WTIF Position */
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT WTCR : WTIF Mask */
N
N#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT WTCR : WTRF Position */
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT WTCR : WTRF Mask */
N
N#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT WTCR : WTRE Position */
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT WTCR : WTRE Mask */
N
N#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT WTCR : WTR Position */
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT WTCR : WTR Mask */
N
N/* WDT WTCRALT Bit Field Definitions */
N#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT WTCRALT : WTRDSEL Position */
N#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT WTCRALT : WTRDSEL Mask */
N/*@}*/ /* end of group NUC200_WDT */
N
N
N/*----------------------------- Window Watchdog Timer (WWDT) -----------------------------*/
N/** @addtogroup NUC200_WWDT NUC200 WWDT
N  Memory Mapped Structure for NUC200 Series Window Watchdog Timer
N  @{
N */
Ntypedef struct
N{
N    /**
N     * WWDTRLD
N     * ===================================================================================================
N     * Offset: 0x00  Window Watchdog Timer Reload Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WWDTRLD;
X    volatile uint32_t  WWDTRLD;
N
N    /**
N     * WWDTCR
N     * ===================================================================================================
N     * Offset: 0x04  Window Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WWDTCR;
X    volatile uint32_t  WWDTCR;
N
N    /**
N     * WWDTSR
N     * ===================================================================================================
N     * Offset: 0x08  Window Watchdog Timer Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WWDTSR;
X    volatile uint32_t  WWDTSR;
N
N    /**
N     * WWDTCVR
N     * ===================================================================================================
N     * Offset: 0x0C  Window Watchdog Timer Counter Value Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  WWDTCVR;
X    volatile const  uint32_t  WWDTCVR;
N} WWDT_T;
N
N/* WWDT WWDTRLD Bit Field Definitions */
N#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT WWDTRLD : WWDTRLD Position */
N#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT WWDTRLD : WWDTRLD Mask */
N
N/* WWDT WWDTCR Bit Field Definitions */
N#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT WWDTCR : DBGACK_WWDT Position */
N#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT WWDTCR : DBGACK_WWDT Mask */
N
N#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT WWDTCR : WINCMP Position */
N#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT WWDTCR : WINCMP Mask */
N
N#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT WWDTCR : PERIODSEL Position */
N#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT WWDTCR : PERIODSEL Mask */
N
N#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT WWDTCR : WWDTIE Position */
N#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT WWDTCR : WWDTIE Mask */
N
N#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT WWDTCR : WWDTEN Position */
N#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT WWDTCR : WWDTEN Mask */
N
N/* WWDT WWDTSR Bit Field Definitions */
N#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT WWDTSR : WWDTRF Position */
N#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT WWDTSR : WWDTRF Mask */
N
N#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT WWDTSR : WWDTIF Position */
N#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT WWDTSR : WWDTIF Mask */
N
N/* WWDT WWDTCVR Bit Field Definitions */
N#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT WWDTCVR : WWDTRF Position */
N#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT WWDTCVR : WWDTRF Mask */
N/*@}*/ /* end of group NUC200_WWDT */
N
N
N/*------------------------- SPI Interface Controller -------------------------*/
N/** @addtogroup NUC200_SPI NUC200 SPI
N  Memory Mapped Structure for NUC200 Series SPI Controller
N  @{
N */
Ntypedef struct
N{
N    __IO uint32_t CNTRL;      /*!< Offset: 0x00  SPI Control and Status Register   */
X    volatile uint32_t CNTRL;       
N    __IO uint32_t DIVIDER;    /*!< Offset: 0x04  SPI Clock Divider Register        */
X    volatile uint32_t DIVIDER;     
N    __IO uint32_t SSR;        /*!< Offset: 0x08  SPI Slave Select Register         */
X    volatile uint32_t SSR;         
N    __I  uint32_t RESERVE0;
X    volatile const  uint32_t RESERVE0;
N    __I  uint32_t RX[2];      /*!< Offset: 0x10  Data Receive Register             */
X    volatile const  uint32_t RX[2];       
N    __I  uint32_t RESERVE1;
X    volatile const  uint32_t RESERVE1;
N    __I  uint32_t RESERVE2;
X    volatile const  uint32_t RESERVE2;
N    __O  uint32_t TX[2];      /*!< Offset: 0x20  Data Transmit Register            */
X    volatile  uint32_t TX[2];       
N    __I  uint32_t RESERVE3;
X    volatile const  uint32_t RESERVE3;
N    __I  uint32_t RESERVE4;
X    volatile const  uint32_t RESERVE4;
N    __I  uint32_t RESERVE5;
X    volatile const  uint32_t RESERVE5;
N    __IO uint32_t VARCLK;     /*!< Offset: 0x34  Variable Clock Pattern Register   */
X    volatile uint32_t VARCLK;      
N    __IO uint32_t DMA;        /*!< Offset: 0x38  SPI DMA Control Register          */
X    volatile uint32_t DMA;         
N    __IO uint32_t CNTRL2;     /*!< Offset: 0x3C  SPI Control and Status Register 2 */
X    volatile uint32_t CNTRL2;      
N    __IO uint32_t FIFO_CTL;   /*!< Offset: 0x40  SPI FIFO Control Register         */
X    volatile uint32_t FIFO_CTL;    
N    __IO uint32_t STATUS;     /*!< Offset: 0x44  SPI Status Register               */
X    volatile uint32_t STATUS;      
N} SPI_T;
N
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI CNTRL: TX_FULL Position */
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI CNTRL: TX_FULL Mask     */
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI CNTRL: TX_EMPTY Position */
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI CNTRL: TX_EMPTY Mask     */
N
N#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI CNTRL: RX_FULL Position */
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI CNTRL: RX_FULL Mask     */
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI CNTRL: RX_EMPTY Position */
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI CNTRL: RX_EMPTY Mask     */
N
N#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI CNTRL: VARCLK_EN Position */
N#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI CNTRL: VARCLK_EN Mask     */
N
N#define SPI_CNTRL_TWOB_Pos         22                                     /*!< SPI CNTRL: TWOB Position */
N#define SPI_CNTRL_TWOB_Msk         (1ul << SPI_CNTRL_TWOB_Pos)            /*!< SPI CNTRL: TWOB Mask     */
N
N#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI CNTRL: FIFO Position */
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI CNTRL: FIFO Mask     */
N
N#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI CNTRL: REORDER Position */
N#define SPI_CNTRL_REORDER_Msk      (1ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI CNTRL: REORDER Mask     */
N
N#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI CNTRL: SLAVE Position */
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI CNTRL: SLAVE Mask     */
N
N#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI CNTRL: IE Position */
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI CNTRL: IE Mask     */
N
N#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI CNTRL: IF Position */
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI CNTRL: IF Mask     */
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI CNTRL: SP_CYCLE Position */
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI CNTRL: SP_CYCLE Mask     */
N
N#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI CNTRL: CLKP Position */
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI CNTRL: CLKP Mask     */
N
N#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI CNTRL: LSB Position */
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI CNTRL: LSB Mask     */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI CNTRL: TX_BIT_LEN Position */
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI CNTRL: TX_BIT_LEN Mask     */
N
N#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI CNTRL: TX_NEG Position */
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI CNTRL: TX_NEG Mask     */
N
N#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI CNTRL: RX_NEG Position */
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI CNTRL: RX_NEG Mask     */
N
N#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI CNTRL: GO_BUSY Position */
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI CNTRL: GO_BUSY Mask     */
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI DIVIDER: DIVIDER2 Position */
N#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI DIVIDER: DIVIDER2 Mask */
N
N#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI DIVIDER: DIVIDER Position */
N#define SPI_DIVIDER_DIVIDER_Msk    (0xFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI DIVIDER: DIVIDER Mask */
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI SSR: LTRIG_FLAG Position */
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI SSR: LTRIG_FLAG Mask */
N
N#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI SSR: SS_LTRIG Position */
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI SSR: SS_LTRIG Mask */
N
N#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI SSR: AUTOSS Position */
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI SSR: AUTOSS Mask */
N
N#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI SSR: SS_LVL Position */
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI SSR: SS_LVL Mask */
N
N#define SPI_SSR_SSR_Pos            0                                 /*!< SPI SSR: SSR Position */
N#define SPI_SSR_SSR_Msk            (3ul << SPI_SSR_SSR_Pos)          /*!< SPI SSR: SSR Mask */
N
N/* SPI_DMA Bit Field Definitions */
N#define SPI_DMA_PDMA_RST_Pos   2                                     /*!< SPI DMA: PDMA_RST Position */
N#define SPI_DMA_PDMA_RST_Msk   (1ul << SPI_DMA_PDMA_RST_Pos)         /*!< SPI DMA: PDMA_RST Mask */
N
N#define SPI_DMA_RX_DMA_GO_Pos   1                                    /*!< SPI DMA: RX_DMA_GO Position */
N#define SPI_DMA_RX_DMA_GO_Msk   (1ul << SPI_DMA_RX_DMA_GO_Pos)       /*!< SPI DMA: RX_DMA_GO Mask */
N
N#define SPI_DMA_TX_DMA_GO_Pos   0                                    /*!< SPI DMA: TX_DMA_GO Position */
N#define SPI_DMA_TX_DMA_GO_Msk   (1ul << SPI_DMA_TX_DMA_GO_Pos)       /*!< SPI DMA: TX_DMA_GO Mask */
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI CNTRL2: BCn Position */
N#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI CNTRL2: BCn Mask */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI CNTRL2: SS_INT_OPT Position */
N#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI CNTRL2: SS_INT_OPT Mask */
N
N#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI CNTRL2: DUAL_IO_EN Position */
N#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI CNTRL2: DUAL_IO_EN Mask */
N
N#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI CNTRL2: DUAL_IO_DIR Position */
N#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI CNTRL2: DUAL_IO_DIR Mask */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI CNTRL2: SLV_START_INTSTS Position */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI CNTRL2: SLV_START_INTSTS Mask */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI CNTRL2: SSTA_INTEN Position */
N#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI CNTRL2: SSTA_INTEN Mask */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI CNTRL2: SLV_ABORT Position */
N#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI CNTRL2: SLV_ABORT Mask */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI CNTRL2: NOSLVSEL Position */
N#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI CNTRL2: NOSLVSEL Mask */
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI FIFO_CTL: TX_THRESHOLD Position */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: TX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI FIFO_CTL: RX_THRESHOLD Position */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: RX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI FIFO_CTL: TIMEOUT_INTEN Position */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI FIFO_CTL: TIMEOUT_INTEN Mask */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI FIFO_CTL: RXOV_INTEN Position */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI FIFO_CTL: RXOV_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI FIFO_CTL: TX_INTEN Position */
N#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI FIFO_CTL: TX_INTEN Mask */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI FIFO_CTL: RX_INTEN Position */
N#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI FIFO_CTL: RX_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI FIFO_CTL: TX_CLR Position */
N#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI FIFO_CTL: TX_CLR Mask */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI FIFO_CTL: RX_CLR Position */
N#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI FIFO_CTL: RX_CLR Mask */
N
N/* SPI_STATUS Bit Field Definitions */
N#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI STATUS: TX_FIFO_COUNT Position */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI STATUS: TX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI STATUS: TX_FULL Position */
N#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI STATUS: TX_FULL Mask */
N
N#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI STATUS: TX_EMPTY Position */
N#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI STATUS: TX_EMPTY Mask */
N
N#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI STATUS: RX_FULL Position */
N#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI STATUS: RX_FULL Mask */
N
N#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI STATUS: RX_EMPTY Position */
N#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI STATUS: RX_EMPTY Mask */
N
N#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI STATUS: TIMEOUT Position */
N#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI STATUS: TIMEOUT Mask */
N
N#define SPI_STATUS_IF_Pos   16                                                       /*!< SPI STATUS: IF Position */
N#define SPI_STATUS_IF_Msk   (1ul << SPI_STATUS_IF_Pos)                               /*!< SPI STATUS: IF Mask     */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI STATUS: RX_FIFO_COUNT Position */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI STATUS: RX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI STATUS: SLV_START_INTSTS Position */
N#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI STATUS: SLV_START_INTSTS Mask */
N
N#define SPI_STATUS_TX_INTSTS_Pos   4                                                 /*!< SPI STATUS: TX_INTSTS Position */
N#define SPI_STATUS_TX_INTSTS_Msk   (1ul << SPI_STATUS_TX_INTSTS_Pos)                 /*!< SPI STATUS: TX_INTSTS Mask */
N
N#define SPI_STATUS_RX_OVERRUN_Pos   2                                                /*!< SPI STATUS: RX_OVERRUN Position */
N#define SPI_STATUS_RX_OVERRUN_Msk   (1ul << SPI_STATUS_RX_OVERRUN_Pos)               /*!< SPI STATUS: RX_OVERRUN Mask */
N
N#define SPI_STATUS_RX_INTSTS_Pos   0                                                 /*!< SPI STATUS: RX_INTSTS Position */
N#define SPI_STATUS_RX_INTSTS_Msk   (1ul << SPI_STATUS_RX_INTSTS_Pos)                 /*!< SPI STATUS: RX_INTSTS Mask */
N
N/*@}*/ /* end of group NUC200_SPI */
N
N
N
N/*------------------------------ I2C Controller ------------------------------*/
N/** @addtogroup NUC200_I2C NUC200 I2C
N  Memory Mapped Structure for NUC200 Series I2C Serial Interface Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * I2CON
N     * ===================================================================================================
N     * Offset: 0x00  I2C Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |AA        |Assert Acknowledge control bit. 
N     * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during 
N     * |        |          |the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from 
N     * |        |          |master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to 
N     * |        |          |address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge 
N     * |        |          |clock pulse on the SCL line.
N     * |[3]     |SI        |I2C Interrupt Flag. 
N     * |        |          |When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI 
N     * |        |          |(I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one 
N     * |        |          |to this bit.
N     * |[4]     |STO       |I2C STOP Flag. 
N     * |        |          |In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus 
N     * |        |          |condition if a STOP condition is detected this flag will be cleared by hardware automatically. 
N     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means 
N     * |        |          |it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
N     * |[5]     |STA       |I2C START Flag. 
N     * |        |          |Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition 
N     * |        |          |to bus when the bus is free.
N     * |[6]     |ENS1      |I2C controller is enabled/disable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function 
N     * |        |          |pin function of SDA and SCL must set to I2C function first.
N     * |[7]     |EI        |Enable interrupt. 
N     * |        |          |1 = Enable I2C interrupt.
N     * |        |          |0 = Disable I2C interrupt. 
N     */    
N    __IO uint32_t I2CON;	
X    volatile uint32_t I2CON;	
N    
N     /**
N     * I2CADDR0
N     * ===================================================================================================
N     * Offset: 0x04  I2C Slave Address Register 0 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */   
N    __IO uint32_t I2CADDR0;    
X    volatile uint32_t I2CADDR0;    
N
N    /**
N     * I2CDAT
N     * ===================================================================================================
N     * Offset: 0x08  I2C Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CDAT    |I2C Data Register
N     * |        |          |Bit[7:0] is located with the 8-bit transferred data of I2C serial port. 
N     */    
N    __IO uint32_t I2CDAT;    
X    volatile uint32_t I2CDAT;    
N    
N    /**
N     * I2CSTATUS
N     * ===================================================================================================
N     * Offset: 0x0C  I2C Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CSTATUS |I2C Status Register 
N     * |        |          |The status register of I2C:
N     * |        |          |The three least significant bits are always 0. The five most significant bits contain the status code. 
N     * |        |          |There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is 
N     * |        |          |requested. All other I2STATUS values correspond to defined I2C states. When each of these 
N     * |        |          |states is entered, a status interrupt is requested (SI = 1). A valid status code is present in 
N     * |        |          |I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle 
N     * |        |          |after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error 
N     * |        |          |occurs when a START or STOP condition is present at an illegal position in the formation frame. 
N     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an 
N     * |        |          |acknowledge bit.
N     */    
N    __I  uint32_t I2CSTATUS;        
X    volatile const  uint32_t I2CSTATUS;        
N    
N    /**
N     * I2CLK
N     * ===================================================================================================
N     * Offset: 0x10  I2C Clock Divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CLK     |I2C clock divided Register
N     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).
N     */    
N    __IO uint32_t I2CLK;    
X    volatile uint32_t I2CLK;    
N    
N    /**
N     * I2CTOC
N     * ===================================================================================================
N     * Offset: 0x14  I2C Time-Out Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Time-Out flag. 
N     * |        |          |1 = Time-Out falg is set by H/W. It can interrupt CPU.
N     * |        |          |0 = S/W can clear the flag.
N     * |[1]     |DIV4      |Time-Out counter input clock is divider by 4 
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |When Enable, The time-Out period is prolong 4 times.
N     * |[2]     |ENTI      |Time-out counter is enabled/disable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will 
N     * |        |          |reset counter and re-start up counting after SI is cleared.
N     */    
N    __IO uint32_t I2CTOC;    
X    volatile uint32_t I2CTOC;    
N    
N    /**
N     * I2CADDR1
N     * ===================================================================================================
N     * Offset: 0x18  I2C Slave Address Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */    
N    __IO uint32_t I2CADDR1;    
X    volatile uint32_t I2CADDR1;    
N    
N    /**
N     * I2CADDR2
N     * ===================================================================================================
N     * Offset: 0x1C  I2C Slave Address Register 2 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */    
N    __IO uint32_t I2CADDR2;    
X    volatile uint32_t I2CADDR2;    
N    
N    /**
N     * I2CADDR3
N     * ===================================================================================================
N     * Offset: 0x20  I2C Slave Address Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = Disable General Call Function.
N     * |        |          |1 = Enable General Call Function.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
N     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
N     * |        |          |either of the address is matched.
N     */    
N    __IO uint32_t I2CADDR3; 
X    volatile uint32_t I2CADDR3; 
N    
N    /**
N     * I2CADM0
N     * ===================================================================================================
N     * Offset: 0x24  I2C Slave Address Mask Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM0;    
X    volatile uint32_t I2CADM0;    
N    
N    /**
N     * I2CADM1
N     * ===================================================================================================
N     * Offset: 0x28  I2C Slave Address Mask Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM1;    
X    volatile uint32_t I2CADM1;    
N    
N    /**
N     * I2CADM2
N     * ===================================================================================================
N     * Offset: 0x2C  I2C Slave Address Mask Register 2 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM2;    
X    volatile uint32_t I2CADM2;    
N    
N    /**
N     * I2CADM3
N     * ===================================================================================================
N     * Offset: 0x30  I2C Slave Address Mask Register 3 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2ADMx    |I2C Address Mask register
N     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
N     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
N     * |        |          |address register.) 
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
N     * |        |          |When the bit in the address mask register is set to one, it means the received 
N     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
N     * |        |          |corresponding register bit should be exact the same as address register.
N     */    
N    __IO uint32_t I2CADM3;    
X    volatile uint32_t I2CADM3;    
N    
N    /**
N     * RESERVED0
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    uint32_t RESERVED0[2];
N      
N    /**
N     * I2CWKUPCON
N     * ===================================================================================================
N     * Offset: 0x3C  I2C Wake Up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKUPEN    |I2C Wakeup Function Enable
N     * |        |          |1 = Enable I2C wake up function.
N     * |        |          |0 = Disable I2C wake up function.
N     */    
N    __IO uint32_t I2CWKUPCON;
X    volatile uint32_t I2CWKUPCON;
N    
N    /**
N     * I2CWKUPSTS
N     * ===================================================================================================
N     * Offset: 0x40  I2C Wake Up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKUPIF    |I2C Wakeup Interrupt Flag 
N     * |        |          |When chip is waked up from power down mode by I2C, this bit is set to 1. Software can 
N     * |        |          |write 1 to clear this bit.
N     */    
N    __IO uint32_t I2CWKUPSTS;            
X    volatile uint32_t I2CWKUPSTS;            
N} I2C_T;
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C I2CON: EI Position */
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C I2CON: EI Mask */
N
N#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C I2CON: ENS1 Position */
N#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C I2CON: ENS1 Mask */
N
N#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C I2CON: STA Position */
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C I2CON: STA Mask */
N
N#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C I2CON: STO Position */
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C I2CON: STO Mask */
N
N#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C I2CON: SI Position */
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C I2CON: SI Mask */
N
N#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C I2CON: AA Position */
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C I2CON: AA Mask */
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C I2CADDR: I2CADDR Position */
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C I2CADDR: I2CADDR Mask */
N
N#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C I2CADDR: GC Position */
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C I2CADDR: GC Mask */
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C I2CDAT: I2CDAT Position */
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C I2CDAT: I2CDAT Mask */
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C I2CSTATUS: I2CSTATUS Position */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C I2CSTATUS: I2CSTATUS Mask */
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C I2CLK: I2CLK Position */
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C I2CLK: I2CLK Mask */
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C I2CTOC: ENTI Position */
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C I2CTOC: ENTI Mask */
N
N#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C I2CTOC: DIV4 Position */
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C I2CTOC: DIV4 Mask */
N
N#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C I2CTOC: TIF Position */
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C I2CTOC: TIF Mask */
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C I2CADM: I2CADM Position */
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C I2CADM: I2CADM Mask */
N
N/* I2C I2CWKUPCON Bit Field Definitions */
N#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C I2CWKUPCON: WKUPEN Position */
N#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C I2CWKUPCON: WKUPEN Mask */
N
N/* I2C I2CWKUPSTS Bit Field Definitions */
N#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C I2CWKUPSTS: WKUPIF Position */
N#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C I2CWKUPSTS: WKUPIF Mask */
N
N/*@}*/ /* end of group NUC200_I2C */
N
N
N/*-----------------------  Real Time Clock (RTC) ------------------*/
N/** @addtogroup NUC200_RTC NUC200 RTC
N  Memory Mapped Structure for NUC200 Series Real Time Clock
N  @{
N */
Ntypedef struct
N{
N    /**
N     * INIR
N     * ===================================================================================================
N     * Offset: 0x00  RTC Initiation Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t INIR;
X    volatile uint32_t INIR;
N
N    /**
N     * AER
N     * ===================================================================================================
N     * Offset: 0x04  RTC Access Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t AER;
X    volatile uint32_t AER;
N
N    /**
N     * FCR
N     * ===================================================================================================
N     * Offset: 0x08  RTC Frequency Compensation Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t FCR;
X    volatile uint32_t FCR;
N
N    /**
N     * TLR
N     * ===================================================================================================
N     * Offset: 0x0C  RTC Time Loading Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TLR;
X    volatile uint32_t TLR;
N
N    /**
N     * CLR
N     * ===================================================================================================
N     * Offset: 0x10  RTC Calendar Loading Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t CLR;
X    volatile uint32_t CLR;
N
N    /**
N     * TSSR
N     * ===================================================================================================
N     * Offset: 0x14  RTC Time Scale Selection Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TSSR;
X    volatile uint32_t TSSR;
N
N    /**
N     * DWR
N     * ===================================================================================================
N     * Offset: 0x18  RTC Day of the Week Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t DWR;
X    volatile uint32_t DWR;
N
N    /**
N     * TAR
N     * ===================================================================================================
N     * Offset: 0x1C  RTC Time Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TAR;
X    volatile uint32_t TAR;
N
N    /**
N     * CAR
N     * ===================================================================================================
N     * Offset: 0x20  RTC Calendar Alarm Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t CAR;
X    volatile uint32_t CAR;
N
N    /**
N     * LIR
N     * ===================================================================================================
N     * Offset: 0x24  RTC Leap Year Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t LIR;
X    volatile const  uint32_t LIR;
N
N    /**
N     * RIER
N     * ===================================================================================================
N     * Offset: 0x28  RTC Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t RIER;
X    volatile uint32_t RIER;
N
N    /**
N     * RIIR
N     * ===================================================================================================
N     * Offset: 0x2C  RTC Interrupt Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t RIIR;
X    volatile uint32_t RIIR;
N
N    /**
N     * TTR
N     * ===================================================================================================
N     * Offset: 0x30  RTC Time Tick Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TTR;
X    volatile uint32_t TTR;
N} RTC_T;
N
N/* RTC INIR Bit Field Definitions */                                            
N#define RTC_INIR_INIR_Pos       0                                               /*!< RTC INIR: INIR Position */
N#define RTC_INIR_INIR_Msk       (0xFFFFFFFFul << RTC_INIR_INIR_Pos)             /*!< RTC INIR: INIR Mask */
N
N#define RTC_INIR_ACTIVE_Pos     0                                               /*!< RTC INIR: ACTIVE Position */
N#define RTC_INIR_ACTIVE_Msk     (1ul << RTC_INIR_ACTIVE_Pos)                    /*!< RTC INIR: ACTIVE Mask */
N
N/* RTC AER Bit Field Definitions */
N#define RTC_AER_ENF_Pos         16                                              /*!< RTC AER: ENF Position */
N#define RTC_AER_ENF_Msk         (1ul << RTC_AER_ENF_Pos)                        /*!< RTC AER: ENF Mask */
N
N#define RTC_AER_AER_Pos         0                                               /*!< RTC AER: AER Position */
N#define RTC_AER_AER_Msk         (0xFFFFul << RTC_AER_AER_Pos)                   /*!< RTC AER: AER Mask */
N
N/* RTC FCR Bit Field Definitions */
N#define RTC_FCR_INTEGER_Pos     8                                               /*!< RTC FCR: INTEGER Position */
N#define RTC_FCR_INTEGER_Msk     (0xFul << RTC_FCR_INTEGER_Pos)                  /*!< RTC FCR: INTEGER Mask */
N
N#define RTC_FCR_FRACTION_Pos    0                                               /*!< RTC FCR: FRACTION Position */
N#define RTC_FCR_FRACTION_Msk    (0x3Ful << RTC_FCR_FRACTION_Pos)                /*!< RTC FCR: FRACTION Mask */
N
N/* RTC TLR Bit Field Definitions */
N#define RTC_TLR_10HR_Pos        20                                              /*!< RTC TLR: 10HR Position */
N#define RTC_TLR_10HR_Msk        (0x3ul << RTC_TLR_10HR_Pos)                     /*!< RTC TLR: 10HR Mask */
N
N#define RTC_TLR_1HR_Pos         16                                              /*!< RTC TLR: 1HR Position */
N#define RTC_TLR_1HR_Msk         (0xFul << RTC_TLR_1HR_Pos)                      /*!< RTC TLR: 1HR Mask */
N
N#define RTC_TLR_10MIN_Pos       12                                              /*!< RTC TLR: 10MIN Position */
N#define RTC_TLR_10MIN_Msk       (0x7ul << RTC_TLR_10MIN_Pos)                    /*!< RTC TLR: 10MIN Mask */
N
N#define RTC_TLR_1MIN_Pos        8                                               /*!< RTC TLR: 1MIN Position */
N#define RTC_TLR_1MIN_Msk        (0xFul << RTC_TLR_1MIN_Pos)                     /*!< RTC TLR: 1MIN Mask */
N
N#define RTC_TLR_10SEC_Pos       4                                               /*!< RTC TLR: 10SEC Position */
N#define RTC_TLR_10SEC_Msk       (0x7ul << RTC_TLR_10SEC_Pos)                    /*!< RTC TLR: 10SEC Mask */
N
N#define RTC_TLR_1SEC_Pos        0                                               /*!< RTC TLR: 1SEC Position */
N#define RTC_TLR_1SEC_Msk        (0xFul << RTC_TLR_1SEC_Pos)                     /*!< RTC TLR: 1SEC Mask */
N
N/* RTC CLR Bit Field Definitions */
N#define RTC_CLR_10YEAR_Pos      20                                              /*!< RTC CLR: 10YEAR Position */
N#define RTC_CLR_10YEAR_Msk      (0xFul << RTC_CLR_10YEAR_Pos)                   /*!< RTC CLR: 10YEAR Mask */
N
N#define RTC_CLR_1YEAR_Pos       16                                              /*!< RTC CLR: 1YEAR Position */
N#define RTC_CLR_1YEAR_Msk       (0xFul << RTC_CLR_1YEAR_Pos)                    /*!< RTC CLR: 1YEAR Mask */ 
N
N#define RTC_CLR_10MON_Pos       12                                              /*!< RTC CLR: 10MON Position */
N#define RTC_CLR_10MON_Msk       (1ul << RTC_CLR_10MON_Pos)                      /*!< RTC CLR: 10MON Mask */
N
N#define RTC_CLR_1MON_Pos        8                                               /*!< RTC CLR: 1MON Position */
N#define RTC_CLR_1MON_Msk        (0xFul << RTC_CLR_1MON_Pos)                     /*!< RTC CLR: 1MON Mask */
N
N#define RTC_CLR_10DAY_Pos       4                                               /*!< RTC CLR: 10DAY Position */
N#define RTC_CLR_10DAY_Msk       (0x3ul << RTC_CLR_10DAY_Pos)                    /*!< RTC CLR: 10DAY Mask */
N
N#define RTC_CLR_1DAY_Pos        0                                               /*!< RTC CLR: 1DAY Position */
N#define RTC_CLR_1DAY_Msk        (0xFul << RTC_CLR_1DAY_Pos)                     /*!< RTC CLR: 1DAY Mask */
N
N/* RTC TSSR Bit Field Definitions */                                            
N#define RTC_TSSR_24H_12H_Pos    0                                               /*!< RTC TSSR: 24H_12H Position */
N#define RTC_TSSR_24H_12H_Msk    (1ul << RTC_TSSR_24H_12H_Pos)                   /*!< RTC TSSR: 24H_12H Mask */
N
N/* RTC DWR Bit Field Definitions */
N#define RTC_DWR_DWR_Pos         0                                               /*!< RTC DWR: DWR Position */
N#define RTC_DWR_DWR_Msk         (0x7ul << RTC_DWR_DWR_Pos)                      /*!< RTC DWR: DWR Mask */
N
N/* RTC TAR Bit Field Definitions */
N#define RTC_TAR_10HR_Pos        20                                              /*!< RTC TAR: 10HR Position */
N#define RTC_TAR_10HR_Msk        (0x3ul << RTC_TAR_10HR_Pos)                     /*!< RTC TAR: 10HR Mask */
N
N#define RTC_TAR_1HR_Pos         16                                              /*!< RTC TAR: 1HR Position */
N#define RTC_TAR_1HR_Msk         (0xFul << RTC_TAR_1HR_Pos)                      /*!< RTC TAR: 1HR Mask */
N
N#define RTC_TAR_10MIN_Pos       12                                              /*!< RTC TAR: 10MIN Position */
N#define RTC_TAR_10MIN_Msk       (0x7ul << RTC_TAR_10MIN_Pos)                    /*!< RTC TAR: 10MIN Mask */
N
N#define RTC_TAR_1MIN_Pos        8                                               /*!< RTC TAR: 1MIN Position */
N#define RTC_TAR_1MIN_Msk        (0xFul << RTC_TAR_1MIN_Pos)                     /*!< RTC TAR: 1MIN Mask */
N
N#define RTC_TAR_10SEC_Pos       4                                               /*!< RTC TAR: 10SEC Position */
N#define RTC_TAR_10SEC_Msk       (0x7ul << RTC_TAR_10SEC_Pos)                    /*!< RTC TAR: 10SEC Mask */
N
N#define RTC_TAR_1SEC_Pos        0                                               /*!< RTC TAR: 1SEC Position */
N#define RTC_TAR_1SEC_Msk        (0xFul << RTC_TAR_1SEC_Pos)                     /*!< RTC TAR: 1SEC Mask */
N
N/* RTC CAR Bit Field Definitions */
N#define RTC_CAR_10YEAR_Pos      20                                              /*!< RTC CAR: 10YEAR Position */
N#define RTC_CAR_10YEAR_Msk      (0xFul << RTC_CAR_10YEAR_Pos)                   /*!< RTC CAR: 10YEAR Mask */
N
N#define RTC_CAR_1YEAR_Pos       16                                              /*!< RTC CAR: 1YEAR Position */        
N#define RTC_CAR_1YEAR_Msk       (0xFul << RTC_CAR_1YEAR_Pos)                    /*!< RTC CAR: 1YEAR Mask */
N
N#define RTC_CAR_10MON_Pos       12                                              /*!< RTC CAR: 10MON Position */
N#define RTC_CAR_10MON_Msk       (1ul << RTC_CAR_10MON_Pos)                      /*!< RTC CAR: 10MON Mask */
N
N#define RTC_CAR_1MON_Pos        8                                               /*!< RTC CAR: 1MON Position */
N#define RTC_CAR_1MON_Msk        (0xFul << RTC_CAR_1MON_Pos)                     /*!< RTC CAR: 1MON Mask */
N
N#define RTC_CAR_10DAY_Pos       4                                               /*!< RTC CAR: 10DAY Position */
N#define RTC_CAR_10DAY_Msk       (0x3ul << RTC_CAR_10DAY_Pos)                    /*!< RTC CAR: 10DAY Mask */
N
N#define RTC_CAR_1DAY_Pos        0                                               /*!< RTC CAR: 1DAY Position */
N#define RTC_CAR_1DAY_Msk        (0xFul << RTC_CAR_1DAY_Pos)                     /*!< RTC CAR: 1DAY Mask */
N
N/* RTC LIR Bit Field Definitions */
N#define RTC_LIR_LIR_Pos         0                                               /*!< RTC LIR: LIR Position */
N#define RTC_LIR_LIR_Msk         (1ul << RTC_LIR_LIR_Pos)                        /*!< RTC LIR: LIR Mask */
N
N/* RTC RIER Bit Field Definitions */
N#define RTC_RIER_TIER_Pos       1                                               /*!< RTC RIER: TIER Position */
N#define RTC_RIER_TIER_Msk       (1ul << RTC_RIER_TIER_Pos)                      /*!< RTC RIER: TIER Mask */
N
N#define RTC_RIER_AIER_Pos       0                                               /*!< RTC RIER: AIER Position */
N#define RTC_RIER_AIER_Msk       (1ul << RTC_RIER_AIER_Pos)                      /*!< RTC RIER: AIER Mask */
N
N/* RTC RIIR Bit Field Definitions */
N#define RTC_RIIR_TIF_Pos        1                                               /*!< RTC RIIR: TIF Position */
N#define RTC_RIIR_TIF_Msk        (1ul << RTC_RIIR_TIF_Pos)                       /*!< RTC RIIR: TIF Mask */
N
N#define RTC_RIIR_AIF_Pos        0                                               /*!< RTC RIIR: AIF Position */
N#define RTC_RIIR_AIF_Msk        (1ul << RTC_RIIR_AIF_Pos)                       /*!< RTC RIIR: AIF Mask */
N
N/* RTC TTR Bit Field Definitions */
N#define RTC_TTR_TTR_Pos         0                                               /*!< RTC TTR: TTR Position */
N#define RTC_TTR_TTR_Msk         (0x7ul << RTC_TTR_TTR_Pos)                      /*!< RTC TTR: TTR Mask */
N/*@}*/ /* end of group NUC200_RTC */
N
N
N
N/*----------------------------- ADC Controller -------------------------------*/
N/** @addtogroup NUC200_ADC NUC200 ADC
N  Memory Mapped Structure for NUC200 Series ADC Controller
N  @{
N */
Ntypedef struct
N{
N    __I  uint32_t ADDR[8];               /*!< Offset: 0x00  A/D Data Register              */
X    volatile const  uint32_t ADDR[8];                
N    __IO uint32_t ADCR;                  /*!< Offset: 0x20  A/D Control Register           */
X    volatile uint32_t ADCR;                   
N    __IO uint32_t ADCHER;                /*!< Offset: 0x24  A/D Channel Enable Register    */
X    volatile uint32_t ADCHER;                 
N    __IO uint32_t ADCMPR[2];             /*!< Offset: 0x28  A/D Compare Register 0 & 1     */
X    volatile uint32_t ADCMPR[2];              
N    __IO uint32_t ADSR;                  /*!< Offset: 0x30  ADC Status Register            */
X    volatile uint32_t ADSR;                   
N    __I  uint32_t RESERVE0[3];
X    volatile const  uint32_t RESERVE0[3];
N    __I  uint32_t ADPDMA;                /*!< Offset: 0x40  ADC PDMA Current Transfer Data */
X    volatile const  uint32_t ADPDMA;                 
N} ADC_T;
N
N
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17                                /*!< ADC ADDR: VALID Position */
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC ADDR: VALID Mask */
N
N#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC ADDR: OVERRUN Position */
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC ADDR: OVERRUN Mask */
N
N#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC ADDR: RSLT Position */
N#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC ADDR: RSLT Mask */
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC ADCR: DMOF Position */
N#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC ADCR: DMOF Mask */
N
N#define ADC_ADCR_ADST_Pos       11                                /*!< ADC ADCR: ADST Position */
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC ADCR: ADST Mask */
N
N#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC ADCR: DIFFEN Position */
N#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC ADCR: DIFFEN Mask */
N
N#define ADC_ADCR_PTEN_Pos       9                                 /*!< ADC ADCR: PTEN Position */
N#define ADC_ADCR_PTEN_Msk       (1ul << ADC_ADCR_PTEN_Pos)        /*!< ADC ADCR: PTEN Mask */
N
N#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC ADCR: TRGEN Position */
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC ADCR: TRGEN Mask */
N
N#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC ADCR: TRGCOND Position */
N#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC ADCR: TRGCOND Mask */
N
N#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC ADCR: TRGS Position */
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC ADCR: TRGS Mask */
N
N#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC ADCR: ADMD Position */
N#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC ADCR: ADMD Mask */
N
N#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC ADCR: ADIE Position */
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC ADCR: ADIE Mask */
N
N#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC ADCR: ADEN Position */
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC ADCR: ADEN Mask */
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC ADCHER: PRESEL Position */
N#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC ADCHER: PRESEL Mask */
N
N#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC ADCHER: CHEN Position */
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC ADCHER: CHEN Mask */
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC ADCMPR: CMPD Position */
N#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC ADCMPR: CMPD Mask */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC ADCMPR: CMPMATCNT Position */
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC ADCMPR: CMPMATCNT Mask */
N
N#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC ADCMPR: CMPCH Position */
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC ADCMPR: CMPCH Mask */
N
N#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC ADCMPR: CMPCOND Position */
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC ADCMPR: CMPCOND Mask */
N
N#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC ADCMPR: CMPIE Position */
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC ADCMPR: CMPIE Mask */
N
N#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC ADCMPR: CMPEN Position */
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC ADCMPR: CMPEN Mask */
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC ADSR: OVERRUN Position */
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC ADSR: OVERRUN Mask */
N
N#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC ADSR: VALID Position */
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC ADSR: VALID Mask */
N
N#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC ADSR: CHANNEL Position */
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC ADSR: CHANNEL Mask */
N
N#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC ADSR: BUSY Position */
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC ADSR: BUSY Mask */
N
N#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC ADSR: CMPF1 Position */
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC ADSR: CMPF1 Mask */
N
N#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC ADSR: CMPF0 Position */
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC ADSR: CMPF0 Mask */
N
N#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC ADSR: ADF Position */
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC ADSR: ADF Mask */
N
N/* ADPDMA Bit Field Definitions */
N#define ADC_ADPDMA_AD_PDMA_Pos     0                                     /*!< ADC ADPDMA: AD_PDMA Position */
N#define ADC_ADPDMA_AD_PDMA_Msk     (0x3FFFFul << ADC_ADPDMA_AD_PDMA_Pos) /*!< ADC ADPDMA: AD_PDMA Mask */
N
N/*@}*/ /* end of group NUC200_ADC */
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/** @addtogroup NUC200_ACMP NUC200 ACMP
N  Memory Mapped Structure for NUC200 Series ACMP Controller
N  @{
N */
Ntypedef struct
N{
N        __IO uint32_t CMPCR[2];        /*!< Offset: 0x00  ACMP Comparator Control Register   */
X        volatile uint32_t CMPCR[2];         
N        __IO uint32_t CMPSR;           /*!< Offset: 0x08  ACMP Comparator Status Register   */
X        volatile uint32_t CMPSR;            
N
N} ACMP_T;
N
N
N/* CMPCR Bit Field Definitions */
N#define ACMP_CMPCR_CMPCN_Pos       4                                   /*!< ACMP CMPCR: CMPCN Position */
N#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)       /*!< ACMP CMPCR: CMPCN Mask */
N
N#define ACMP_CMPCR_CMP_HYSEN_Pos   2                                   /*!< ACMP CMPCR: CMP_HYSEN Position */
N#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)   /*!< ACMP CMPCR: CMP_HYSEN Mask */
N
N#define ACMP_CMPCR_CMPIE_Pos       1                                   /*!< ACMP CMPCR: CMPIE Position */
N#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)       /*!< ACMP CMPCR: CMPIE Mask */
N
N#define ACMP_CMPCR_CMPEN_Pos       0                                   /*!< ACMP CMPCR: CMPEN Position */
N#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)       /*!< ACMP CMPCR: CMPEN Mask */
N
N/* CMPSR Bit Field Definitions */
N#define ACMP_CMPSR_CO1_Pos     3                                 /*!< ACMP CMPSR: CO1 Position */
N#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)       /*!< ACMP CMPSR: CO1 Mask */
N
N#define ACMP_CMPSR_CO0_Pos     2                                 /*!< ACMP CMPSR: CO0 Position */
N#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)       /*!< ACMP CMPSR: CO0 Mask */
N
N#define ACMP_CMPSR_CMPF1_Pos   1                                 /*!< ACMP CMPSR: CMPF1 Position */
N#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)     /*!< ACMP CMPSR: CMPF1 Mask */
N
N#define ACMP_CMPSR_CMPF0_Pos   0                                 /*!< ACMP CMPSR: CMPF0 Position */
N#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)     /*!< ACMP CMPSR: CMPF0 Mask */
N
N/*@}*/ /* end of group NUC200_ACMP */
N
N
N
N/*---------------------------- Clock Controller ------------------------------*/
N/** @addtogroup NUC200_SYSCLK NUC200 System Clock Controller
N  Memory Mapped Structure for NUC200 Series System Clock Controller
N  @{
N */
Ntypedef struct
N{
N    __IO uint32_t PWRCON;           
X    volatile uint32_t PWRCON;           
N    __IO uint32_t AHBCLK;           
X    volatile uint32_t AHBCLK;           
N    __IO uint32_t APBCLK;           
X    volatile uint32_t APBCLK;           
N    __IO uint32_t CLKSTATUS;        
X    volatile uint32_t CLKSTATUS;        
N    __IO uint32_t CLKSEL0;          
X    volatile uint32_t CLKSEL0;          
N    __IO uint32_t CLKSEL1;          
X    volatile uint32_t CLKSEL1;          
N    __IO uint32_t CLKDIV;           
X    volatile uint32_t CLKDIV;           
N    __IO uint32_t CLKSEL2;           
X    volatile uint32_t CLKSEL2;           
N    __IO uint32_t PLLCON;           
X    volatile uint32_t PLLCON;           
N    __IO uint32_t FRQDIV;           
X    volatile uint32_t FRQDIV;           
N    __IO uint32_t RESERVE[2];           
X    volatile uint32_t RESERVE[2];           
N    __IO uint32_t APBCLK1;             
X    volatile uint32_t APBCLK1;             
N    __IO uint32_t CLKSEL3;          
X    volatile uint32_t CLKSEL3;          
N    __IO uint32_t CLKDIV1;                        
X    volatile uint32_t CLKDIV1;                        
N} SYSCLK_T;
N
N/* SYSCLK PWRCON Bit Field Definitions */
N#define SYSCLK_PWRCON_PD_WAIT_CPU_Pos           8                                       /*!< SYSCLK PWRCON: PD_WAIT_CPU Position */
N#define SYSCLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << SYSCLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< SYSCLK PWRCON: PD_WAIT_CPU Mask */
N
N#define SYSCLK_PWRCON_PWR_DOWN_EN_Pos           7                                       /*!< SYSCLK PWRCON: PWR_DOWN_EN Position */
N#define SYSCLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << SYSCLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< SYSCLK PWRCON: PWR_DOWN_EN Mask */
N
N#define SYSCLK_PWRCON_PD_WU_STS_Pos             6                                       /*!< SYSCLK PWRCON: PD_WU_STS Position */
N#define SYSCLK_PWRCON_PD_WU_STS_Msk             (1ul << SYSCLK_PWRCON_PD_WU_STS_Pos)    /*!< SYSCLK PWRCON: PD_WU_STS Mask */
N
N#define SYSCLK_PWRCON_PD_WU_INT_EN_Pos          5                                       /*!< SYSCLK PWRCON: PD_WU_INT_EN Position */
N#define SYSCLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << SYSCLK_PWRCON_PD_WU_INT_EN_Pos) /*!< SYSCLK PWRCON: PD_WU_INT_EN Mask */
N
N#define SYSCLK_PWRCON_PD_WU_DLY_Pos             4                                       /*!< SYSCLK PWRCON: PD_WU_DLY Position */
N#define SYSCLK_PWRCON_PD_WU_DLY_Msk             (1ul << SYSCLK_PWRCON_PD_WU_DLY_Pos)    /*!< SYSCLK PWRCON: PD_WU_DLY Mask */
N
N#define SYSCLK_PWRCON_IRC10K_EN_Pos             3                                       /*!< SYSCLK PWRCON: IRC10K_EN Position */
N#define SYSCLK_PWRCON_IRC10K_EN_Msk             (1ul << SYSCLK_PWRCON_IRC10K_EN_Pos)    /*!< SYSCLK PWRCON: IRC10K_EN Mask */
N
N#define SYSCLK_PWRCON_IRC22M_EN_Pos             2                                       /*!< SYSCLK PWRCON: IRC22M_EN Position */
N#define SYSCLK_PWRCON_IRC22M_EN_Msk             (1ul << SYSCLK_PWRCON_IRC22M_EN_Pos)    /*!< SYSCLK PWRCON: IRC22M_EN Mask */
N
N#define SYSCLK_PWRCON_XTL32K_EN_Pos             1                                       /*!< SYSCLK PWRCON: XTL32K_EN Position */
N#define SYSCLK_PWRCON_XTL32K_EN_Msk             (1ul << SYSCLK_PWRCON_XTL32K_EN_Pos)    /*!< SYSCLK PWRCON: XTL32K_EN Mask */
N
N#define SYSCLK_PWRCON_XTL12M_EN_Pos             0                                       /*!< SYSCLK PWRCON: XTL12M_EN Position */
N#define SYSCLK_PWRCON_XTL12M_EN_Msk             (1ul << SYSCLK_PWRCON_XTL12M_EN_Pos)    /*!< SYSCLK PWRCON: XTL12M_EN Mask */
N
N/* SYSCLK AHBCLK Bit Field Definitions */
N#define SYSCLK_AHBCLK_ISP_EN_Pos                2                                       /*!< SYSCLK AHBCLK: ISP_EN Position */
N#define SYSCLK_AHBCLK_ISP_EN_Msk                (1ul << SYSCLK_AHBCLK_ISP_EN_Pos)       /*!< SYSCLK AHBCLK: ISP_EN Mask */
N
N#define SYSCLK_AHBCLK_PDMA_EN_Pos               1                                       /*!< SYSCLK AHBCLK: PDMA_EN Position */
N#define SYSCLK_AHBCLK_PDMA_EN_Msk               (1ul << SYSCLK_AHBCLK_PDMA_EN_Pos)      /*!< SYSCLK AHBCLK: PDMA_EN Mask */
N
N
N/* SYSCLK APBCLK Bit Field Definitions */
N#define SYSCLK_APBCLK_PS2_EN_Pos                31                                      /*!< SYSCLK APBCLK: PS2_EN Position */
N#define SYSCLK_APBCLK_PS2_EN_Msk                (1ul << SYSCLK_APBCLK_PS2_EN_Pos)       /*!< SYSCLK APBCLK: PS2_EN Mask */
N
N#define SYSCLK_APBCLK_ACMP_EN_Pos               30                                      /*!< SYSCLK APBCLK: ACMP_EN Position */
N#define SYSCLK_APBCLK_ACMP_EN_Msk               (1ul << SYSCLK_APBCLK_ACMP_EN_Pos)      /*!< SYSCLK APBCLK: ACMP_EN Mask */
N
N#define SYSCLK_APBCLK_I2S_EN_Pos                29                                      /*!< SYSCLK APBCLK: I2S_EN Position */
N#define SYSCLK_APBCLK_I2S_EN_Msk                (1ul << SYSCLK_APBCLK_I2S_EN_Pos)       /*!< SYSCLK APBCLK: I2S_EN Mask */
N
N#define SYSCLK_APBCLK_ADC_EN_Pos                28                                      /*!< SYSCLK APBCLK: ADC_EN Position */
N#define SYSCLK_APBCLK_ADC_EN_Msk                (1ul << SYSCLK_APBCLK_ADC_EN_Pos)       /*!< SYSCLK APBCLK: ADC_EN Mask */
N
N#define SYSCLK_APBCLK_USBD_EN_Pos               27                                      /*!< SYSCLK APBCLK: USBD_EN Position */
N#define SYSCLK_APBCLK_USBD_EN_Msk               (1ul << SYSCLK_APBCLK_USBD_EN_Pos)      /*!< SYSCLK APBCLK: USBD_EN Mask */
N
N#define SYSCLK_APBCLK_CAN1_EN_Pos               25                                      /*!< SYSCLK APBCLK: CAN1_EN Position */
N#define SYSCLK_APBCLK_CAN1_EN_Msk               (1ul << SYSCLK_APBCLK_CAN1_EN_Pos)      /*!< SYSCLK APBCLK: CAN1_EN Mask */
N
N#define SYSCLK_APBCLK_CAN0_EN_Pos               24                                      /*!< SYSCLK APBCLK: CAN0_EN Position */
N#define SYSCLK_APBCLK_CAN0_EN_Msk               (1ul << SYSCLK_APBCLK_CAN0_EN_Pos)      /*!< SYSCLK APBCLK: CAN0_EN Mask */
N
N#define SYSCLK_APBCLK_PWM67_EN_Pos              23                                      /*!< SYSCLK APBCLK: PWM67_EN Position */
N#define SYSCLK_APBCLK_PWM67_EN_Msk              (1ul << SYSCLK_APBCLK_PWM67_EN_Pos)     /*!< SYSCLK APBCLK: PWM67_EN Mask */
N
N#define SYSCLK_APBCLK_PWM45_EN_Pos              22                                      /*!< SYSCLK APBCLK: PWM45_EN Position */
N#define SYSCLK_APBCLK_PWM45_EN_Msk              (1ul << SYSCLK_APBCLK_PWM45_EN_Pos)     /*!< SYSCLK APBCLK: PWM45_EN Mask */
N
N#define SYSCLK_APBCLK_PWM23_EN_Pos              21                                      /*!< SYSCLK APBCLK: PWM23_EN Position */
N#define SYSCLK_APBCLK_PWM23_EN_Msk              (1ul << SYSCLK_APBCLK_PWM23_EN_Pos)     /*!< SYSCLK APBCLK: PWM23_EN Mask */
N
N#define SYSCLK_APBCLK_PWM01_EN_Pos              20                                      /*!< SYSCLK APBCLK: PWM01_EN Position */
N#define SYSCLK_APBCLK_PWM01_EN_Msk              (1ul << SYSCLK_APBCLK_PWM01_EN_Pos)     /*!< SYSCLK APBCLK: PWM01_EN Mask */
N
N#define SYSCLK_APBCLK_UART2_EN_Pos              18                                      /*!< SYSCLK APBCLK: UART2_EN Position */
N#define SYSCLK_APBCLK_UART2_EN_Msk              (1ul << SYSCLK_APBCLK_UART2_EN_Pos)     /*!< SYSCLK APBCLK: UART2_EN Mask */
N
N#define SYSCLK_APBCLK_UART1_EN_Pos              17                                      /*!< SYSCLK APBCLK: UART1_EN Position */
N#define SYSCLK_APBCLK_UART1_EN_Msk              (1ul << SYSCLK_APBCLK_UART1_EN_Pos)     /*!< SYSCLK APBCLK: UART1_EN Mask */
N
N#define SYSCLK_APBCLK_UART0_EN_Pos              16                                      /*!< SYSCLK APBCLK: UART0_EN Position */
N#define SYSCLK_APBCLK_UART0_EN_Msk              (1ul << SYSCLK_APBCLK_UART0_EN_Pos)     /*!< SYSCLK APBCLK: UART0_EN Mask */
N
N#define SYSCLK_APBCLK_SPI3_EN_Pos               15                                      /*!< SYSCLK APBCLK: SPI3_EN Position */
N#define SYSCLK_APBCLK_SPI3_EN_Msk               (1ul << SYSCLK_APBCLK_SPI3_EN_Pos)      /*!< SYSCLK APBCLK: SPI3_EN Mask */
N
N#define SYSCLK_APBCLK_SPI2_EN_Pos               14                                      /*!< SYSCLK APBCLK: SPI2_EN Position */
N#define SYSCLK_APBCLK_SPI2_EN_Msk               (1ul << SYSCLK_APBCLK_SPI2_EN_Pos)      /*!< SYSCLK APBCLK: SPI2_EN Mask */
N
N#define SYSCLK_APBCLK_SPI1_EN_Pos               13                                      /*!< SYSCLK APBCLK: SPI1_EN Position */
N#define SYSCLK_APBCLK_SPI1_EN_Msk               (1ul << SYSCLK_APBCLK_SPI1_EN_Pos)      /*!< SYSCLK APBCLK: SPI1_EN Mask */
N
N#define SYSCLK_APBCLK_SPI0_EN_Pos               12                                      /*!< SYSCLK APBCLK: SPI0_EN Position */
N#define SYSCLK_APBCLK_SPI0_EN_Msk               (1ul << SYSCLK_APBCLK_SPI0_EN_Pos)      /*!< SYSCLK APBCLK: SPI0_EN Mask */
N
N#define SYSCLK_APBCLK_I2C1_EN_Pos               9                                       /*!< SYSCLK APBCLK: I2C1_EN Position */
N#define SYSCLK_APBCLK_I2C1_EN_Msk               (1ul << SYSCLK_APBCLK_I2C1_EN_Pos)      /*!< SYSCLK APBCLK: I2C1_EN Mask */
N
N#define SYSCLK_APBCLK_I2C0_EN_Pos               8                                       /*!< SYSCLK APBCLK: I2C0_EN_ Position */
N#define SYSCLK_APBCLK_I2C0_EN_Msk               (1ul << SYSCLK_APBCLK_I2C0_EN_Pos)      /*!< SYSCLK APBCLK: I2C0_EN_ Mask */
N
N#define SYSCLK_APBCLK_FDIV_EN_Pos               6                                       /*!< SYSCLK APBCLK: FDIV_EN Position */
N#define SYSCLK_APBCLK_FDIV_EN_Msk               (1ul << SYSCLK_APBCLK_FDIV_EN_Pos)      /*!< SYSCLK APBCLK: FDIV_EN Mask */
N
N#define SYSCLK_APBCLK_TMR3_EN_Pos               5                                       /*!< SYSCLK APBCLK: TMR3_EN Position */
N#define SYSCLK_APBCLK_TMR3_EN_Msk               (1ul << SYSCLK_APBCLK_TMR3_EN_Pos)      /*!< SYSCLK APBCLK: TMR3_EN Mask */
N
N#define SYSCLK_APBCLK_TMR2_EN_Pos               4                                       /*!< SYSCLK APBCLK: TMR2_EN Position */
N#define SYSCLK_APBCLK_TMR2_EN_Msk               (1ul << SYSCLK_APBCLK_TMR2_EN_Pos)      /*!< SYSCLK APBCLK: TMR2_EN Mask */
N
N#define SYSCLK_APBCLK_TMR1_EN_Pos               3                                       /*!< SYSCLK APBCLK: TMR1_EN Position */
N#define SYSCLK_APBCLK_TMR1_EN_Msk               (1ul << SYSCLK_APBCLK_TMR1_EN_Pos)      /*!< SYSCLK APBCLK: TMR1_EN Mask */
N                                                
N#define SYSCLK_APBCLK_TMR0_EN_Pos               2                                       /*!< SYSCLK APBCLK: TMR0_EN Position */
N#define SYSCLK_APBCLK_TMR0_EN_Msk               (1ul << SYSCLK_APBCLK_TMR0_EN_Pos)      /*!< SYSCLK APBCLK: TMR0_EN Mask */      
N
N#define SYSCLK_APBCLK_RTC_EN_Pos                1                                       /*!< SYSCLK APBCLK: RTC_EN Position */
N#define SYSCLK_APBCLK_RTC_EN_Msk                (1ul << SYSCLK_APBCLK_RTC_EN_Pos)       /*!< SYSCLK APBCLK: RTC_EN Mask */
N
N#define SYSCLK_APBCLK_WDT_EN_Pos                0                                       /*!< SYSCLK APBCLK: WDT_EN Position */
N#define SYSCLK_APBCLK_WDT_EN_Msk                (1ul << SYSCLK_APBCLK_WDT_EN_Pos)       /*!< SYSCLK APBCLK: WDT_EN Mask */
N
N/* SYSCLK APBCLK1 Bit Field Definitions */
N#define SYSCLK_APBCLK1_SC2_EN_Pos                2                                      /*!< SYSCLK APBCLK1: SC2_EN Position */
N#define SYSCLK_APBCLK1_SC2_EN_Msk                (1ul << SYSCLK_APBCLK1_SC2_EN_Pos)     /*!< SYSCLK APBCLK1: SC2_EN Mask */
N
N#define SYSCLK_APBCLK1_SC1_EN_Pos                1                                      /*!< SYSCLK APBCLK1: SC1_EN Position */
N#define SYSCLK_APBCLK1_SC1_EN_Msk                (1ul << SYSCLK_APBCLK1_SC1_EN_Pos)     /*!< SYSCLK APBCLK1: SC1_EN Mask */
N
N#define SYSCLK_APBCLK1_SC0_EN_Pos                0                                      /*!< SYSCLK APBCLK1: SC0_EN Position */
N#define SYSCLK_APBCLK1_SC0_EN_Msk                (1ul << SYSCLK_APBCLK1_SC0_EN_Pos)     /*!< SYSCLK APBCLK1: SC0_EN Mask */
N
N/* SYSCLK CLKSTATUS Bit Field Definitions */
N#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                           /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Position */
N#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Mask */
N
N#define SYSCLK_CLKSTATUS_IRC22M_STB_Pos         4                                           /*!< SYSCLK CLKSTATUS: IRC22M_STB Position */
N#define SYSCLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_IRC22M_STB_Pos)    /*!< SYSCLK CLKSTATUS: IRC22M_STB Mask */
N
N#define SYSCLK_CLKSTATUS_IRC10K_STB_Pos         3                                           /*!< SYSCLK CLKSTATUS: IRC10K_STB Position */
N#define SYSCLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_IRC10K_STB_Pos)    /*!< SYSCLK CLKSTATUS: IRC10K_STB Mask */
N
N#define SYSCLK_CLKSTATUS_PLL_STB_Pos            2                                           /*!< SYSCLK CLKSTATUS: PLL_STB Position */
N#define SYSCLK_CLKSTATUS_PLL_STB_Msk            (1ul << SYSCLK_CLKSTATUS_PLL_STB_Pos)       /*!< SYSCLK CLKSTATUS: PLL_STB Mask */
N
N#define SYSCLK_CLKSTATUS_XTL32K_STB_Pos         1                                           /*!< SYSCLK CLKSTATUS: XTL32K_STB Position */
N#define SYSCLK_CLKSTATUS_XTL32K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL32K_STB_Pos)    /*!< SYSCLK CLKSTATUS: XTL32K_STB Mask */
N
N#define SYSCLK_CLKSTATUS_XTL12M_STB_Pos         0                                           /*!< SYSCLK CLKSTATUS: XTL12M_STB Position */
N#define SYSCLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL12M_STB_Pos)    /*!< SYSCLK CLKSTATUS: XTL12M_STB Mask */
N
N/* SYSCLK CLKSEL0 Bit Field Definitions */
N#define SYSCLK_CLKSEL0_STCLK_S_Pos              3                                           /*!< SYSCLK CLKSEL0: STCLK_S Position */
N#define SYSCLK_CLKSEL0_STCLK_S_Msk              (7ul << SYSCLK_CLKSEL0_STCLK_S_Pos)         /*!< SYSCLK CLKSEL0: STCLK_S Mask */
N
N#define SYSCLK_CLKSEL0_HCLK_S_Pos               0                                           /*!< SYSCLK CLKSEL0: HCLK_S Position */
N#define SYSCLK_CLKSEL0_HCLK_S_Msk               (7ul << SYSCLK_CLKSEL0_HCLK_S_Pos)          /*!< SYSCLK CLKSEL0: HCLK_S Mask */
N
N/* SYSCLK CLKSEL1 Bit Field Definitions */
N#define SYSCLK_CLKSEL1_PWM23_S_Pos              30                                      /*!< SYSCLK CLKSEL1: PWM23_S Position */
N#define SYSCLK_CLKSEL1_PWM23_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM23_S_Pos)     /*!< SYSCLK CLKSEL1: PWM23_S Mask */
N
N#define SYSCLK_CLKSEL1_PWM01_S_Pos              28                                      /*!< SYSCLK CLKSEL1: PWM01_S Position */
N#define SYSCLK_CLKSEL1_PWM01_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM01_S_Pos)     /*!< SYSCLK CLKSEL1: PWM01_S Mask */
N
N#define SYSCLK_CLKSEL1_UART_S_Pos               24                                      /*!< SYSCLK CLKSEL1: UART_S Position */
N#define SYSCLK_CLKSEL1_UART_S_Msk               (3ul << SYSCLK_CLKSEL1_UART_S_Pos)      /*!< SYSCLK CLKSEL1: UART_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR3_S_Pos               20                                      /*!< SYSCLK CLKSEL1: TMR3_S Position */
N#define SYSCLK_CLKSEL1_TMR3_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR3_S_Pos)      /*!< SYSCLK CLKSEL1: TMR3_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR2_S_Pos               16                                      /*!< SYSCLK CLKSEL1: TMR2_S Position */
N#define SYSCLK_CLKSEL1_TMR2_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR2_S_Pos)      /*!< SYSCLK CLKSEL1: TMR2_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR1_S_Pos               12                                      /*!< SYSCLK CLKSEL1: TMR1_S Position */
N#define SYSCLK_CLKSEL1_TMR1_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR1_S_Pos)      /*!< SYSCLK CLKSEL1: TMR1_S Mask */
N
N#define SYSCLK_CLKSEL1_TMR0_S_Pos               8                                       /*!< SYSCLK CLKSEL1: TMR0_S Position */
N#define SYSCLK_CLKSEL1_TMR0_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR0_S_Pos)      /*!< SYSCLK CLKSEL1: TMR0_S Mask */
N
N#define SYSCLK_CLKSEL1_SPI3_S_Pos               7                                       /*!< SYSCLK CLKSEL1: SPI3_S Position */
N#define SYSCLK_CLKSEL1_SPI3_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI3_S_Pos)      /*!< SYSCLK CLKSEL1: SPI3_S Mask */
N
N#define SYSCLK_CLKSEL1_SPI2_S_Pos               6                                       /*!< SYSCLK CLKSEL1: SPI2_S Position */
N#define SYSCLK_CLKSEL1_SPI2_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI2_S_Pos)      /*!< SYSCLK CLKSEL1: SPI2_S Mask */
N
N#define SYSCLK_CLKSEL1_SPI1_S_Pos               5                                       /*!< SYSCLK CLKSEL1: SPI1_S Position */
N#define SYSCLK_CLKSEL1_SPI1_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI1_S_Pos)      /*!< SYSCLK CLKSEL1: SPI1_S Mask */
N
N#define SYSCLK_CLKSEL1_SPI0_S_Pos               4                                       /*!< SYSCLK CLKSEL1: SPI0_S Position */
N#define SYSCLK_CLKSEL1_SPI0_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI0_S_Pos)      /*!< SYSCLK CLKSEL1: SPI0_S Mask */
N
N#define SYSCLK_CLKSEL1_ADC_S_Pos                2                                       /*!< SYSCLK CLKSEL1: ADC_S Position */
N#define SYSCLK_CLKSEL1_ADC_S_Msk                (3ul << SYSCLK_CLKSEL1_ADC_S_Pos)       /*!< SYSCLK CLKSEL1: ADC_S Mask */
N
N#define SYSCLK_CLKSEL1_WDT_S_Pos                0                                       /*!< SYSCLK CLKSEL1: WDT_S Position */
N#define SYSCLK_CLKSEL1_WDT_S_Msk                (3ul << SYSCLK_CLKSEL1_WDT_S_Pos)       /*!< SYSCLK CLKSEL1: WDT_S Mask */
N
N/* SYSCLK CLKSEL2 Bit Field Definitions */
N#define SYSCLK_CLKSEL2_WWDT_S_Pos              16                                       /*!< SYSCLK CLKSEL2: WWDT_S Position */
N#define SYSCLK_CLKSEL2_WWDT_S_Msk              (3ul << SYSCLK_CLKSEL2_WWDT_S_Pos)       /*!< SYSCLK CLKSEL2: WWDT_S Mask */
N
N#define SYSCLK_CLKSEL2_PWM67_S_EXT_Pos         11                                       /*!< SYSCLK CLKSEL2: PWM67_S_EXT Position */
N#define SYSCLK_CLKSEL2_PWM67_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM67_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM67_S_EXT Mask */
N
N#define SYSCLK_CLKSEL2_PWM45_S_EXT_Pos         10                                       /*!< SYSCLK CLKSEL2: PWM45_S_EXT Position */
N#define SYSCLK_CLKSEL2_PWM45_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM45_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM45_S_EXT Mask */
N
N#define SYSCLK_CLKSEL2_PWM23_S_EXT_Pos         9                                        /*!< SYSCLK CLKSEL2: PWM23_S_EXT Position */
N#define SYSCLK_CLKSEL2_PWM23_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM23_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM23_S_EXT Mask */
N
N#define SYSCLK_CLKSEL2_PWM01_S_EXT_Pos         8                                        /*!< SYSCLK CLKSEL2: PWM01_S_EXT Position */
N#define SYSCLK_CLKSEL2_PWM01_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM01_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM01_S_EXT Mask */
N
N#define SYSCLK_CLKSEL2_PWM67_S_Pos              6                                       /*!< SYSCLK CLKSEL2: PWM67_S_ Position */
N#define SYSCLK_CLKSEL2_PWM67_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM67_S_Pos)     /*!< SYSCLK CLKSEL2: PWM67_S_ Mask */
N
N#define SYSCLK_CLKSEL2_PWM45_S_Pos              4                                       /*!< SYSCLK CLKSEL2: PWM45_S Position */
N#define SYSCLK_CLKSEL2_PWM45_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM45_S_Pos)      /*!< SYSCLK CLKSEL2: PWM45_S Mask */
N
N#define SYSCLK_CLKSEL2_FRQDIV_S_Pos             2                                       /*!< SYSCLK CLKSEL2: FRQDIV_S Position */
N#define SYSCLK_CLKSEL2_FRQDIV_S_Msk             (3ul << SYSCLK_CLKSEL2_FRQDIV_S_Pos)    /*!< SYSCLK CLKSEL2: FRQDIV_S Mask */
N
N#define SYSCLK_CLKSEL2_I2S_S_Pos                0                                       /*!< SYSCLK CLKSEL2: I2S_S Position */
N#define SYSCLK_CLKSEL2_I2S_S_Msk                (3ul << SYSCLK_CLKSEL2_I2S_S_Pos)       /*!< SYSCLK CLKSEL2: I2S_S Mask */
N
N/* SYSCLK CLKSEL3 Bit Field Definitions */
N#define SYSCLK_CLKSEL3_SC2_S_Pos                4                                       /*!< SYSCLK CLKSEL3: SC2_S Position */
N#define SYSCLK_CLKSEL3_SC2_S_Msk                (3ul << SYSCLK_CLKSEL3_SC2_S_Pos)       /*!< SYSCLK CLKSEL3: SC2_S Mask */
N
N#define SYSCLK_CLKSEL3_SC1_S_Pos                2                                       /*!< SYSCLK CLKSEL3: SC1_S Position */
N#define SYSCLK_CLKSEL3_SC1_S_Msk                (3ul << SYSCLK_CLKSEL3_SC1_S_Pos)       /*!< SYSCLK CLKSEL3: SC1_S Mask */
N
N#define SYSCLK_CLKSEL3_SC0_S_Pos                0                                       /*!< SYSCLK CLKSEL3: SC0_S Position */
N#define SYSCLK_CLKSEL3_SC0_S_Msk                (3ul << SYSCLK_CLKSEL3_SC0_S_Pos)       /*!< SYSCLK CLKSEL3: SC0_S Mask */
N
N/* SYSCLK CLKDIV Bit Field Definitions */
N#define SYSCLK_CLKDIV_ADC_N_Pos                 16                                      /*!< SYSCLK CLKDIV: ADC_N Position */
N#define SYSCLK_CLKDIV_ADC_N_Msk                 (0xFFul << SYSCLK_CLKDIV_ADC_N_Pos)     /*!< SYSCLK CLKDIV: ADC_N Mask */
N
N#define SYSCLK_CLKDIV_UART_N_Pos                8                                       /*!< SYSCLK CLKDIV: UART_N Position */
N#define SYSCLK_CLKDIV_UART_N_Msk                (0xFul << SYSCLK_CLKDIV_UART_N_Pos)     /*!< SYSCLK CLKDIV: UART_N Mask */
N
N#define SYSCLK_CLKDIV_USB_N_Pos                 4                                       /*!< SYSCLK CLKDIV: USB_N Position */
N#define SYSCLK_CLKDIV_USB_N_Msk                 (0xFul << SYSCLK_CLKDIV_USB_N_Pos)      /*!< SYSCLK CLKDIV: USB_N Mask */
N
N#define SYSCLK_CLKDIV_HCLK_N_Pos                0                                       /*!< SYSCLK CLKDIV: HCLK_N Position */
N#define SYSCLK_CLKDIV_HCLK_N_Msk                (0xFul << SYSCLK_CLKDIV_HCLK_N_Pos)     /*!< SYSCLK CLKDIV: HCLK_N Mask */
N
N/* SYSCLK CLKDIV1 Bit Field Definitions */
N#define SYSCLK_CLKDIV1_SC2_N_Pos                16                                      /*!< SYSCLK CLKDIV: SC2_N Position */
N#define SYSCLK_CLKDIV1_SC2_N_Msk                (0xFFul << SYSCLK_CLKDIV1_SC2_N_Pos)    /*!< SYSCLK CLKDIV: SC2_N Mask */
N
N#define SYSCLK_CLKDIV1_SC1_N_Pos                8                                       /*!< SYSCLK CLKDIV: SC1_N Position */
N#define SYSCLK_CLKDIV1_SC1_N_Msk                (0xFFul << SYSCLK_CLKDIV1_SC1_N_Pos)    /*!< SYSCLK CLKDIV: SC1_N Mask */
N
N#define SYSCLK_CLKDIV1_SC0_N_Pos                0                                       /*!< SYSCLK CLKDIV: SC0_N Position */
N#define SYSCLK_CLKDIV1_SC0_N_Msk                (0xFFul << SYSCLK_CLKDIV1_SC0_N_Pos)    /*!< SYSCLK CLKDIV: SC0_N Mask */
N
N/* SYSCLK PLLCON Bit Field Definitions */
N#define SYSCLK_PLLCON_PLL_SRC_Pos               19                                      /*!< SYSCLK PLLCON: PLL_SRC Position */
N#define SYSCLK_PLLCON_PLL_SRC_Msk               (1ul << SYSCLK_PLLCON_PLL_SRC_Pos)      /*!< SYSCLK PLLCON: PLL_SRC Mask */
N
N#define SYSCLK_PLLCON_OE_Pos                    18                                      /*!< SYSCLK PLLCON: PLL_SRC Position */
N#define SYSCLK_PLLCON_OE_Msk                    (1ul << SYSCLK_PLLCON_OE_Pos)           /*!< SYSCLK PLLCON: PLL_SRC Mask */
N
N#define SYSCLK_PLLCON_BP_Pos                    17                                      /*!< SYSCLK PLLCON: OE Position */
N#define SYSCLK_PLLCON_BP_Msk                    (1ul << SYSCLK_PLLCON_BP_Pos)           /*!< SYSCLK PLLCON: OE Mask */
N
N#define SYSCLK_PLLCON_PD_Pos                    16                                      /*!< SYSCLK PLLCON: PD Position */
N#define SYSCLK_PLLCON_PD_Msk                    (1ul << SYSCLK_PLLCON_PD_Pos)           /*!< SYSCLK PLLCON: PD Mask */
N
N#define SYSCLK_PLLCON_OUT_DV_Pos                14                                      /*!< SYSCLK PLLCON: OUT_DV Position */
N#define SYSCLK_PLLCON_OUT_DV_Msk                (3ul << SYSCLK_PLLCON_OUT_DV_Pos)       /*!< SYSCLK PLLCON: OUT_DV Mask */
N
N#define SYSCLK_PLLCON_IN_DV_Pos                 9                                       /*!< SYSCLK PLLCON: IN_DV Position */
N#define SYSCLK_PLLCON_IN_DV_Msk                 (0x1Ful << SYSCLK_PLLCON_IN_DV_Pos)     /*!< SYSCLK PLLCON: IN_DV Mask */
N
N#define SYSCLK_PLLCON_FB_DV_Pos                 0                                       /*!< SYSCLK PLLCON: FB_DV Position */
N#define SYSCLK_PLLCON_FB_DV_Msk                 (0x1FFul << SYSCLK_PLLCON_FB_DV_Pos)    /*!< SYSCLK PLLCON: FB_DV Mask */
N
N/* SYSCLK FRQDIV Bit Field Definitions */
N#define SYSCLK_FRQDIV_DIVIDER_EN_Pos            4                                       /*!< SYSCLK FRQDIV: DIVIDER_EN Position */
N#define SYSCLK_FRQDIV_DIVIDER_EN_Msk            (1ul << SYSCLK_FRQDIV_DIVIDER_EN_Pos)   /*!< SYSCLK FRQDIV: DIVIDER_EN Mask */
N
N#define SYSCLK_FRQDIV_FSEL_Pos                  0                                       /*!< SYSCLK FRQDIV: FRQDIV_FSEL Position */
N#define SYSCLK_FRQDIV_FSEL_Msk                  (0xFul << SYSCLK_FRQDIV_FSEL_Pos)       /*!< SYSCLK FRQDIV: FRQDIV_FSEL Mask */
N
N/*@}*/ /* end of group NUC200_SYSCLK */
N
N/*---------------------------- Global Controller -----------------------------*/
N/** @addtogroup NUC200_SYS NUC200 System Controller
N  Memory Mapped Structure for NUC200 Series System Controller
N  @{
N */
N
Ntypedef struct
N{
N    __I uint32_t PDID;
X    volatile const uint32_t PDID;
N    __IO uint32_t RSTSRC;
X    volatile uint32_t RSTSRC;
N    __IO uint32_t IPRSTC1;
X    volatile uint32_t IPRSTC1;
N    __IO uint32_t IPRSTC2;
X    volatile uint32_t IPRSTC2;
N    __IO uint32_t IPRSTC3;   
X    volatile uint32_t IPRSTC3;   
N    uint32_t RESERVE0;
N    __IO uint32_t BODCR;
X    volatile uint32_t BODCR;
N    __IO uint32_t TEMPCR;
X    volatile uint32_t TEMPCR;
N    uint32_t RESERVE1;
N    __IO uint32_t PORCR;
X    volatile uint32_t PORCR;
N    uint32_t RESERVE2[2];
N    __IO uint32_t GPA_MFP;
X    volatile uint32_t GPA_MFP;
N    __IO uint32_t GPB_MFP;
X    volatile uint32_t GPB_MFP;
N    __IO uint32_t GPC_MFP;
X    volatile uint32_t GPC_MFP;
N    __IO uint32_t GPD_MFP;
X    volatile uint32_t GPD_MFP;
N    __IO uint32_t GPE_MFP;
X    volatile uint32_t GPE_MFP;
N    __IO uint32_t GPF_MFP;
X    volatile uint32_t GPF_MFP;
N    uint32_t RESERVE3[2];
N    __IO uint32_t ALT_MFP;
X    volatile uint32_t ALT_MFP;
N    uint32_t RESERVE4;
N    __IO uint32_t ALT_MFP1;
X    volatile uint32_t ALT_MFP1;
N    uint32_t RESERVE5[9];
N    __IO uint32_t IRCTRIMCTL;
X    volatile uint32_t IRCTRIMCTL;
N    __IO uint32_t IRCTRIMIEN;  
X    volatile uint32_t IRCTRIMIEN;  
N    __IO uint32_t IRCTRIMINT; 
X    volatile uint32_t IRCTRIMINT; 
N    uint32_t RESERVE6[29];       
N    __IO uint32_t REGWRPROT;
X    volatile uint32_t REGWRPROT;
N} GCR_T;
N
N/* GCR RSTSRC Bit Field Definitions */
N#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                   /*!< GCR RSTSRC: RSTS_CPU Position */
N#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)    /*!< GCR RSTSRC: RSTS_CPU Mask */
N
N#define SYS_RSTSRC_RSTS_SYS_Pos                 5                                   /*!< GCR RSTSRC: RSTS_SYS Position */
N#define SYS_RSTSRC_RSTS_SYS_Msk                 (1ul << SYS_RSTSRC_RSTS_SYS_Pos)    /*!< GCR RSTSRC: RSTS_SYS Mask */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                   /*!< GCR RSTSRC: RSTS_BOD Position */
N#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)    /*!< GCR RSTSRC: RSTS_BOD Mask */
N
N#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                   /*!< GCR RSTSRC: RSTS_LVR Position */
N#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)    /*!< GCR RSTSRC: RSTS_LVR Mask */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                   /*!< GCR RSTSRC: RSTS_WDT Position */
N#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)    /*!< GCR RSTSRC: RSTS_WDT Mask */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos               1                                   /*!< GCR RSTSRC: RSTS_RESET Position */
N#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)  /*!< GCR RSTSRC: RSTS_RESET Mask */
N
N#define SYS_RSTSRC_RSTS_POR_Pos                 0                                   /*!< GCR RSTSRC: RSTS_POR Position */
N#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)    /*!< GCR RSTSRC: RSTS_POR Mask */
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define SYS_IPRSTC1_PDMA_RST_Pos                2                                   /*!< GCR IPRSTC1: PDMA_RST Position */
N#define SYS_IPRSTC1_PDMA_RST_Msk                (1ul << SYS_IPRSTC1_PDMA_RST_Pos)   /*!< GCR IPRSTC1: PDMA_RST Mask */
N
N#define SYS_IPRSTC1_CPU_RST_Pos                 1                                   /*!< GCR IPRSTC1: CPU_RST Position */
N#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)    /*!< GCR IPRSTC1: CPU_RST Mask */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos                0                                   /*!< GCR IPRSTC1: CHIP_RST Position */
N#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)   /*!< GCR IPRSTC1: CHIP_RST Mask */
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define SYS_IPRSTC2_I2S_RST_Pos                 29                                  /*!< GCR IPRSTC2: I2S_RST Position */
N#define SYS_IPRSTC2_I2S_RST_Msk                 (1ul << SYS_IPRSTC2_I2S_RST_Pos)    /*!< GCR IPRSTC2: I2S_RST Mask */
N
N#define SYS_IPRSTC2_ADC_RST_Pos                 28                                  /*!< GCR IPRSTC2: ADC_RST Position */
N#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)    /*!< GCR IPRSTC2: ADC_RST Mask */
N
N#define SYS_IPRSTC2_USBD_RST_Pos                27                                  /*!< GCR IPRSTC2: USBD_RST Position */
N#define SYS_IPRSTC2_USBD_RST_Msk                (1ul << SYS_IPRSTC2_USBD_RST_Pos)   /*!< GCR IPRSTC2: USBD_RST Mask */
N
N#define SYS_IPRSTC2_CAN1_RST_Pos                25                                  /*!< GCR IPRSTC2: CAN1_RST Position */
N#define SYS_IPRSTC2_CAN1_RST_Msk                (1ul << SYS_IPRSTC2_CAN1_RST_Pos)   /*!< GCR IPRSTC2: CAN1_RST Mask */
N
N#define SYS_IPRSTC2_CAN0_RST_Pos                24                                  /*!< GCR IPRSTC2: CAN0_RST Position */
N#define SYS_IPRSTC2_CAN0_RST_Msk                (1ul << SYS_IPRSTC2_CAN0_RST_Pos)   /*!< GCR IPRSTC2: CAN0_RST Mask */
N
N#define SYS_IPRSTC2_PS2_RST_Pos                 23                                  /*!< GCR IPRSTC2: PS2_RST Position */
N#define SYS_IPRSTC2_PS2_RST_Msk                 (1ul << SYS_IPRSTC2_PS2_RST_Pos)    /*!< GCR IPRSTC2: PS2_RST Mask */
N
N#define SYS_IPRSTC2_ACMP_RST_Pos                22                                  /*!< GCR IPRSTC2: ACMP_RST Position */
N#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)   /*!< GCR IPRSTC2: ACMP_RST Mask */
N
N#define SYS_IPRSTC2_PWM47_RST_Pos               21                                  /*!< GCR IPRSTC2: PWM47_RST Position */
N#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)  /*!< GCR IPRSTC2: PWM47_RST Mask */
N
N#define SYS_IPRSTC2_PWM03_RST_Pos               20                                  /*!< GCR IPRSTC2: PWM03_RST Position */
N#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)  /*!< GCR IPRSTC2: PWM03_RST Mask */
N
N#define SYS_IPRSTC2_UART2_RST_Pos               18                                  /*!< GCR IPRSTC2: UART2_RST Position */
N#define SYS_IPRSTC2_UART2_RST_Msk               (1ul << SYS_IPRSTC2_UART2_RST_Pos)  /*!< GCR IPRSTC2: UART2_RST Mask */
N
N#define SYS_IPRSTC2_UART1_RST_Pos               17                                  /*!< GCR IPRSTC2: UART1_RST Position */
N#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)  /*!< GCR IPRSTC2: UART1_RST Mask */
N
N#define SYS_IPRSTC2_UART0_RST_Pos               16                                  /*!< GCR IPRSTC2: UART0_RST Position */
N#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)  /*!< GCR IPRSTC2: UART0_RST Mask */
N
N#define SYS_IPRSTC2_SPI3_RST_Pos                15                                  /*!< GCR IPRSTC2: SPI3_RST Position */
N#define SYS_IPRSTC2_SPI3_RST_Msk                (1ul << SYS_IPRSTC2_SPI3_RST_Pos)   /*!< GCR IPRSTC2: SPI3_RST Mask */
N
N#define SYS_IPRSTC2_SPI2_RST_Pos                14                                  /*!< GCR IPRSTC2: SPI2_RST Position */
N#define SYS_IPRSTC2_SPI2_RST_Msk                (1ul << SYS_IPRSTC2_SPI2_RST_Pos)   /*!< GCR IPRSTC2: SPI2_RST Mask */
N
N#define SYS_IPRSTC2_SPI1_RST_Pos                13                                  /*!< GCR IPRSTC2: SPI1_RST Position */
N#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)   /*!< GCR IPRSTC2: SPI1_RST Mask */
N
N#define SYS_IPRSTC2_SPI0_RST_Pos                12                                  /*!< GCR IPRSTC2: SPI0_RST Position */
N#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)   /*!< GCR IPRSTC2: SPI0_RST Mask */
N
N#define SYS_IPRSTC2_I2C1_RST_Pos                9                                   /*!< GCR IPRSTC2: I2C1_RST Position */
N#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)   /*!< GCR IPRSTC2: I2C1_RST Mask */
N
N#define SYS_IPRSTC2_I2C0_RST_Pos                8                                   /*!< GCR IPRSTC2: I2C0_RST Position */
N#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)   /*!< GCR IPRSTC2: I2C0_RST Mask */
N
N#define SYS_IPRSTC2_TMR3_RST_Pos                5                                   /*!< GCR IPRSTC2: TMR3_RST Position */
N#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)   /*!< GCR IPRSTC2: TMR3_RST Mask */
N
N#define SYS_IPRSTC2_TMR2_RST_Pos                4                                   /*!< GCR IPRSTC2: TMR2_RST Position */
N#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)   /*!< GCR IPRSTC2: TMR2_RST Mask */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos                3                                   /*!< GCR IPRSTC2: TMR1_RST Position */
N#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)   /*!< GCR IPRSTC2: TMR1_RST Mask */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos                2                                   /*!< GCR IPRSTC2: TMR0_RST Position */
N#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)   /*!< GCR IPRSTC2: TMR0_RST Mask */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos                1                                   /*!< GCR IPRSTC2: GPIO_RST Position */
N#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)   /*!< GCR IPRSTC2: GPIO_RST Mask */
N
N/* GCR IPRSTC3 Bit Field Definitions */
N#define SYS_IPRSTC3_SC2_RST_Pos                 2                                   /*!< GCR IPRSTC3: SC2_RST Position */
N#define SYS_IPRSTC3_SC2_RST_Msk                 (1ul << SYS_IPRSTC3_SC2_RST_Pos)    /*!< GCR IPRSTC3: SC2_RST Mask */
N
N#define SYS_IPRSTC3_SC1_RST_Pos                 1                                   /*!< GCR IPRSTC3: SC1_RST Position */
N#define SYS_IPRSTC3_SC1_RST_Msk                 (1ul << SYS_IPRSTC3_SC1_RST_Pos)    /*!< GCR IPRSTC3: SC1_RST Mask */
N
N#define SYS_IPRSTC3_SC0_RST_Pos                 0                                   /*!< GCR IPRSTC3: SC0_RST Position */
N#define SYS_IPRSTC3_SC0_RST_Msk                 (1ul << SYS_IPRSTC3_SC0_RST_Pos)    /*!< GCR IPRSTC3: SC0_RST Mask */
N
N/* GCR BODCR Bit Field Definitions */
N#define SYS_BODCR_LVR_EN_Pos                    7                                   /*!< GCR BODCR: LVR_EN Position */
N#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)       /*!< GCR BODCR: LVR_EN Mask */
N
N#define SYS_BODCR_BOD_OUT_Pos                   6                                   /*!< GCR BODCR: BOD_OUT Position */
N#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)      /*!< GCR BODCR: BOD_OUT Mask */
N
N#define SYS_BODCR_BOD_LPM_Pos                   5                                   /*!< GCR BODCR: BOD_LPM Position */
N#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)      /*!< GCR BODCR: BOD_LPM Mask */
N
N#define SYS_BODCR_BOD_INTF_Pos                  4                                   /*!< GCR BODCR: BOD_INTF Position */
N#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)     /*!< GCR BODCR: BOD_INTF Mask */
N
N#define SYS_BODCR_BOD_RSTEN_Pos                 3                                   /*!< GCR BODCR: BOD_RSTEN Position */
N#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)    /*!< GCR BODCR: BOD_RSTEN Mask */
N
N#define SYS_BODCR_BOD_VL_Pos                    1                                   /*!< GCR BODCR: BOD_VL Position */
N#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)       /*!< GCR BODCR: BOD_VL Mask */
N
N#define SYS_BODCR_BOD_EN_Pos                    0                                   /*!< GCR BODCR: BOD_EN Position */
N#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)       /*!< GCR BODCR: BOD_EN Mask */
N
N/* GCR TEMPCR Bit Field Definitions */
N#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                   /*!< GCR TEMPCR: VTEMP_EN Position */
N#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)    /*!< GCR TEMPCR: VTEMP_EN Mask */
N
N/* GCR PORCR Bit Field Definitions */
N#define SYS_PORCR_POR_DIS_CODE_Pos              0                                           /*!< GCR PORCR: POR_DIS_CODE Position */
N#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)    /*!< GCR PORCR: POR_DIS_CODE Mask */
N
N/* GCR GPAMFP Bit Field Definitions */
N#define SYS_GPA_MFP_GPA_TYPE_Pos                 16                                         /*!< GCR GPA_MFP: GPA_TYPE Position */
N#define SYS_GPA_MFP_GPA_TYPE_Msk                 (0xFFFFul << SYS_GPA_MFP_GPA_TYPE_Pos)     /*!< GCR GPA_MFP: GPA_TYPE Mask */
N
N#define SYS_GPA_MFP_GPA_MFP_Pos                  0                                          /*!< GCR GPA_MFP: GPA_MFP Position */
N#define SYS_GPA_MFP_GPA_MFP_Msk                  (0xFFFFul << SYS_GPA_MFP_GPA_MFP_Pos)      /*!< GCR GPA_MFP: GPA_MFP Mask */
N
N
N/* GCR GPBMFP Bit Field Definitions */
N#define SYS_GPB_MFP_GPB_TYPE_Pos                 16                                         /*!< GCR GPB_MFP: GPB_TYPE Position */
N#define SYS_GPB_MFP_GPB_TYPE_Msk                 (0xFFFFul << SYS_GPB_MFP_GPB_TYPE_Pos)     /*!< GCR GPB_MFP: GPB_TYPE Mask */
N
N#define SYS_GPB_MFP_GPB_MFP_Pos                  0                                          /*!< GCR GPB_MFP: GPB_MFP Position */
N#define SYS_GPB_MFP_GPB_MFP_Msk                  (0xFFFFul << SYS_GPB_MFP_GPB_MFP_Pos)      /*!< GCR GPB_MFP: GPB_MFP Mask */
N
N/* GCR GPCMFP Bit Field Definitions */
N#define SYS_GPC_MFP_GPC_TYPE_Pos                 16                                         /*!< GCR GPC_MFP: GPC_TYPE Position */
N#define SYS_GPC_MFP_GPC_TYPE_Msk                 (0xFFFFul << SYS_GPC_MFP_GPC_TYPE_Pos)     /*!< GCR GPC_MFP: GPC_TYPE Mask */
N
N#define SYS_GPC_MFP_GPC_MFP_Pos                  0                                          /*!< GCR GPC_MFP: GPC_MFP Position */
N#define SYS_GPC_MFP_GPC_MFP_Msk                  (0xFFFFul << SYS_GPC_MFP_GPC_MFP_Pos)      /*!< GCR GPC_MFP: GPC_MFP Mask */
N
N/* GCR GPDMFP Bit Field Definitions */
N#define SYS_GPD_MFP_GPD_TYPE_Pos                 16                                         /*!< GCR GPD_MFP: GPD_TYPE Position */
N#define SYS_GPD_MFP_GPD_TYPE_Msk                 (0xFFFFul << SYS_GPD_MFP_GPD_TYPE_Pos)     /*!< GCR GPD_MFP: GPD_TYPE Mask */
N
N#define SYS_GPD_MFP_GPD_MFP_Pos                  0                                          /*!< GCR GPD_MFP: GPD_MFP Position */
N#define SYS_GPD_MFP_GPD_MFP_Msk                  (0xFFFFul << SYS_GPD_MFP_GPD_MFP_Pos)      /*!< GCR GPD_MFP: GPD_MFP Mask */
N
N/* GCR GPEMFP Bit Field Definitions */
N#define SYS_GPE_MFP_GPE_TYPE_Pos                 16                                         /*!< GCR GPE_MFP: GPE_TYPE Position */
N#define SYS_GPE_MFP_GPE_TYPE_Msk                 (0xFFFFul << SYS_GPE_MFP_GPE_TYPE_Pos)     /*!< GCR GPE_MFP: GPE_TYPE Mask */
N
N#define SYS_GPE_MFP_GPE_MFP5_Pos                 5                                          /*!< GCR GPE_MFP: GPE_MFP5 Position */     
N#define SYS_GPE_MFP_GPE_MFP5_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP5_Pos)          /*!< GCR GPE_MFP: GPE_MFP5 Mask */
N
N#define SYS_GPE_MFP_GPE_MFP1_Pos                 1                                          /*!< GCR GPE_MFP: GPE_MFP1 Position */
N#define SYS_GPE_MFP_GPE_MFP1_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP1_Pos)          /*!< GCR GPE_MFP: GPE_MFP1 Mask */
N
N#define SYS_GPE_MFP_GPE_MFP0_Pos                 0                                          /*!< GCR GPE_MFP: GPE_MFP0 Position */
N#define SYS_GPE_MFP_GPE_MFP0_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP0_Pos)          /*!< GCR GPE_MFP: GPE_MFP0 Mask */
N
N/* GCR GPFMFP Bit Field Definitions */
N#define SYS_GPF_MFP_GPF_TYPE_Pos                 16                                         /*!< GCR GPF_MFP: GPF_TYPE Position */
N#define SYS_GPF_MFP_GPF_TYPE_Msk                 (0xFul << SYS_GPF_MFP_GPF_TYPE_Pos)        /*!< GCR GPF_MFP: GPF_TYPE Mask */
N
N#define SYS_GPF_MFP_GPF_MFP3_Pos                 3                                          /*!< GCR GPF_MFP: GPF_MFP3 Position */
N#define SYS_GPF_MFP_GPF_MFP3_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP3_Pos)          /*!< GCR GPF_MFP: GPF_MFP3 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP2_Pos                 2                                          /*!< GCR GPF_MFP: GPF_MFP2 Position */
N#define SYS_GPF_MFP_GPF_MFP2_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP2_Pos)          /*!< GCR GPF_MFP: GPF_MFP2 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP1_Pos                 1                                          /*!< GCR GPF_MFP: GPF_MFP1 Position */
N#define SYS_GPF_MFP_GPF_MFP1_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP1_Pos)          /*!< GCR GPF_MFP: GPF_MFP1 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP0_Pos                 0                                          /*!< GCR GPF_MFP: GPF_MFP0 Position */
N#define SYS_GPF_MFP_GPF_MFP0_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP0_Pos)          /*!< GCR GPF_MFP: GPF_MFP0 Mask */
N
N/* GCR ALTMFP Bit Field Definitions */
N#define SYS_ALT_MFP_PB2_CPO0_Pos                30                                          /*!< GCR ALT_MFP: PB2_CPO0 Position */
N#define SYS_ALT_MFP_PB2_CPO0_Msk                (1ul << SYS_ALT_MFP_PB2_CPO0_Pos)           /*!< GCR ALT_MFP: PB2_CPO0 Mask */
N
N#define SYS_ALT_MFP_PB8_CLKO_Pos                29                                         /*!< GCR ALT_MFP: PB8_CLKO Position */
N#define SYS_ALT_MFP_PB8_CLKO_Msk                (1ul << SYS_ALT_MFP_PB8_CLKO_Pos)      /*!< GCR ALT_MFP: PB8_CLKO Mask */
N
N#define SYS_ALT_MFP_PA10_11_CAN1_Pos             28                                         /*!< GCR ALT_MFP: PA10_11_CAN1 Position */
N#define SYS_ALT_MFP_PA10_11_CAN1_Msk             (1ul << SYS_ALT_MFP_PA10_11_CAN1_Pos)      /*!< GCR ALT_MFP: PA10_11_CAN1 Mask */
N
N#define SYS_ALT_MFP_PB3_T3EX_Pos                 27                                         /*!< GCR ALT_MFP: PB3_T3EX Position */
N#define SYS_ALT_MFP_PB3_T3EX_Msk                 (1ul << SYS_ALT_MFP_PB3_T3EX_Pos)          /*!< GCR ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PB2_T2EX_Pos                 26                                         /*!< GCR ALT_MFP: PB2_T2EX Position */
N#define SYS_ALT_MFP_PB2_T2EX_Msk                 (1ul << SYS_ALT_MFP_PB2_T2EX_Pos)          /*!< GCR ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PE5_T1EX_Pos                 25                                         /*!< GCR ALT_MFP: PE5_T1EX Position */
N#define SYS_ALT_MFP_PE5_T1EX_Msk                 (1ul << SYS_ALT_MFP_PE5_T1EX_Pos)          /*!< GCR ALT_MFP: PE5_T1EX Mask */
N
N#define SYS_ALT_MFP_PB15_T0EX_Pos                24                                         /*!< GCR ALT_MFP: PB15_T0EX Position */
N#define SYS_ALT_MFP_PB15_T0EX_Msk                (1ul << SYS_ALT_MFP_PB15_T0EX_Pos)         /*!< GCR ALT_MFP: PB15_T0EX Mask */
N
N#define SYS_ALT_MFP_PB12_CLKO_Pos                10                                         /*!< GCR ALT_MFP: PB12_CLKO Position */
N#define SYS_ALT_MFP_PB12_CLKO_Msk                (1ul << SYS_ALT_MFP_PB12_CLKO_Pos)         /*!< GCR ALT_MFP: PB12_CLKO Mask */
N
N#define SYS_ALT_MFP_PA15_I2SMCLK_Pos             9                                          /*!< GCR ALT_MFP: PA15_I2SMCLK Position */
N#define SYS_ALT_MFP_PA15_I2SMCLK_Msk             (1ul << SYS_ALT_MFP_PA15_I2SMCLK_Pos)      /*!< GCR ALT_MFP: PA15_I2SMCLK Mask */
N
N#define SYS_ALT_MFP_PC3_I2SDO_Pos                8                                          /*!< GCR ALT_MFP: PC3_I2SDO Position */
N#define SYS_ALT_MFP_PC3_I2SDO_Msk                (1ul << SYS_ALT_MFP_PC3_I2SDO_Pos)         /*!< GCR ALT_MFP: PC3_I2SDO Mask */
N
N#define SYS_ALT_MFP_PC2_I2SDI_Pos                7                                          /*!< GCR ALT_MFP: PC2_I2SDI Position */
N#define SYS_ALT_MFP_PC2_I2SDI_Msk                (1ul << SYS_ALT_MFP_PC2_I2SDI_Pos)         /*!< GCR ALT_MFP: PC2_I2SDI Mask */
N
N#define SYS_ALT_MFP_PC1_I2SBCLK_Pos              6                                          /*!< GCR ALT_MFP: PC1_I2SBCLK Position */
N#define SYS_ALT_MFP_PC1_I2SBCLK_Msk              (1ul << SYS_ALT_MFP_PC1_I2SBCLK_Pos)       /*!< GCR ALT_MFP: PC1_I2SBCLK Mask */
N
N#define SYS_ALT_MFP_PC0_I2SLRCLK_Pos             5                                          /*!< GCR ALT_MFP: PC0_I2SLRCLK Position */
N#define SYS_ALT_MFP_PC0_I2SLRCLK_Msk             (1ul << SYS_ALT_MFP_PC0_I2SLRCLK_Pos)      /*!< GCR ALT_MFP: PC0_I2SLRCLK Mask */
N
N#define SYS_ALT_MFP_PB11_PWM4_Pos                4                                          /*!< GCR ALT_MFP: PB11_PWM4 Position */
N#define SYS_ALT_MFP_PB11_PWM4_Msk                (1ul << SYS_ALT_MFP_PB11_PWM4_Pos)         /*!< GCR ALT_MFP: PB11_PWM4 Mask */
N
N#define SYS_ALT_MFP_PB14_S31_Pos                 3                                          /*!< GCR ALT_MFP: PB14_S31 Position */
N#define SYS_ALT_MFP_PB14_S31_Msk                 (1ul << SYS_ALT_MFP_PB14_S31_Pos)          /*!< GCR ALT_MFP: PB14_S31 Mask */
N
N#define SYS_ALT_MFP_PA7_S21_Pos                  2                                          /*!< GCR ALT_MFP: PA7_S21 Position */
N#define SYS_ALT_MFP_PA7_S21_Msk                  (1ul << SYS_ALT_MFP_PA7_S21_Pos)           /*!< GCR ALT_MFP: PA7_S21 Mask */
N
N#define SYS_ALT_MFP_PB9_S11_Pos                  1                                          /*!< GCR ALT_MFP: PB9_S11 Position */
N#define SYS_ALT_MFP_PB9_S11_Msk                  (1ul << SYS_ALT_MFP_PB9_S11_Pos)           /*!< GCR ALT_MFP: PB9_S11 Mask */
N
N#define SYS_ALT_MFP_PB10_S01_Pos                 0                                          /*!< GCR ALT_MFP: PB10_S01 Position */
N#define SYS_ALT_MFP_PB10_S01_Msk                 (1ul << SYS_ALT_MFP_PB10_S01_Pos)          /*!< GCR ALT_MFP: PB10_S01 Mask */
N
N/* GCR ALTMFP1 Bit Field Definitions */
N#define SYS_ALT_MFP1_PB3_SC2CD_Pos              14                                          /*!< GCR ALT_MFP1: PB3_SC2CD Position */
N#define SYS_ALT_MFP1_PB3_SC2CD_Msk              (1ul << SYS_ALT_MFP1_PB3_SC2CD_Pos)         /*!< GCR ALT_MFP1: PB3_SC2CD Mask */
N
N#define SYS_ALT_MFP1_PA14_SC2RST_Pos            13                                          /*!< GCR ALT_MFP1: PA14_SC2RST Position */
N#define SYS_ALT_MFP1_PA14_SC2RST_Msk            (1ul << SYS_ALT_MFP1_PA14_SC2RST_Pos)       /*!< GCR ALT_MFP1: PA14_SC2RST Mask */
N
N#define SYS_ALT_MFP1_PA15_SC2PWR_Pos            12                                          /*!< GCR ALT_MFP1: PA15_SC2PWR Position */
N#define SYS_ALT_MFP1_PA15_SC2PWR_Msk            (1ul << SYS_ALT_MFP1_PA15_SC2PWR_Pos)       /*!< GCR ALT_MFP1: PA15_SC2PWR Mask */
N
N#define SYS_ALT_MFP1_PA12_SC2DAT_Pos             11                                          /*!< GCR ALT_MFP1: PA12_SC2DAT Position */
N#define SYS_ALT_MFP1_PA12_SC2DAT_Msk             (1ul << SYS_ALT_MFP1_PA12_SC2DAT_Pos)        /*!< GCR ALT_MFP1: PA12_SC2DAT Mask */
N
N#define SYS_ALT_MFP1_PA13_SC2CLK_Pos             10                                          /*!< GCR ALT_MFP1: PA13_SC2CLK Position */
N#define SYS_ALT_MFP1_PA13_SC2CLK_Msk             (1ul << SYS_ALT_MFP1_PA13_SC2CLK_Pos)        /*!< GCR ALT_MFP1: PA13_SC2CLK Mask */
N
N#define SYS_ALT_MFP1_PC7_SC1CD_Pos             9                                          /*!< GCR ALT_MFP1: PC7_SC1CD Position */
N#define SYS_ALT_MFP1_PC7_SC1CD_Msk             (1ul << SYS_ALT_MFP1_PC7_SC1CD_Pos)        /*!< GCR ALT_MFP1: PC7_SC1CD Mask */
N
N#define SYS_ALT_MFP1_PA5_SC1RST_Pos             8                                           /*!< GCR ALT_MFP1: PA5_SC1RST Position */
N#define SYS_ALT_MFP1_PA5_SC1RST_Msk             (1ul << SYS_ALT_MFP1_PA5_SC1RST_Pos)        /*!< GCR ALT_MFP1: PA5_SC1RST Mask */
N
N#define SYS_ALT_MFP1_PA4_SC1PWR_Pos             7                                           /*!< GCR ALT_MFP1: PA4_SC1PWR Position */
N#define SYS_ALT_MFP1_PA4_SC1PWR_Msk             (1ul << SYS_ALT_MFP1_PA4_SC1PWR_Pos)        /*!< GCR ALT_MFP1: PA4_SC1PWR Mask */
N
N#define SYS_ALT_MFP1_PA7_SC1DAT_Pos             6                                           /*!< GCR ALT_MFP1: PA7_SC1DAT Position */
N#define SYS_ALT_MFP1_PA7_SC1DAT_Msk             (1ul << SYS_ALT_MFP1_PA7_SC1DAT_Pos)        /*!< GCR ALT_MFP1: PA7_SC1DAT Mask */
N
N#define SYS_ALT_MFP1_PA6_SC1CLK_Pos             5                                           /*!< GCR ALT_MFP1: PA6_SC1CLK Position */
N#define SYS_ALT_MFP1_PA6_SC1CLK_Msk             (1ul << SYS_ALT_MFP1_PA6_SC1CLK_Pos)        /*!< GCR ALT_MFP1: PA6_SC1CLK Mask */
N
N#define SYS_ALT_MFP1_PC6_SC0CD_Pos              4                                           /*!< GCR ALT_MFP1: PC6_SC0CD Position */
N#define SYS_ALT_MFP1_PC6_SC0CD_Msk              (1ul << SYS_ALT_MFP1_PC6_SC0CD_Pos)         /*!< GCR ALT_MFP1: PC6_SC0CD Mask */
N
N#define SYS_ALT_MFP1_PA1_SC0RST_Pos             3                                           /*!< GCR ALT_MFP1: PA1_SC0RST Position */
N#define SYS_ALT_MFP1_PA1_SC0RST_Msk             (1ul << SYS_ALT_MFP1_PA1_SC0RST_Pos)        /*!< GCR ALT_MFP1: PA1_SC0RST Mask */
N
N#define SYS_ALT_MFP1_PA0_SC0PWR_Pos             2                                           /*!< GCR ALT_MFP1: PA0_SC0PWR Position */
N#define SYS_ALT_MFP1_PA0_SC0PWR_Msk             (1ul << SYS_ALT_MFP1_PA0_SC0PWR_Pos)        /*!< GCR ALT_MFP1: PA0_SC0PWR Mask */
N
N#define SYS_ALT_MFP1_PA3_SC0DAT_Pos             1                                           /*!< GCR ALT_MFP1: PA3_SC0DAT Position */
N#define SYS_ALT_MFP1_PA3_SC0DAT_Msk             (1ul << SYS_ALT_MFP1_PA3_SC0DAT_Pos)        /*!< GCR ALT_MFP1: PA3_SC0DAT Mask */
N
N#define SYS_ALT_MFP1_PA2_SC0CLK_Pos             0                                           /*!< GCR ALT_MFP1: PA2_SC0CLK Position */
N#define SYS_ALT_MFP1_PA2_SC0CLK_Msk             (1ul << SYS_ALT_MFP1_PA2_SC0CLK_Pos)        /*!< GCR ALT_MFP1: PA2_SC0CLK Mask */
N
N/* GCR IRCTRIMCTL Bit Field Definitions */
N#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos       8                                           /*!< GCR IRCTRIMCTL: CLKERR_STOP_EN Position */
N#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Msk       (1ul << SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos)  /*!< GCR IRCTRIMCTL: CLKERR_STOP_EN Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos       6                                           /*!< GCR IRCTRIMCTL: TRIM_RETRY_CNT Position */
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Msk       (3ul << SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos)  /*!< GCR IRCTRIMCTL: TRIM_RETRY_CNT Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos            4                                           /*!< GCR IRCTRIMCTL: TRIM_LOOP Position */
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk            (3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos)       /*!< GCR IRCTRIMCTL: TRIM_LOOP Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_SEL_Pos             0                                           /*!< GCR IRCTRIMCTL: TRIM_SEL Position */
N#define SYS_IRCTRIMCTL_TRIM_SEL_Msk             (3ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)        /*!< GCR IRCTRIMCTL: TRIM_SEL Mask */
N
N/* GCR IRCTRIMIEN Bit Field Definitions */
N#define SYS_IRCTRIMIEN_CLKERR_IEN_Pos           2                                           /*!< GCR IRCTRIMIEN: CLKERR_IEN Position */
N#define SYS_IRCTRIMIEN_CLKERR_IEN_Msk           (1ul << SYS_IRCTRIMIEN_CLKERR_IEN_Pos)      /*!< GCR IRCTRIMIEN: CLKERR_IEN Mask */
N
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos        1                                           /*!< GCR IRCTRIMIEN: TRIM_FAIL_IEN Position */
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk        (1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)   /*!< GCR IRCTRIMIEN: TRIM_FAIL_IEN Mask */
N
N/* GCR IRCTRIMINT Bit Field Definitions */
N#define SYS_IRCTRIMINT_CLKERR_INT_Pos           2                                           /*!< GCR IRCTRIMINT: CLKERR_INT Position */
N#define SYS_IRCTRIMINT_CLKERR_INT_Msk           (1ul << SYS_IRCTRIMINT_CLKERR_INT_Pos)      /*!< GCR IRCTRIMINT: CLKERR_INT Mask */
N
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos        1                                           /*!< GCR IRCTRIMINT: TRIM_FAIL_INT Position */
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk        (1ul << SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos)   /*!< GCR IRCTRIMINT: TRIM_FAIL_INT Mask */
N
N#define SYS_IRCTRIMINT_FREQ_LOCK_Pos            0                                           /*!< GCR IRCTRIMINT: FREQ_LOCK Position */
N#define SYS_IRCTRIMINT_FREQ_LOCK_Msk            (1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)       /*!< GCR IRCTRIMINT: FREQ_LOCK Mask */
N
N/* GCR REGWRPROT Bit Field Definitions */
N#define SYS_REGWRPROT_REGWRPROT_Pos             0                                           /*!< GCR REGWRPROT: REGWRPROT Position */
N#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos)     /*!< GCR REGWRPROT: REGWRPROT Mask */
N
N
Ntypedef struct
N{
N    __I uint32_t IRQSRC[32];
X    volatile const uint32_t IRQSRC[32];
N    __IO uint32_t NMISEL;
X    volatile uint32_t NMISEL;
N    __IO uint32_t MCUIRQ;
X    volatile uint32_t MCUIRQ;
N} GCR_INT_T;
N
N/* INT IRQSRC Bit Field Definitions */
N#define INT_IRQSRC_INT_SRC_Pos                  0                                   /*!< INT IRQSRC: INT_SRC Position */ 
N#define INT_IRQSRC_INT_SRC_Msk                  (0xFul << INT_IRQSRC_INT_SRC_Pos)
N
N/* INT NMI_SEL Bit Field Definitions */
N#define INT_NMI_SEL_NMI_EN_Pos                  8                                   /*!< INT NMI_SEL: NMI_EN Position */      
N#define INT_NMI_SEL_NMI_EN_Msk                  (1ul << INT_NMI_SEL_NMI_EN_Pos)     /*!< INT NMI_SEL: NMI_EN Mask */
N
N#define INT_NMI_SEL_NMI_SEL_Pos                 0                                   /*!< INT NMI_SEL: NMI_SEL Position */
N#define INT_NMI_SEL_NMI_SEL_Msk                 (0x1Ful << INT_NMI_SEL_NMI_SEL_Pos) /*!< INT NMI_SEL: NMI_SEL Mask */
N/*@}*/ /* end of group NUC200_SYS */
N
N/*-------------------------- FLASH Memory Controller -------------------------*/
N/** @addtogroup NUC200_FMC NUC200 FMC
N  Memory Mapped Structure for NUC200 Series Flash Memory Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * ISPCON
N     * ===================================================================================================
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable
N     * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
N     * |        |          |1 = Enable ISP function
N     * |        |          |0 = Disable ISP function
N     * |[1]     |BS        |Boot Select 
N     * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM, 
N     * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where 
N     * |        |          |MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-
N     * |        |          |on reset; It keeps the same value at other reset.
N     * |        |          |1 = boot from LDROM
N     * |        |          |0 = boot from APROM
N     * |[4]     |CFGUEN    |Config Update Enable
N     * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program 
N     * |        |          |code is running in APROM or LDROM.
N     * |        |          |1 = Config update enable 
N     * |        |          |0 = Config update disable
N     * |[5]     |LDUEN     |LDROM Update Enable
N     * |        |          |LDROM update enable bit. 
N     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N     * |        |          |0 = LDROM cannot be updated
N     * |[6]     |ISPFF     |ISP Fail Flag
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself.
N     * |        |          |(2) LDROM writes to itself. 
N     * |        |          |(3) Destination address is illegal, such as over an available range.
N     * |        |          |Write 1 to clear.
N     * |[7]     |SWRST     |Software Reset
N     * |        |          |Writing 1 to this bit to start software reset. 
N     * |        |          |It is cleared by hardware after reset is finished.
N     * |[10:8]  |PT        |Flash Program Time
N     * |        |          |000 = 40 us
N     * |        |          |001 = 45 us
N     * |        |          |010 = 50 us
N     * |        |          |011 = 55 us
N     * |        |          |100 = 20 us
N     * |        |          |101 = 25 us
N     * |        |          |110 = 30 us
N     * |        |          |111 = 35 us
N     * |[14:12] |ET        |Flash Erase Time
N     * |        |          |000 = 20 ms (default)
N     * |        |          |001 = 25 ms 
N     * |        |          |010 = 30 ms 
N     * |        |          |011 = 35 ms 
N     * |        |          |100 = 3  ms 
N     * |        |          |101 = 5  ms 
N     * |        |          |110 = 10 ms 
N     * |        |          |111 = 15 ms 
N     */    
N    __IO uint32_t ISPCON;
X    volatile uint32_t ISPCON;
N
N    /**
N     * ISPADR
N     * ===================================================================================================
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADR    |ISP Address 
N     * |        |          |NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program 
N     * |        |          |only. ISPARD[1:0] must be kept 2'b00 for ISP operation. 
N     */    
N    __IO uint32_t ISPADR;
X    volatile uint32_t ISPADR;
N
N    /**
N     * ISPDAT
N     * ===================================================================================================
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data 
N     * |        |          |Write data to this register before ISP program operation
N     * |        |          |Read data from this register after ISP read operation
N     */    
N    __IO uint32_t ISPDAT;
X    volatile uint32_t ISPDAT;
N
N    /**
N     * ISPCMD
N     * ===================================================================================================
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command 
N     * |        |          |ISP command table is shown below:
N     * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
N     * |        |          |Read          ,    0,    0, 0000
N     * |        |          |Program       ,    1,    0, 0001
N     * |        |          |Page Erase    ,    1,    0, 0010
N     */    
N    __IO uint32_t ISPCMD;
X    volatile uint32_t ISPCMD;
N
N    /**
N     * ISPTRG
N     * ===================================================================================================
N     * Offset: 0x10  IISP Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP start trigger
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP 
N     * |        |          |operation is finish. 
N     * |        |          |1 = ISP is on going 
N     * |        |          |0 = ISP done
N     */    
N    __IO uint32_t ISPTRG;
X    volatile uint32_t ISPTRG;
N
N    /**
N     * DFBADR
N     * ===================================================================================================
N     * Offset: 0x14  Data Flash Base Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates data flash start address. 
N     * |        |          | 
N     * |        |          |It is a read only register. 
N     * |        |          | 
N     * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at 
N     * |        |          |0x01F000 by hardware internally.
N     */    
N    __I  uint32_t DFBADR;
X    volatile const  uint32_t DFBADR;
N
N    /**
N     * FATCON
N     * ===================================================================================================
N     * Offset: 0x18  Flash Access Time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FPSEN     |Flash Power Save Enable
N     * |        |          |If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
N     * |        |          |1 = Enable flash power saving
N     * |        |          |0 = Disable flash power saving
N     * |[3:1]   |FATS      |Flash Access Time Window Select
N     * |        |          |These bits are used to decide flash sense amplifier active duration.
N     * |        |          |000 = 40 ns
N     * |        |          |001 = 50 ns
N     * |        |          |010 = 60 ns
N     * |        |          |011 = 70 ns
N     * |        |          |100 = 80 ns
N     * |        |          |101 = 90 ns
N     * |        |          |110 = 100 ns
N     * |        |          |111 = Reserved
N     * |[4]     |L_SPEED   |Flash Low Speed Mode Enable
N     * |        |          |1 = Flash access always no wait state (zero wait state)
N     * |        |          |0 = Insert wait state while Flash access discontinued address. 
N     * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong 
N     * |        |          |code and cause fail result.
N     */    
N    __IO uint32_t FATCON;
X    volatile uint32_t FATCON;
N    
N    __I  uint32_t  RESERVED[9];
X    volatile const  uint32_t  RESERVED[9];
N
N    __IO uint32_t ISPSTA;
X    volatile uint32_t ISPSTA;
N
N} FMC_T;
N
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ET_Pos                       12                                      /*!< FMC ISPCON: ET Position */
N#define FMC_ISPCON_ET_Msk                       (7ul << FMC_ISPCON_ET_Pos)              /*!< FMC ISPCON: ET Mask     */
N
N#define FMC_ISPCON_PT_Pos                       8                                       /*!< FMC ISPCON: PT Position */
N#define FMC_ISPCON_PT_Msk                       (7ul << FMC_ISPCON_PT_Pos)              /*!< FMC ISPCON: PT Mask     */
N
N#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC ISPCON: ISPFF Position */
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC ISPCON: ISPFF Mask */
N
N#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC ISPCON: LDUEN Position */
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC ISPCON: LDUEN Mask */
N
N#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC ISPCON: CFGUEN Position */
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC ISPCON: CFGUEN Mask */
N
N#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC ISPCON: APUEN Position */
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC ISPCON: APUEN Mask */
N
N#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC ISPCON: BS Position */
N#define FMC_ISPCON_BS_Msk                       (0x1ul << FMC_ISPCON_BS_Pos)            /*!< FMC ISPCON: BS Mask */
N                                                                                        
N#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC ISPCON: ISPEN Position */
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC ISPCON: ISPEN Mask */
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPADR_ISPADR_Pos                   0                                       /*!< FMC ISPADR: ISPADR Position */
N#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos) /*!< FMC ISPADR: ISPADR Mask     */
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPDAT_ISPDAT_Pos                   0                                       /*!< FMC ISPDAT: ISPDAT Position */
N#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos) /*!< FMC ISPDAT: ISPDAT Mask     */
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC ISPCMD: FOEN Position */
N#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC ISPCMD: FOEN Mask */
N
N#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC ISPCMD: FCEN Position */
N#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC ISPCMD: FCEN Mask */
N
N#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC ISPCMD: FCTRL Position */
N#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC ISPCMD: FCTRL Mask */
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC ISPTRG: ISPGO Position */
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC ISPTRG: ISPGO Mask */
N
N/* FMC DFBADR Bit Field Definitions */
N#define FMC_DFBADR_DFBA_Pos                     0                                       /*!< FMC DFBADR: DFBA Position */
N#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)   /*!< FMC DFBADR: DFBA Mask     */
N
N/* FMC FATCON Bit Field Definitions */
N#define FMC_FATCON_MFOM_Pos                     6                                       /*!< FMC FATCON: MFOM Position */
N#define FMC_FATCON_MFOM_Msk                     (1ul << FMC_FATCON_MFOM_Pos)            /*!< FMC FATCON: MFOM Mask */
N
N#define FMC_FATCON_LFOM_Pos                     4                                       /*!< FMC FATCON: LFOM Position */
N#define FMC_FATCON_LFOM_Msk                     (1ul << FMC_FATCON_LFOM_Pos)            /*!< FMC FATCON: LFOM Mask */
N
N#define FMC_FATCON_FATS_Pos                     1                                       /*!< FMC FATCON: FATS Position */
N#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)            /*!< FMC FATCON: FATS Mask */
N
N#define FMC_FATCON_FPSEN_Pos                    0                                       /*!< FMC FATCON: FPSEN Position */
N#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)           /*!< FMC FATCON: FPSEN Mask */
N
N
N#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC ISPSTA: ISPGO Position */
N#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC ISPSTA: ISPGO Mask */
N
N#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC ISPSTA: CBS Position */
N#define FMC_ISPSTA_CBS_Msk                      (0x3ul << FMC_ISPSTA_CBS_Pos)           /*!< FMC ISPSTA: CBS Mask */
N
N#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC ISPSTA: ISPFF Position */
N#define FMC_ISPSTA_ISPFF_Msk                    (0x3ul << FMC_ISPSTA_ISPFF_Pos)         /*!< FMC ISPSTA: ISPFF Mask */
N
N#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC ISPSTA: VECMAP Position */
N#define FMC_ISPSTA_VECMAP_Msk                   (0xFFFul << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC ISPSTA: VECMAP Mask */
N
N
N/*@}*/ /* end of group NUC200_FMC */
N
N
N/*------------------------------ PS2 Controller ------------------------------*/
N/** @addtogroup NUC200_PS2 NUC200 PS2
N  Memory Mapped Structure for NUC200 Series PS2 Serial Interface Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * PS2CON
N     * ===================================================================================================
N     * Offset: 0x00  PS2 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field        |Descriptions
N     * | :----: | :----:      | :---- |
N     * |[0]     |PS2EN        |Enable PS2 Device
N		 * |        |             |Enable PS2 device controller.
N     * |        |             |1 = Enable
N     * |        |             |0 = Disable
N     * |[1]     |TXINTEN      |Enable Transmit Interrupt
N     * |        |             |1 = Enable data transmit complete interrupt.
N     * |        |             |0 = Disable data transmit complete interrupt.
N     * |[2]     |RXINTEN      |Enable Receive Interrupt
N     * |        |             |1 = Enable data receive complete interrupt.
N     * |        |             |0 = Disable data receive complete interrupt.
N     * |[6:3]   |TXFIFO_DEPTH |Transmit data FIFO Depth
N     * |        |             |There is 16 bytes buffer for data trnsmit. S/W can define the FIFO depth from 1 to 16 bytes depends
N     * |        |             |on appliction.  
N     * |        |             | 0 =  1 byte
N     * |        |             | 1 =  2 bytes             
N     * |        |             |...
N     * |        |             |14 = 15 btyes
N     * |        |             |15 = 16 bytes             
N     * |[7]     |ACK          |Acknowledge Enable
N     * |        |             |1 = if parity error or stop bit is not received correctly, acknowledge bit will not be sent to host
N     * |        |             |    at 12th clock.
N     * |        |             |0 = Always send acknowledge to host at 12th clock for host to device communication
N     * |[8]     |CLRFIFO      |Clear TX FIFO
N     * |        |             |Write 1 to this bit to terminate device to host transmission. The TXEMPTY bit in PS2STATUS bit will
N     * |        |             |be set to 1 and pointer BYTEINDEX is reset to 0 regardless there is residue data in buffer or not. 
N     * |        |             |The buffer content is not been cleared.
N     * |        |             |1 = Clear FIFO.
N     * |        |             |0 = Not active.
N     * |[9]     |OVERRIDE     |Software Override PS2 CLK/DATA Pin State
N     * |        |             |1 = PS2CLK and PS2DATA pins are controlled by S/W.
N     * |        |             |0 = PS2CLK and PS2DATA pins are controlled by internal state machine.
N     * |[10]    |FPS2CLK      |Force PS2CLK Line
N     * |        |             |It forces PS2CLK line high or low regardless of the internal state of the device controller if
N     * |        |             |OVERRIDE is set to high.
N     * |        |             |1 = Force PS2CLK line high.
N     * |        |             |0 = Force PS2CLK line low.
N     * |[11]    |FPS2DAT      |Force PS2DATA Line 
N     * |        |             |It forces PS2DATA high or low regardless of the internal state of the device controller if OVERRIDE
N     * |        |             |is set to high.
N     * |        |             |1 = Force PS2DATA high.
N     * |        |             |0 = Force PS2DATA low.                                                                         
N     */  	
N		__IO uint32_t PS2CON;
X		volatile uint32_t PS2CON;
N		
N    /**
N     * PS2TXDATA0
N     * ===================================================================================================
N     * Offset: 0x04  PS2 TX DATA Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PS2TXDATAx|Transmit data
N     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
N     * |        |          |enable PS2EN before writing data to TX buffer.
N     */ 						
N		__IO uint32_t PS2TXDATA0;
X		volatile uint32_t PS2TXDATA0;
N		
N    /**
N     * PS2TXDATA1
N     * ===================================================================================================
N     * Offset: 0x08  PS2 TX DATA Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PS2TXDATAx|Transmit data
N     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
N     * |        |          |enable PS2EN before writing data to TX buffer.
N     */ 		
N		__IO uint32_t PS2TXDATA1;
X		volatile uint32_t PS2TXDATA1;
N		
N    /**
N     * PS2TXDATA2
N     * ===================================================================================================
N     * Offset: 0x0C  PS2 TX DATA Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PS2TXDATAx|Transmit data
N     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
N     * |        |          |enable PS2EN before writing data to TX buffer.
N     */ 			
N		__IO uint32_t PS2TXDATA2;
X		volatile uint32_t PS2TXDATA2;
N		
N    /**
N     * PS2TXDATA3
N     * ===================================================================================================
N     * Offset: 0x10  PS2 TX DATA Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PS2TXDATAx|Transmit data
N     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
N     * |        |          |enable PS2EN before writing data to TX buffer.
N     */ 		
N		__IO uint32_t PS2TXDATA3;
X		volatile uint32_t PS2TXDATA3;
N		
N    /**
N     * PS2RXDATA
N     * ===================================================================================================
N     * Offset: 0x14  PS2 Receive Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |GC        |Received Data
N     * |        |          |For host to device communication, after acknowledge bit is sent, the received data is copied from
N     * |        |          |receive shift register to PS2RXDATA register. CPU must read this register before next byte 
N     * |        |          |reception complete, otherwise the data will be overwritten and RXOVF bit in PS2STATUS[6] will be
N     * |        |          |set to 1.
N     */  		
N		__IO uint32_t PS2RXDATA;
X		volatile uint32_t PS2RXDATA;
N		
N     /**
N     * PS2STATUS
N     * ===================================================================================================
N     * Offset: 0x18  PS2 Status Register 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PS2CLK    |CLK Pin State
N     * |        |          |This bit reflects the status of the PS2CLK line after synchronizing.
N     * |[1]     |PS2DATA   |DATA Pin State
N     * |        |          |This bit reflects the status of the PS2DATA line after synchronizing and sampling.
N     * |[2]     |FRAMERR   |FrameError
N     * |        |          |For host to device communication, if STOP bit (logic 1) is not received it is a frame error. If
N     * |        |          |frame error occurs, DATA line may keep at low state after 12th clock. At this moment, S/W 
N     * |        |          |overrides PS2CLK to send clock till PS2DATA release to high state. After that, device sends a 
N     * |        |          |"Resend" command to host.
N     * |        |          |1 = Frame error occur.
N     * |        |          |0 = No Frame error.
N     * |        |          |Write 1 to clear this bit.
N     * |[3]     |RXPARITY  |Received Parity
N     * |        |          |This bit reflects the parity bit for the last received data byte (odd parity).
N     * |        |          |Read only bit.
N     * |[4]     |RXBUSY    |Receive Busy
N     * |        |          |This bit indicates that the PS2 device is currently receiving data.
N     * |        |          |1 = Currently receiving data.
N     * |        |          |0 = Idle.
N     * |        |          |Read only bit.
N     * |[5]     |TXBUSY    |Transmit Busy
N     * |        |          |This bit indicates that the PS2 device is currently sending data.
N     * |        |          |1 = Currently sending data.
N     * |        |          |0 = Idle.
N     * |        |          |Read only bit.
N     * |[6]     |RXOVF     |RX Buffer Overwrite
N     * |        |          |1 = Data in PS2RXDATA register is overwritten by new received data. 
N     * |        |          |0 = No overwrite.
N     * |        |          |Write 1 to clear this bit.                                                                      
N     * |[7]     |TXEMPTY   |TX FIFO Empty
N     * |        |          |When S/W writes any data to PS2TXDATA0~3 the TXEMPTY bit is cleared to 0 immediately if PS2EN is 
N     * |        |          |enabled. When transmitted data byte number is equal to FIFODEPTH then TXEMPTY bit is set to 1.
N     * |        |          |1 = FIFO is empty.
N     * |        |          |0 = There is data to be transmitted.                         
N     * |[11:8]  |BYTEIDX   |Byte Index
N     * |        |          |It indicates which data byte in transmit data shift register. When all data in FIFO is 
N     * |        |          |transmitted and it will be cleared to 0.
N     * |        |          |It is a read only bit.
N     * |        |          |
N     * |        |          |BYTEIDX, DATA Transmit , BYTEIDX, DATA Transmit
N     * |        |          |0000   , TXDATA0[ 7: 0], 1000   , TXDATA2[ 7: 0],
N     * |        |          |0001   , TXDATA0[15: 8], 1001   , TXDATA2[15: 8],
N     * |        |          |0010   , TXDATA0[23:16], 1010   , TXDATA2[23:16],
N     * |        |          |0011   , TXDATA0[31:24], 1011   , TXDATA2[31:24],
N     * |        |          |0100   , TXDATA1[ 7: 0], 1100   , TXDATA3[ 7: 0],
N     * |        |          |0101   , TXDATA1[15: 8], 1101   , TXDATA3[15: 8],
N     * |        |          |0110   , TXDATA1[23:16], 1110   , TXDATA3[23:16],                           
N     * |        |          |0111   , TXDATA1[31:24], 1111   , TXDATA3[31:24],                   
N     */   		
N		__IO uint32_t PS2STATUS;
X		volatile uint32_t PS2STATUS;
N		
N     /**
N     * PS2INTID
N     * ===================================================================================================
N     * Offset: 0x1C  PS2 Interrupt Identification Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXINT     |Receive Interrupt
N	 * |        |          |This bit is set to 1 when acknowledge bit is sent for Host to device communication. Interrupt      
N	 * |        |          |occurs if RXINTEN bit is set to 1.
N     * |        |          |1 = Receive interrupt occurs.
N     * |        |          |0 = No interrupt.
N     * |        |          |Write 1 to clear this bit to 0.     
N     * |[1]     |TXINT     |Transmit Interrupt 
N     * |        |          |This bit is set to 1 after STOP bit is transmitted. Interrupt occur if TXINTEN bit is set to 1.
N     * |        |          |1 = Transmit interrupt occurs.
N     * |        |          |0 = No interrupt.
N     * |        |          |Write 1 to clear this bit to 0.        
N     */   		
N		__IO uint32_t PS2INTID;
X		volatile uint32_t PS2INTID;
N}PS2_T;
N
N
N/* PS2 PS2CON Bit Field Definitions */
N#define PS2_PS2CON_PS2EN_Pos                       0										/*!< PS2 PS2CON: PS2EN Position */
N#define PS2_PS2CON_PS2EN_Msk                       (1ul << PS2_PS2CON_PS2EN_Pos)  			/*!< PS2 PS2CON: PS2EN Mask */
N
N#define PS2_PS2CON_TXINTEN_Pos                     1										/*!< PS2 PS2CON: TXINTEN Position */
N#define PS2_PS2CON_TXINTEN_Msk                     (1ul << PS2_PS2CON_TXINTEN_Pos)		    /*!< PS2 PS2CON: TXINTEN Mask */ 
N
N#define PS2_PS2CON_RXINTEN_Pos                     2										/*!< PS2 PS2CON: RXINTEN Position */
N#define PS2_PS2CON_RXINTEN_Msk                     (1ul << PS2_PS2CON_RXINTEN_Pos)  	    /*!< PS2 PS2CON: RXINTEN Mask */
N
N#define PS2_PS2CON_TXFIFO_DEPTH_Pos                3									    /*!< PS2 PS2CON: TXFIFO_DEPTH Position */
N#define PS2_PS2CON_TXFIFO_DEPTH_Msk                (0xFul << PS2_PS2CON_TXFIFO_DEPTH_Pos)	/*!< PS2 PS2CON: TXFIFO_DEPTH Mask */
N
N#define PS2_PS2CON_ACK_Pos                         7									    /*!< PS2 PS2CON: ACK Position */
N#define PS2_PS2CON_ACK_Msk                         (1ul << PS2_PS2CON_ACK_Pos)				/*!< PS2 PS2CON: ACK Mask */ 
N
N#define PS2_PS2CON_CLRFIFO_Pos                     8										/*!< PS2 PS2CON: CLRFIFO Position */
N#define PS2_PS2CON_CLRFIFO_Msk                     (1ul << PS2_PS2CON_CLRFIFO_Pos)  		/*!< PS2 PS2CON: CLRFIFO Mask */
N
N#define PS2_PS2CON_OVERRIDE_Pos                    9										/*!< PS2 PS2CON: OVERRIDE Position */
N#define PS2_PS2CON_OVERRIDE_Msk                    (1ul << PS2_PS2CON_OVERRIDE_Pos)  		/*!< PS2 PS2CON: OVERRIDE Mask */
N
N#define PS2_PS2CON_FPS2CLK_Pos                     10										/*!< PS2 PS2CON: FPS2CLK Position */
N#define PS2_PS2CON_FPS2CLK_Msk                     (1ul << PS2_PS2CON_FPS2CLK_Pos) 			/*!< PS2 PS2CON: FPS2CLK Mask */
N
N#define PS2_PS2CON_FPS2DAT_Pos                     11									    /*!< PS2 PS2CON: FPS2DAT Position */
N#define PS2_PS2CON_FPS2DAT_Msk                     (1ul << PS2_PS2CON_FPS2DAT_Pos) 			/*!< PS2 PS2CON: FPS2DAT Mask */
N
N/* PS/2 PS2RXDATA Bit Field Definitions */
N#define PS2_PS2RXDATA_RXDATA_Pos                   0										/*!< PS2 PS2RXDATA: RXDATA Position */
N#define PS2_PS2RXDATA_RXDATA_Msk                   (0xFFul << PS2_PS2RXDATA_RXDATA_Pos)		/*!< PS2 PS2RXDATA: RXDATA Mask */
N
N/* PS/2 PS2STATUS Bit Field Definitions */
N#define PS2_PS2STATUS_PS2CLK_Pos                   0									    /*!< PS2 PS2STATUS: PS2CLK Position */
N#define PS2_PS2STATUS_PS2CLK_Msk                   (1ul << PS2_PS2STATUS_PS2CLK_Pos) 		/*!< PS2 PS2STATUS: PS2CLK Mask */
N
N#define PS2_PS2STATUS_PS2DATA_Pos                  1										/*!< PS2 PS2STATUS: PS2DATA Position */
N#define PS2_PS2STATUS_PS2DATA_Msk                  (1ul << PS2_PS2STATUS_PS2DATA_Pos) 		/*!< PS2 PS2STATUS: PS2DATA Mask */
N
N#define PS2_PS2STATUS_FRAMERR_Pos                  2										/*!< PS2 PS2STATUS: FRAMERR Position */
N#define PS2_PS2STATUS_FRAMERR_Msk                  (1ul << PS2_PS2STATUS_FRAMERR_Pos)		/*!< PS2 PS2STATUS: FRAMERR Mask */ 
N
N#define PS2_PS2STATUS_RXPARITY_Pos                 3										/*!< PS2 PS2STATUS: RXPARITY Position */
N#define PS2_PS2STATUS_RXPARITY_Msk                 (1ul << PS2_PS2STATUS_RXPARITY_Pos) 		/*!< PS2 PS2STATUS: RXPARITY Mask */
N
N#define PS2_PS2STATUS_RXBUSY_Pos                   4										/*!< PS2 PS2STATUS: RXBUSY Position */
N#define PS2_PS2STATUS_RXBUSY_Msk                   (1ul << PS2_PS2STATUS_RXBUSY_Pos)		/*!< PS2 PS2STATUS: RXBUSY Mask */
N
N#define PS2_PS2STATUS_TXBUSY_Pos                   5										/*!< PS2 PS2STATUS: TXBUSY Position */
N#define PS2_PS2STATUS_TXBUSY_Msk                   (1ul << PS2_PS2STATUS_TXBUSY_Pos)		/*!< PS2 PS2STATUS: TXBUSY Mask */
N
N#define PS2_PS2STATUS_RXOVF_Pos                    6										/*!< PS2 PS2STATUS: RXOVF Position */
N#define PS2_PS2STATUS_RXOVF_Msk                    (1ul << PS2_PS2STATUS_RXOVF_Pos)			/*!< PS2 PS2STATUS: RXOVF Mask */
N
N#define PS2_PS2STATUS_TXEMPTY_Pos                  7										/*!< PS2 PS2STATUS: TXEMPTY Position */
N#define PS2_PS2STATUS_TXEMPTY_Msk                  (1ul << PS2_PS2STATUS_TXEMPTY_Pos)		/*!< PS2 PS2STATUS: TXEMPTY Mask */
N
N#define PS2_PS2STATUS_BYTEIDX_Pos                  8										/*!< PS2 PS2STATUS: BYTEIDX Position */
N#define PS2_PS2STATUS_BYTEIDX_Msk                  (0xFul << PS2_PS2STATUS_BYTEIDX_Pos)		/*!< PS2 PS2STATUS: BYTEIDX Mask */
N
N/* PS/2 PS2INTID Bit Field Definitions */
N#define PS2_PS2INTID_RXINT_Pos                     0										/*!< PS2 PS2INTID : RXINT Position */
N#define PS2_PS2INTID_RXINT_Msk                     (1ul << PS2_PS2INTID_RXINT_Pos) 			/*!< PS2 PS2INTID : RXINT Mask */
N                     
N#define PS2_PS2INTID_TXINT_Pos                     1										/*!< PS2 PS2INTID : TXINT Position */
N#define PS2_PS2INTID_TXINT_Msk                     (1ul << PS2_PS2INTID_TXINT_Pos) 			/*!< PS2 PS2INTID : TXINT Mask */
N/*@}*/ /* end of group NUC200_PS2 */
N
N/*----------------------------- CAN Controller ------------------------------*/
N/** @addtogroup NUC200_CAN NUC200 CAN
N  Register Structure for NUC200 Series CAN Device Controller 
N  @{
N */
N
Ntypedef struct
N{
N    __IO uint32_t CREQ;
X    volatile uint32_t CREQ;
N    __IO uint32_t CMASK;
X    volatile uint32_t CMASK;
N    __IO uint32_t MASK1;
X    volatile uint32_t MASK1;
N    __IO uint32_t MASK2;
X    volatile uint32_t MASK2;
N    __IO uint32_t ARB1;
X    volatile uint32_t ARB1;
N    __IO uint32_t ARB2;	
X    volatile uint32_t ARB2;	
N    __IO uint32_t MCON;			
X    volatile uint32_t MCON;			
N    __IO uint32_t DAT_A1;			
X    volatile uint32_t DAT_A1;			
N    __IO uint32_t DAT_A2;		
X    volatile uint32_t DAT_A2;		
N    __IO uint32_t DAT_B1;
X    volatile uint32_t DAT_B1;
N    __IO uint32_t DAT_B2;		
X    volatile uint32_t DAT_B2;		
N    __I uint32_t RESERVE0[13];        
X    volatile const uint32_t RESERVE0[13];        
N                                    
N} CAN_IF_T;
N
Ntypedef struct
N{
N    __IO uint32_t   CON;		 	
X    volatile uint32_t   CON;		 	
N    __IO uint32_t   STATUS;	
X    volatile uint32_t   STATUS;	
N    __IO uint32_t   ERR;     		
X    volatile uint32_t   ERR;     		
N    __IO uint32_t   BTIME;
X    volatile uint32_t   BTIME;
N    __IO uint32_t   IIDR;
X    volatile uint32_t   IIDR;
N    __IO uint32_t   TEST;
X    volatile uint32_t   TEST;
N    __IO uint32_t   BRPE;
X    volatile uint32_t   BRPE;
N    __I uint32_t   	RESERVE0[1];     
X    volatile const uint32_t   	RESERVE0[1];     
N    CAN_IF_T        IF[2];             
N 	__I uint32_t   	RESERVE1[8];
X 	volatile const uint32_t   	RESERVE1[8];
N    __IO uint32_t   TXREQ1;
X    volatile uint32_t   TXREQ1;
N    __IO uint32_t   TXREQ2;
X    volatile uint32_t   TXREQ2;
N    __I uint32_t   	RESERVE2[6];        
X    volatile const uint32_t   	RESERVE2[6];        
N    __IO uint32_t   NDAT1;
X    volatile uint32_t   NDAT1;
N    __IO uint32_t   NDAT2;
X    volatile uint32_t   NDAT2;
N    __I uint32_t   	RESERVE3[6];
X    volatile const uint32_t   	RESERVE3[6];
N    __IO uint32_t   IPND1;
X    volatile uint32_t   IPND1;
N    __IO uint32_t   IPND2;
X    volatile uint32_t   IPND2;
N    __I uint32_t   	RESERVE4[6];
X    volatile const uint32_t   	RESERVE4[6];
N    __IO uint32_t   MVLD1;
X    volatile uint32_t   MVLD1;
N    __IO uint32_t   MVLD2;
X    volatile uint32_t   MVLD2;
N    __IO uint32_t   WU_EN;            
X    volatile uint32_t   WU_EN;            
N    __IO uint32_t   WU_STATUS;
X    volatile uint32_t   WU_STATUS;
N} CAN_T;
N
N
N/* CAN CON Bit Field Definitions */
N#define CAN_CON_TEST_Pos           7                                    /*!< CAN CON: TEST Position */  
N#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)            /*!< CAN CON: TEST Mask     */  
N
N#define CAN_CON_CCE_Pos            6                                    /*!< CAN CON: CCE Position  */  
N#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)             /*!< CAN CON: CCE Mask      */  
N
N#define CAN_CON_DAR_Pos            5                                    /*!< CAN CON: DAR Position  */  
N#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)             /*!< CAN CON: DAR Mask      */  
N
N#define CAN_CON_EIE_Pos            3                                    /*!< CAN CON: EIE Position  */  
N#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)             /*!< CAN CON: EIE Mask      */  
N
N#define CAN_CON_SIE_Pos            2                                    /*!< CAN CON: SIE Position  */  
N#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)             /*!< CAN CON: SIE Mask      */  
N
N#define CAN_CON_IE_Pos             1                                    /*!< CAN CON: IE Position   */  
N#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)              /*!< CAN CON: IE Mask       */  
N
N#define CAN_CON_INIT_Pos           0                                    /*!< CAN CON: INIT Position */  
N#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)            /*!< CAN CON: INIT Mask     */  
N
N/* CAN STATUS Bit Field Definitions */
N#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN STATUS: BOFF Position  */
N#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)         /*!< CAN STATUS: BOFF Mask      */
N
N#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN STATUS: EWARN Position */
N#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)        /*!< CAN STATUS: EWARN Mask     */
N
N#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN STATUS: EPASS Position */
N#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)        /*!< CAN STATUS: EPASS Mask     */
N
N#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN STATUS: RXOK Position  */
N#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN STATUS: RXOK Mask      */
N
N#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN STATUS: TXOK Position  */
N#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN STATUS: TXOK Mask      */
N
N#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN STATUS: LEC Position   */
N#define CAN_STATUS_LEC_Msk         (0x3ul << CAN_STATUS_LEC_Pos)        /*!< CAN STATUS: LEC Mask       */
N
N/* CAN ERR Bit Field Definitions */
N#define CAN_ERR_RP_Pos             15                                   /*!< CAN ERR: RP Position       */
N#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)              /*!< CAN ERR: RP Mask           */
N
N#define CAN_ERR_REC_Pos            8                                    /*!< CAN ERR: REC Position      */
N#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN ERR: REC Mask          */
N
N#define CAN_ERR_TEC_Pos            0                                    /*!< CAN ERR: TEC Position      */
N#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN ERR: TEC Mask          */
N
N/* CAN BTIME Bit Field Definitions */   
N#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN BTIME: TSEG2 Position  */
N#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN BTIME: TSEG2 Mask      */
N
N#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN BTIME: TSEG1 Position  */
N#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN BTIME: TSEG1 Mask      */
N
N#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN BTIME: SJW Position    */
N#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN BTIME: SJW Mask        */
N
N#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN BTIME: BRP Position    */
N#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN BTIME: BRP Mask        */
N
N/* CAN IIDR Bit Field Definitions */
N#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN IIDR: INTID Position   */
N#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN IIDR: INTID Mask       */
N
N/* CAN TEST Bit Field Definitions */
N#define CAN_TEST_RX_Pos            7                                    /*!< CAN TEST: RX Position      */
N#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)             /*!< CAN TEST: RX Mask          */
N
N#define CAN_TEST_TX_Pos            5                                    /*!< CAN TEST: TX Position      */
N#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN TEST: TX Mask          */
N
N#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN TEST: LBACK Position   */
N#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)          /*!< CAN TEST: LBACK Mask       */
N             
N#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN TEST: Silent Position  */
N#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)         /*!< CAN TEST: Silent Mask      */
N
N#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN TEST: Basic Position   */
N#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)          /*!< CAN TEST: Basic Mask       */
N
N/* CAN BPRE Bit Field Definitions */
N#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN BRPE: BRPE Position    */
N#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN BRPE: BRPE Mask        */
N
N/* CAN IFn_CREQ Bit Field Definitions */
N#define CAN_IF_CREQ_BUSY_Pos       15                                   /*!< CAN IFnCREQ: BUSY Position */
N#define CAN_IF_CREQ_BUSY_Msk       (1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN IFnCREQ: BUSY Mask     */
N
N#define CAN_IF_CREQ_MSGNUM_Pos     0                                    /*!< CAN IFnCREQ: MSGNUM Position */
N#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)   /*!< CAN IFnCREQ: MSGNUM Mask     */
N
N/* CAN IFn_CMASK Bit Field Definitions */
N#define CAN_IF_CMASK_WRRD_Pos      7                                    /*!< CAN IFnCMASK: WRRD Position */
N#define CAN_IF_CMASK_WRRD_Msk      (1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN IFnCMASK: WRRD Mask     */
N
N#define CAN_IF_CMASK_MASK_Pos      6                                    /*!< CAN IFnCMASK: MASK Position */
N#define CAN_IF_CMASK_MASK_Msk      (1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN IFnCMASK: MASK Mask     */
N
N#define CAN_IF_CMASK_ARB_Pos       5                                    /*!< CAN IFnCMASK: ARB Position  */
N#define CAN_IF_CMASK_ARB_Msk       (1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN IFnCMASK: ARB Mask      */
N
N#define CAN_IF_CMASK_CONTROL_Pos   4                                    /*!< CAN IFnCMASK: CONTROL Position */
N#define CAN_IF_CMASK_CONTROL_Msk   (1ul << CAN_IF_CMASK_CONTROL_Pos)    /*!< CAN IFnCMASK: CONTROL Mask */
N
N#define CAN_IF_CMASK_CLRINTPND_Pos 3                                    /*!< CAN IFnCMASK: CLRINTPND Position */
N#define CAN_IF_CMASK_CLRINTPND_Msk (1ul << CAN_IF_CMASK_CLRINTPND_Pos)  /*!< CAN IFnCMASK: CLRINTPND Mask */
N  
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN IFnCMASK: TXRQSTNEWDAT Position */
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)    /*!< CAN IFnCMASK: TXRQSTNEWDAT Mask     */
N
N#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN IFnCMASK: DATAA Position */
N#define CAN_IF_CMASK_DATAA_Msk     (1ul << CAN_IF_CMASK_DATAA_Pos)      /*!< CAN IFnCMASK: DATAA Mask     */
N
N#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN IFnCMASK: DATAB Position */
N#define CAN_IF_CMASK_DATAB_Msk     (1ul << CAN_IF_CMASK_DATAB_Pos)      /*!< CAN IFnCMASK: DATAB Mask     */
N
N/* CAN IFn_MASK1 Bit Field Definitions */
N#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN IFnMASK1: MSK Position   */
N#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN IFnMASK1: MSK Mask       */
N
N/* CAN IFn_MASK2 Bit Field Definitions */
N#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN IFnMASK2: MXTD Position */
N#define CAN_IF_MASK2_MXTD_Msk      (1ul << CAN_IF_MASK2_MXTD_Pos)       /*!< CAN IFnMASK2: MXTD Mask     */
N
N#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN IFnMASK2: MDIR Position */
N#define CAN_IF_MASK2_MDIR_Msk      (1ul << CAN_IF_MASK2_MDIR_Pos)       /*!< CAN IFnMASK2: MDIR Mask     */
N
N#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN IFnMASK2: MSK Position */
N#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN IFnMASK2: MSK Mask     */
N
N/* CAN IFn_ARB1 Bit Field Definitions */
N#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN IFnARB1: ID Position   */
N#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN IFnARB1: ID Mask       */
N
N/* CAN IFn_ARB2 Bit Field Definitions */        
N#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN IFnARB2: MSGVAL Position */
N#define CAN_IF_ARB2_MSGVAL_Msk     (1ul << CAN_IF_ARB2_MSGVAL_Pos)      /*!< CAN IFnARB2: MSGVAL Mask     */
N
N#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN IFnARB2: XTD Position    */
N#define CAN_IF_ARB2_XTD_Msk        (1ul << CAN_IF_ARB2_XTD_Pos)         /*!< CAN IFnARB2: XTD Mask        */
N
N#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN IFnARB2: DIR Position    */
N#define CAN_IF_ARB2_DIR_Msk        (1ul << CAN_IF_ARB2_DIR_Pos)         /*!< CAN IFnARB2: DIR Mask        */
N
N#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN IFnARB2: ID Position     */
N#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN IFnARB2: ID Mask         */
N
N/* CAN IFn_MCON Bit Field Definitions */
N#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN IFnMCON: NEWDAT Position */ 
N#define CAN_IF_MCON_NEWDAT_Msk     (1ul << CAN_IF_MCON_NEWDAT_Pos)      /*!< CAN IFnMCON: NEWDAT Mask     */ 
N
N#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN IFnMCON: MSGLST Position */ 
N#define CAN_IF_MCON_MSGLST_Msk     (1ul << CAN_IF_MCON_MSGLST_Pos)      /*!< CAN IFnMCON: MSGLST Mask     */ 
N
N#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN IFnMCON: INTPND Position */ 
N#define CAN_IF_MCON_INTPND_Msk     (1ul << CAN_IF_MCON_INTPND_Pos)      /*!< CAN IFnMCON: INTPND Mask     */ 
N
N#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN IFnMCON: UMASK Position  */ 
N#define CAN_IF_MCON_UMASK_Msk      (1ul << CAN_IF_MCON_UMASK_Pos)       /*!< CAN IFnMCON: UMASK Mask      */ 
N
N#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN IFnMCON: TXIE Position   */ 
N#define CAN_IF_MCON_TXIE_Msk       (1ul << CAN_IF_MCON_TXIE_Pos)        /*!< CAN IFnMCON: TXIE Mask       */ 
N
N#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN IFnMCON: RXIE Position   */ 
N#define CAN_IF_MCON_RXIE_Msk       (1ul << CAN_IF_MCON_RXIE_Pos)        /*!< CAN IFnMCON: RXIE Mask       */ 
N
N#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN IFnMCON: RMTEN Position  */ 
N#define CAN_IF_MCON_RMTEN_Msk      (1ul << CAN_IF_MCON_RMTEN_Pos)       /*!< CAN IFnMCON: RMTEN Mask      */ 
N
N#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN IFnMCON: TXRQST Position */ 
N#define CAN_IF_MCON_TXRQST_Msk     (1ul << CAN_IF_MCON_TXRQST_Pos)      /*!< CAN IFnMCON: TXRQST Mask     */ 
N
N#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN IFnMCON: EOB Position    */ 
N#define CAN_IF_MCON_EOB_Msk        (1ul << CAN_IF_MCON_EOB_Pos)         /*!< CAN IFnMCON: EOB Mask        */ 
N
N#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN IFnMCON: DLC Position    */ 
N#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN IFnMCON: DLC Mask        */ 
N
N/* CAN IFn_DATA_A1 Bit Field Definitions */
N#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN IFnDATAA1: DATA1 Position */ 
N#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN IFnDATAA1: DATA1 Mask     */ 
N
N#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN IFnDATAA1: DATA0 Position */ 
N#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN IFnDATAA1: DATA0 Mask     */ 
N
N/* CAN IFn_DATA_A2 Bit Field Definitions */ 
N#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN IFnDATAA1: DATA3 Position */ 
N#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN IFnDATAA1: DATA3 Mask     */ 
N
N#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN IFnDATAA1: DATA2 Position */ 
N#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN IFnDATAA1: DATA2 Mask     */ 
N
N/* CAN IFn_DATA_B1 Bit Field Definitions */
N#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN IFnDATAB1: DATA5 Position */ 
N#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN IFnDATAB1: DATA5 Mask */ 
N
N#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN IFnDATAB1: DATA4 Position */ 
N#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN IFnDATAB1: DATA4 Mask */ 
N
N/* CAN IFn_DATA_B2 Bit Field Definitions */
N#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN IFnDATAB2: DATA7 Position */ 
N#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN IFnDATAB2: DATA7 Mask     */ 
N
N#define CAN_IF_DAT_B2_DATA6_Pos    8                                    /*!< CAN IFnDATAB2: DATA6 Position */ 
N#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN IFnDATAB2: DATA6 Mask     */ 
N
N/* CAN IFn_TXRQST1 Bit Field Definitions */
N#define CAN_IF_TXRQST1_TXRQST_Pos  0                                        /*!< CAN IFnTXRQST1: TXRQST Position */ 
N#define CAN_IF_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST1_TXRQST_Pos)  /*!< CAN IFnTXRQST1: TXRQST Mask     */ 
N
N/* CAN IFn_TXRQST2 Bit Field Definitions */
N#define CAN_IF_TXRQST2_TXRQST_Pos  0                                        /*!< CAN IFnTXRQST2: TXRQST Position  */ 
N#define CAN_IF_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST2_TXRQST_Pos)  /*!< CAN IFnTXRQST2: TXRQST Mask      */ 
N
N/* CAN IFn_NDAT1 Bit Field Definitions */
N#define CAN_IF_NDAT1_NEWDATA_Pos   0                                        /*!< CAN IFnNDAT1: NEWDATA Position */ 
N#define CAN_IF_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT1_NEWDATA_Pos)   /*!< CAN IFnNDAT1: NEWDATA Mask     */ 
N
N/* CAN IFn_NDAT2 Bit Field Definitions */
N#define CAN_IF_NDAT2_NEWDATA_Pos   0                                        /*!< CAN IFnNDAT2: NEWDATA Position */ 
N#define CAN_IF_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT2_NEWDATA_Pos)   /*!< CAN IFnNDAT2: NEWDATA Mask     */ 
N
N/* CAN IFn_IPND1 Bit Field Definitions */
N#define CAN_IF_IPND1_INTPND_Pos   0                                         /*!< CAN IFnIPND1: INTPND Position */ 
N#define CAN_IF_IPND1_INTPND_Msk   (0xFFFFul << CAN_IF_IPND1_INTPND_Pos)     /*!< CAN IFnIPND1: INTPND Mask     */ 
N
N/* CAN IFn_IPND2 Bit Field Definitions */
N#define CAN_IF_IPND2_INTPND_Pos   0                                         /*!< CAN IFnIPND2: INTPND Position */ 
N#define CAN_IF_IPND2_INTPND_Msk   (0xFFFFul << CAN_IF_IPND2_INTPND_Pos)     /*!< CAN IFnIPND2: INTPND Mask     */
N
N/* CAN IFn_MVLD1 Bit Field Definitions */
N#define CAN_IF_MVLD1_MSGVAL_Pos   0                                         /*!< CAN IFnMVLD1: MSGVAL Position */
N#define CAN_IF_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD1_MSGVAL_Pos)     /*!< CAN IFnMVLD1: MSGVAL Mask     */
N
N/* CAN IFn_MVLD2 Bit Field Definitions */
N#define CAN_IF_MVLD2_MSGVAL_Pos   0                                         /*!< CAN IFnMVLD2: MSGVAL Position */        
N#define CAN_IF_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD2_MSGVAL_Pos)     /*!< CAN IFnMVLD2: MSGVAL Mask     */
N
N/* CAN WUEN Bit Field Definitions */
N#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN WUEN: WAKUP_EN Position */
N#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)             /*!< CAN WUEN: WAKUP_EN Mask     */
N
N/* CAN WUSTATUS Bit Field Definitions */
N#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                    /*!< CAN WUSTATUS: WAKUP_STS Position */
N#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN WUSTATUS: WAKUP_STS Mask     */
N/*@}*/ /* end of group NUC200_CAN */                                  
N
N/*--------------------------- USB Device Controller --------------------------*/
N/** @addtogroup NUC200_USBD NUC200 USBD
N  Memory Mapped Structure for NUC200 Series USB Device Controller
N  @{
N */
N
Ntypedef struct
N{
N        __IO uint32_t BUFSEG;   /*!< Endpoint Buffer Segmentation Register   */
X        volatile uint32_t BUFSEG;    
N        
N        __IO uint32_t MXPLD;    /*!< Endpoint Maximal Payload Register   */
X        volatile uint32_t MXPLD;     
N        
N        __IO uint32_t CFG;      /*!< Endpoint Configuration Register   */
X        volatile uint32_t CFG;       
N        
N        __IO uint32_t CFGP;     /*!< Endpoint Set Stall and Clear In/Out Ready Control Register */
X        volatile uint32_t CFGP;      
N    
N} USBD_EP_T;
N
Ntypedef struct
N{
N        __IO uint32_t INTEN;      /*!< Offset: 0x00  USB Interrupt Enable Register   */
X        volatile uint32_t INTEN;       
N        
N        __IO uint32_t INTSTS;     /*!< Offset: 0x04  USB Interrupt Event Status Register   */
X        volatile uint32_t INTSTS;      
N        
N        __IO uint32_t FADDR;      /*!< Offset: 0x08  USB Device Function Address Register   */
X        volatile uint32_t FADDR;       
N        
N        __I  uint32_t EPSTS;      /*!< Offset: 0x0C  USB Endpoint Status Register   */
X        volatile const  uint32_t EPSTS;       
N        
N        __IO uint32_t ATTR;       /*!< Offset: 0x10  USB Bus Status and Attribution Register   */
X        volatile uint32_t ATTR;        
N        
N        __I  uint32_t FLDET;      /*!< Offset: 0x14  USB Floating Detected Register   */
X        volatile const  uint32_t FLDET;       
N        
N        __IO uint32_t STBUFSEG;   /*!< Offset: 0x18  Setup Token Buffer Segmentation Register   */
X        volatile uint32_t STBUFSEG;    
N    
N        __I  uint32_t RESERVE0;
X        volatile const  uint32_t RESERVE0;
N    
N        USBD_EP_T EP[6];          /*!< Offset: 0x20  Endpoint Related Configuration Registers   */
N    
N        __I  uint32_t RESERVE1[4];
X        volatile const  uint32_t RESERVE1[4];
N    
N        __IO uint32_t DRVSE0;     /*!< Offset: 0x90  USB Driver SE0 Control Register   */
X        volatile uint32_t DRVSE0;      
N        
N} USBD_T;
N
N/* USBD INTEN Bit Field Definitions */
N#define USBD_INTEN_INNAK_EN_Pos    15                                    /*!< USB INTEN: INNAK_EN Position */
N#define USBD_INTEN_INNAK_EN_Msk    (1ul << USBD_INTEN_INNAK_EN_Pos)      /*!< USB INTEN: INNAK_EN Mask */
N
N#define USBD_INTEN_WAKEUP_EN_Pos   8                                     /*!< USB INTEN: WAKEUP_EN Position */
N#define USBD_INTEN_WAKEUP_EN_Msk   (1ul << USBD_INTEN_WAKEUP_EN_Pos)     /*!< USB INTEN: WAKEUP_EN Mask */
N
N#define USBD_INTEN_WAKEUP_IE_Pos   3                                     /*!< USB INTEN: WAKEUP_IE Position */
N#define USBD_INTEN_WAKEUP_IE_Msk   (1ul << USBD_INTEN_WAKEUP_IE_Pos)     /*!< USB INTEN: WAKEUP_IE Mask */
N
N#define USBD_INTEN_FLDET_IE_Pos    2                                     /*!< USB INTEN: FLDET_IE Position */
N#define USBD_INTEN_FLDET_IE_Msk    (1ul << USBD_INTEN_FLDET_IE_Pos)      /*!< USB INTEN: FLDET_IE Mask */
N
N#define USBD_INTEN_USB_IE_Pos      1                                     /*!< USB INTEN: USB_IE Position */
N#define USBD_INTEN_USB_IE_Msk      (1ul << USBD_INTEN_USB_IE_Pos)        /*!< USB INTEN: USB_IE Mask */
N
N#define USBD_INTEN_BUS_IE_Pos      0                                     /*!< USB INTEN: BUS_IE Position */
N#define USBD_INTEN_BUS_IE_Msk      (1ul << USBD_INTEN_BUS_IE_Pos)        /*!< USB INTEN: BUS_IE Mask */
N
N/* USBD INTSTS Bit Field Definitions */
N#define USBD_INTSTS_SETUP_Pos        31                                  /*!< USB INTSTS: SETUP Position */
N#define USBD_INTSTS_SETUP_Msk        (1ul << USBD_INTSTS_SETUP_Pos)      /*!< USB INTSTS: SETUP Mask */
N
N#define USBD_INTSTS_EPEVT_Pos        16                                  /*!< USB INTSTS: EPEVT Position */
N#define USBD_INTSTS_EPEVT_Msk        (0x3Ful << USBD_INTSTS_EPEVT_Pos)   /*!< USB INTSTS: EPEVT Mask */
N
N#define USBD_INTSTS_WAKEUP_STS_Pos   3                                   /*!< USB INTSTS: WAKEUP_STS Position */
N#define USBD_INTSTS_WAKEUP_STS_Msk   (1ul << USBD_INTSTS_WAKEUP_STS_Pos) /*!< USB INTSTS: WAKEUP_STS Mask */
N
N#define USBD_INTSTS_FLDET_STS_Pos    2                                   /*!< USB INTSTS: FLDET_STS Position */
N#define USBD_INTSTS_FLDET_STS_Msk    (1ul << USBD_INTSTS_FLDET_STS_Pos)  /*!< USB INTSTS: FLDET_STS Mask */
N
N#define USBD_INTSTS_USB_STS_Pos      1                                   /*!< USB INTSTS: USB_STS Position */
N#define USBD_INTSTS_USB_STS_Msk      (1ul << USBD_INTSTS_USB_STS_Pos)    /*!< USB INTSTS: USB_STS Mask */
N
N#define USBD_INTSTS_BUS_STS_Pos      0                                   /*!< USB INTSTS: BUS_STS Position */
N#define USBD_INTSTS_BUS_STS_Msk      (1ul << USBD_INTSTS_BUS_STS_Pos)    /*!< USB INTSTS: BUS_STS Mask */
N
N/* USBD FADDR Bit Field Definitions */
N#define USBD_FADDR_FADDR_Pos     0                                       /*!< USB FADDR: FADDR Position */
N#define USBD_FADDR_FADDR_Msk     (0x7Ful << USBD_FADDR_FADDR_Pos)        /*!< USB FADDR: FADDR Mask */
N
N/* USBD EPSTS Bit Field Definitions */
N#define USBD_EPSTS_EPSTS5_Pos    23                                      /*!< USB EPSTS: EPSTS5 Position */
N#define USBD_EPSTS_EPSTS5_Msk    (7ul << USBD_EPSTS_EPSTS5_Pos)          /*!< USB EPSTS: EPSTS5 Mask */
N
N#define USBD_EPSTS_EPSTS4_Pos    20                                      /*!< USB EPSTS: EPSTS4 Position */
N#define USBD_EPSTS_EPSTS4_Msk    (7ul << USBD_EPSTS_EPSTS4_Pos)          /*!< USB EPSTS: EPSTS5 Mask */
N
N#define USBD_EPSTS_EPSTS3_Pos    17                                      /*!< USB EPSTS: EPSTS3 Position */
N#define USBD_EPSTS_EPSTS3_Msk    (7ul << USBD_EPSTS_EPSTS3_Pos)          /*!< USB EPSTS: EPSTS3 Mask */
N
N#define USBD_EPSTS_EPSTS2_Pos    14                                      /*!< USB EPSTS: EPSTS2 Position */
N#define USBD_EPSTS_EPSTS2_Msk    (7ul << USBD_EPSTS_EPSTS2_Pos)          /*!< USB EPSTS: EPSTS2 Mask */
N
N#define USBD_EPSTS_EPSTS1_Pos    11                                      /*!< USB EPSTS: EPSTS1 Position */
N#define USBD_EPSTS_EPSTS1_Msk    (7ul << USBD_EPSTS_EPSTS1_Pos)          /*!< USB EPSTS: EPSTS1 Mask */
N
N#define USBD_EPSTS_EPSTS0_Pos    8                                       /*!< USB EPSTS: EPSTS0 Position */
N#define USBD_EPSTS_EPSTS0_Msk    (7ul << USBD_EPSTS_EPSTS0_Pos)          /*!< USB EPSTS: EPSTS0 Mask */
N
N#define USBD_EPSTS_OVERRUN_Pos   7                                       /*!< USB EPSTS: OVERRUN Position */
N#define USBD_EPSTS_OVERRUN_Msk   (1ul << USBD_EPSTS_OVERRUN_Pos)         /*!< USB EPSTS: OVERRUN Mask */
N
N/* USBD ATTR Bit Field Definitions */
N#define USBD_ATTR_PWRDN_Pos      9                                       /*!< USB ATTR: PWRDN Position */
N#define USBD_ATTR_PWRDN_Msk      (1ul << USBD_ATTR_PWRDN_Pos)            /*!< USB ATTR: PWRDN Mask */
N
N#define USBD_ATTR_DPPU_EN_Pos    8                                       /*!< USB ATTR: DPPU_EN Position */
N#define USBD_ATTR_DPPU_EN_Msk    (1ul << USBD_ATTR_DPPU_EN_Pos)          /*!< USB ATTR: DPPU_EN Mask */
N
N#define USBD_ATTR_USB_EN_Pos     7                                       /*!< USB ATTR: USB_EN Position */
N#define USBD_ATTR_USB_EN_Msk     (1ul << USBD_ATTR_USB_EN_Pos)           /*!< USB ATTR: USB_EN Mask */
N
N#define USBD_ATTR_RWAKEUP_Pos    5                                       /*!< USB ATTR: RWAKEUP Position */
N#define USBD_ATTR_RWAKEUP_Msk    (1ul << USBD_ATTR_RWAKEUP_Pos)          /*!< USB ATTR: RWAKEUP Mask */
N
N#define USBD_ATTR_PHY_EN_Pos     4                                       /*!< USB ATTR: PHY_EN Position */
N#define USBD_ATTR_PHY_EN_Msk     (1ul << USBD_ATTR_PHY_EN_Pos)           /*!< USB ATTR: PHY_EN Mask */
N
N#define USBD_ATTR_TIMEOUT_Pos    3                                       /*!< USB ATTR: TIMEOUT Position */
N#define USBD_ATTR_TIMEOUT_Msk    (1ul << USBD_ATTR_TIMEOUT_Pos)          /*!< USB ATTR: TIMEOUT Mask */
N
N#define USBD_ATTR_RESUME_Pos     2                                       /*!< USB ATTR: RESUME Position */
N#define USBD_ATTR_RESUME_Msk     (1ul << USBD_ATTR_RESUME_Pos)           /*!< USB ATTR: RESUME Mask */
N
N#define USBD_ATTR_SUSPEND_Pos    1                                       /*!< USB ATTR: SUSPEND Position */
N#define USBD_ATTR_SUSPEND_Msk    (1ul << USBD_ATTR_SUSPEND_Pos)          /*!< USB ATTR: SUSPEND Mask */
N
N#define USBD_ATTR_USBRST_Pos     0                                       /*!< USB ATTR: USBRST Position */
N#define USBD_ATTR_USBRST_Msk     (1ul << USBD_ATTR_USBRST_Pos)           /*!< USB ATTR: USBRST Mask */
N
N/* USBD FLDET Bit Field Definitions */
N#define USBD_FLDET_FLDET_Pos     0                                       /*!< USB FLDET: FLDET Position */
N#define USBD_FLDET_FLDET_Msk     (1ul << USBD_FLDET_FLDET_Pos)           /*!< USB FLDET: FLDET Mask */
N
N/* USBD STBUFSEG Bit Field Definitions */
N#define USBD_STBUFSEG_STBUFSEG_Pos   3                                        /*!< USB STBUFSEG: STBUFSEG Position */
N#define USBD_STBUFSEG_STBUFSEG_Msk   (0x3Ful << USBD_STBUFSEG_STBUFSEG_Pos)   /*!< USB STBUFSEG: STBUFSEG Mask */
N
N/* USBD BUFSEG Bit Field Definitions */
N#define USBD_BUFSEG_BUFSEG_Pos   3                                       /*!< USB BUFSEG: BUFSEG Position */
N#define USBD_BUFSEG_BUFSEG_Msk   (0x3Ful << USBD_BUFSEG_BUFSEG_Pos)      /*!< USB BUFSEG: BUFSEG Mask */
N
N/* USBD MXPLD Bit Field Definitions */
N#define USBD_MXPLD_MXPLD_Pos    0                                        /*!< USB MXPLD: MXPLD Position */
N#define USBD_MXPLD_MXPLD_Msk    (0x1FFul << USBD_MXPLD_MXPLD_Pos)        /*!< USB MXPLD: MXPLD Mask */
N
N/* USBD CFG Bit Field Definitions */
N#define USBD_CFG_CSTALL_Pos     9                                        /*!< USB CFG: CSTALL Position */
N#define USBD_CFG_CSTALL_Msk     (1ul << USBD_CFG_CSTALL_Pos)             /*!< USB CFG: CSTALL Mask */
N
N#define USBD_CFG_DSQ_SYNC_Pos   7                                        /*!< USB CFG: DSQ_SYNC Position */
N#define USBD_CFG_DSQ_SYNC_Msk   (1ul << USBD_CFG_DSQ_SYNC_Pos)           /*!< USB CFG: DSQ_SYNC Mask */
N
N#define USBD_CFG_STATE_Pos      5                                        /*!< USB CFG: STATE Position */
N#define USBD_CFG_STATE_Msk      (3ul << USBD_CFG_STATE_Pos)              /*!< USB CFG: STATE Mask */
N
N#define USBD_CFG_ISOCH_Pos      4                                        /*!< USB CFG: ISOCH Position */
N#define USBD_CFG_ISOCH_Msk      (1ul << USBD_CFG_ISOCH_Pos)              /*!< USB CFG: ISOCH Mask */
N
N#define USBD_CFG_EP_NUM_Pos     0                                        /*!< USB CFG: EP_NUM Position */
N#define USBD_CFG_EP_NUM_Msk     (0xFul << USBD_CFG_EP_NUM_Pos)           /*!< USB CFG: EP_NUM Mask */
N
N/* USBD CFGP Bit Field Definitions */
N#define USBD_CFGP_SSTALL_Pos    1                                        /*!< USB CFGP: SSTALL Position */
N#define USBD_CFGP_SSTALL_Msk    (1ul << USBD_CFGP_SSTALL_Pos)            /*!< USB CFGP: SSTALL Mask */
N
N#define USBD_CFGP_CLRRDY_Pos    0                                        /*!< USB CFGP: CLRRDY Position */
N#define USBD_CFGP_CLRRDY_Msk    (1ul << USBD_CFGP_CLRRDY_Pos)            /*!< USB CFGP: CLRRDY Mask */
N
N/* USBD DRVSE0 Bit Field Definitions */
N#define USBD_DRVSE0_DRVSE0_Pos   0                                       /*!< USB DRVSE0: DRVSE0 Position */
N#define USBD_DRVSE0_DRVSE0_Msk   (1ul << USBD_DRVSE0_DRVSE0_Pos)         /*!< USB DRVSE0: DRVSE0 Mask */
N
N/*@}*/ /* end of group NUC200_USBD */
N
N
N/*------------------------------ DMA Controller -----------------------------*/
N/** @addtogroup NUC200_PWM NUC200 PWM
N  Memory Mapped Structure for NUC200 Series DMA Controller 
N  @{
N */
Ntypedef struct
N{
N    __IO uint32_t CSR;
X    volatile uint32_t CSR;
N    __IO uint32_t SAR;
X    volatile uint32_t SAR;
N    __IO uint32_t DAR;
X    volatile uint32_t DAR;
N    __IO uint32_t BCR;
X    volatile uint32_t BCR;
N    __I  uint32_t POINT;
X    volatile const  uint32_t POINT;
N    __I  uint32_t CSAR;
X    volatile const  uint32_t CSAR;
N    __I  uint32_t CDAR;
X    volatile const  uint32_t CDAR;
N    __I  uint32_t CBCR;
X    volatile const  uint32_t CBCR;
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N    __IO uint32_t ISR;
X    volatile uint32_t ISR;
N    __I  uint32_t RESERVE[22];
X    volatile const  uint32_t RESERVE[22];
N    __I  uint32_t SBUF;
X    volatile const  uint32_t SBUF;
N} PDMA_T;
N
Ntypedef struct
N{
N    __IO uint32_t GCRCSR;
X    volatile uint32_t GCRCSR;
N    __IO uint32_t PDSSR0;
X    volatile uint32_t PDSSR0;
N    __IO uint32_t PDSSR1;
X    volatile uint32_t PDSSR1;
N    __IO uint32_t GCRISR;
X    volatile uint32_t GCRISR;
N    __IO uint32_t PDSSR2;
X    volatile uint32_t PDSSR2;
N} PDMA_GCR_T;
N
N
N/* PDMA CSR Bit Field Definitions */
N#define PDMA_CSR_TRIG_EN_Pos                        23                              /*!< PDMA CSR: TRIG_EN Position */
N#define PDMA_CSR_TRIG_EN_Msk                        (1ul << PDMA_CSR_TRIG_EN_Pos)   /*!< PDMA CSR: TRIG_EN Mask */
N
N#define PDMA_CSR_APB_TWS_Pos                        19                              /*!< PDMA CSR: APB_TWS Position */
N#define PDMA_CSR_APB_TWS_Msk                        (3ul << PDMA_CSR_APB_TWS_Pos)   /*!< PDMA CSR: APB_TWS Mask */
N
N#define PDMA_CSR_DAD_SEL_Pos                        6                               /*!< PDMA CSR: DAD_SEL Position */
N#define PDMA_CSR_DAD_SEL_Msk                        (3ul << PDMA_CSR_DAD_SEL_Pos)   /*!< PDMA CSR: DAD_SEL Mask */
N
N#define PDMA_CSR_SAD_SEL_Pos                        4                               /*!< PDMA CSR: SAD_SEL Position */
N#define PDMA_CSR_SAD_SEL_Msk                        (3ul << PDMA_CSR_SAD_SEL_Pos)   /*!< PDMA CSR: SAD_SEL Mask */
N
N#define PDMA_CSR_MODE_SEL_Pos                       2                               /*!< PDMA CSR: MODE_SEL Position */
N#define PDMA_CSR_MODE_SEL_Msk                       (3ul << PDMA_CSR_MODE_SEL_Pos)  /*!< PDMA CSR: MODE_SEL Mask */
N
N#define PDMA_CSR_SW_RST_Pos                         1                               /*!< PDMA CSR: SW_RST Position */
N#define PDMA_CSR_SW_RST_Msk                         (1ul << PDMA_CSR_SW_RST_Pos)    /*!< PDMA CSR: SW_RST Mask */
N
N#define PDMA_CSR_PDMACEN_Pos                        0                               /*!< PDMA CSR: PDMACEN Position */
N#define PDMA_CSR_PDMACEN_Msk                        (1ul << PDMA_CSR_PDMACEN_Pos)   /*!< PDMA CSR: PDMACEN Mask */
N
N/* PDMA BCR Bit Field Definitions */
N#define PDMA_BCR_BCR_Pos                            0                               /*!< PDMA BCR: BCR Position */
N#define PDMA_BCR_BCR_Msk                            (0xFFFFul << PDMA_BCR_BCR_Pos)  /*!< PDMA BCR: BCR Mask */
N
N/* PDMA POINT Bit Field Definitions */
N#define PDMA_POINT_POINT_Pos                        0                               /*!< PDMA POINT: POINT Position */
N#define PDMA_POINT_POINT_Msk                        (0xFul << PDMA_POINT_POINT_Pos) /*!< PDMA POINT: POINT Mask */
N
N/* PDMA CBCR Bit Field Definitions */
N#define PDMA_CBCR_CBCR_Pos                          0                                   /*!< PDMA CBCR: CBCR Position */
N#define PDMA_CBCR_CBCR_Msk                          (0xFFFFul << PDMA_CBCR_CBCR_Pos)    /*!< PDMA CBCR: CBCR Mask */
N
N
N/* PDMA IER Bit Field Definitions */
N#define PDMA_IER_BLKD_IE_Pos                        1                               /*!< PDMA IER: BLKD_IE Position */
N#define PDMA_IER_BLKD_IE_Msk                        (1ul << PDMA_IER_BLKD_IE_Pos)   /*!< PDMA IER: BLKD_IE Mask */
N
N#define PDMA_IER_TABORT_IE_Pos                      0                               /*!< PDMA IER: TABORT_IE Position */
N#define PDMA_IER_TABORT_IE_Msk                      (1ul << PDMA_IER_TABORT_IE_Pos) /*!< PDMA IER: TABORT_IE Mask */
N
N/* PDMA ISR Bit Field Definitions */
N#define PDMA_ISR_BLKD_IF_Pos                        1                               /*!< PDMA ISR: BLKD_IF Position */
N#define PDMA_ISR_BLKD_IF_Msk                        (1ul << PDMA_ISR_BLKD_IF_Pos)   /*!< PDMA ISR: BLKD_IF Mask */
N
N#define PDMA_ISR_TABORT_IF_Pos                      0                               /*!< PDMA ISR: TABORT_IF Position */
N#define PDMA_ISR_TABORT_IF_Msk                      (1ul << PDMA_ISR_TABORT_IF_Pos) /*!< PDMA ISR: TABORT_IF Mask */
N
N/* PDMA GCRCSR Bit Field Definitions */
N#define PDMA_GCRCSR_CRC_CLK_EN_Pos                  24                                  /*!< PDMA GCRCSR: CRC_CLK_EN Position */
N#define PDMA_GCRCSR_CRC_CLK_EN_Msk                  (1ul << PDMA_GCRCSR_CRC_CLK_EN_Pos) /*!< PDMA GCRCSR: CRC_CLK_EN Mask */
N
N#define PDMA_GCRCSR_CLK8_EN_Pos                     16                                  /*!< PDMA GCRCSR: CLK8_EN Position */
N#define PDMA_GCRCSR_CLK8_EN_Msk                     (1ul << PDMA_GCRCSR_CLK8_EN_Pos)    /*!< PDMA GCRCSR: CLK8_EN Mask */
N
N#define PDMA_GCRCSR_CLK7_EN_Pos                     15                                  /*!< PDMA GCRCSR: CLK7_EN Position */
N#define PDMA_GCRCSR_CLK7_EN_Msk                     (1ul << PDMA_GCRCSR_CLK7_EN_Pos)    /*!< PDMA GCRCSR: CLK7_EN Mask */
N
N#define PDMA_GCRCSR_CLK6_EN_Pos                     14                                  /*!< PDMA GCRCSR: CLK6_EN Position */
N#define PDMA_GCRCSR_CLK6_EN_Msk                     (1ul << PDMA_GCRCSR_CLK6_EN_Pos)    /*!< PDMA GCRCSR: CLK6_EN Mask */
N
N#define PDMA_GCRCSR_CLK5_EN_Pos                     13                                  /*!< PDMA GCRCSR: CLK5_EN Position */
N#define PDMA_GCRCSR_CLK5_EN_Msk                     (1ul << PDMA_GCRCSR_CLK5_EN_Pos)    /*!< PDMA GCRCSR: CLK5_EN Mask */
N
N#define PDMA_GCRCSR_CLK4_EN_Pos                     12                                  /*!< PDMA GCRCSR: CLK4_EN Position */
N#define PDMA_GCRCSR_CLK4_EN_Msk                     (1ul << PDMA_GCRCSR_CLK4_EN_Pos)    /*!< PDMA GCRCSR: CLK4_EN Mask */
N
N#define PDMA_GCRCSR_CLK3_EN_Pos                     11                                  /*!< PDMA GCRCSR: CLK3_EN Position */
N#define PDMA_GCRCSR_CLK3_EN_Msk                     (1ul << PDMA_GCRCSR_CLK3_EN_Pos)    /*!< PDMA GCRCSR: CLK3_EN Mask */
N
N#define PDMA_GCRCSR_CLK2_EN_Pos                     10                                  /*!< PDMA GCRCSR: CLK2_EN Position */
N#define PDMA_GCRCSR_CLK2_EN_Msk                     (1ul << PDMA_GCRCSR_CLK2_EN_Pos)    /*!< PDMA GCRCSR: CLK2_EN Mask */
N
N#define PDMA_GCRCSR_CLK1_EN_Pos                     9                                   /*!< PDMA GCRCSR: CLK1_EN Position */
N#define PDMA_GCRCSR_CLK1_EN_Msk                     (1ul << PDMA_GCRCSR_CLK1_EN_Pos)    /*!< PDMA GCRCSR: CLK1_EN Mask */
N
N#define PDMA_GCRCSR_CLK0_EN_Pos                     8                                   /*!< PDMA GCRCSR: CLK0_EN Position */
N#define PDMA_GCRCSR_CLK0_EN_Msk                     (1ul << PDMA_GCRCSR_CLK0_EN_Pos)    /*!< PDMA GCRCSR: CLK0_EN Mask */
N
N/* PDMA PDSSR0 Bit Field Definitions */
N#define PDMA_PDSSR0_SPI3_TXSEL_Pos                  28                                      /*!< PDMA PDSSR0: SPI3_TXSEL Position */
N#define PDMA_PDSSR0_SPI3_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI3_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI3_RXSEL_Pos                  24                                      /*!< PDMA PDSSR0: SPI3_RXSEL Position */
N#define PDMA_PDSSR0_SPI3_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI3_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI2_TXSEL_Pos                  20                                      /*!< PDMA PDSSR0: SPI2_TXSEL Position */
N#define PDMA_PDSSR0_SPI2_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI2_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI2_RXSEL_Pos                  16                                      /*!< PDMA PDSSR0: SPI2_RXSEL Position */
N#define PDMA_PDSSR0_SPI2_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI2_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI1_TXSEL_Pos                  12                                      /*!< PDMA PDSSR0: SPI1_TXSEL Position */
N#define PDMA_PDSSR0_SPI1_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI1_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI1_RXSEL_Pos                  8                                       /*!< PDMA PDSSR0: SPI1_RXSEL Position */
N#define PDMA_PDSSR0_SPI1_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI1_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI0_TXSEL_Pos                  4                                       /*!< PDMA PDSSR0: SPI0_TXSEL Position */
N#define PDMA_PDSSR0_SPI0_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI0_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI0_RXSEL_Pos                  0                                       /*!< PDMA PDSSR0: SPI0_RXSEL Position */
N#define PDMA_PDSSR0_SPI0_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI0_RXSEL Mask */
N
N/* PDMA PDSSR1 Bit Field Definitions */
N#define PDMA_PDSSR1_ADC_RXSEL_Pos                   24                                      /*!< PDMA PDSSR1: ADC_RXSEL Position */
N#define PDMA_PDSSR1_ADC_RXSEL_Msk                   (0xFul << PDMA_PDSSR1_ADC_RXSEL_Pos)    /*!< PDMA PDSSR1: ADC_RXSEL Mask */
N
N#define PDMA_PDSSR1_UART1_TXSEL_Pos                 12                                      /*!< PDMA PDSSR1: UART1_TXSEL Position */
N#define PDMA_PDSSR1_UART1_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_TXSEL_Pos)  /*!< PDMA PDSSR1: UART1_TXSEL Mask */
N
N#define PDMA_PDSSR1_UART1_RXSEL_Pos                 8                                       /*!< PDMA PDSSR1: UART1_RXSEL Position */
N#define PDMA_PDSSR1_UART1_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_RXSEL_Pos)  /*!< PDMA PDSSR1: UART1_RXSEL Mask */
N
N#define PDMA_PDSSR1_UART0_TXSEL_Pos                 4                                       /*!< PDMA PDSSR1: UART0_TXSEL Position */
N#define PDMA_PDSSR1_UART0_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_TXSEL_Pos)  /*!< PDMA PDSSR1: UART0_TXSEL Mask */
N
N#define PDMA_PDSSR1_UART0_RXSEL_Pos                 0                                       /*!< PDMA PDSSR1: UART0_RXSEL Position */
N#define PDMA_PDSSR1_UART0_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_RXSEL_Pos)  /*!< PDMA PDSSR1: UART0_RXSEL Mask */
N
N/* PDMA GCRISR Bit Field Definitions */
N#define PDMA_GCRISR_INTR_Pos                        31                              /*!< PDMA GCRISR: INTR Position */
N#define PDMA_GCRISR_INTR_Msk                        (1ul << PDMA_GCRISR_INTR_Pos)   /*!< PDMA GCRISR: INTR Mask */
N
N#define PDMA_GCRISR_INTRCRC_Pos                     16                               /*!< PDMA GCRISR: INTRCRC Position */
N#define PDMA_GCRISR_INTRCRC_Msk                     (1ul << PDMA_GCRISR_INTRCRC_Pos) /*!< PDMA GCRISR: INTRCRC Mask */
N
N#define PDMA_GCRISR_INTR8_Pos                       8                               /*!< PDMA GCRISR: INTR8 Position */
N#define PDMA_GCRISR_INTR8_Msk                       (1ul << PDMA_GCRISR_INTR8_Pos)  /*!< PDMA GCRISR: INTR8 Mask */
N
N#define PDMA_GCRISR_INTR7_Pos                       7                               /*!< PDMA GCRISR: INTR7 Position */
N#define PDMA_GCRISR_INTR7_Msk                       (1ul << PDMA_GCRISR_INTR7_Pos)  /*!< PDMA GCRISR: INTR7 Mask */
N
N#define PDMA_GCRISR_INTR6_Pos                       6                               /*!< PDMA GCRISR: INTR6 Position */
N#define PDMA_GCRISR_INTR6_Msk                       (1ul << PDMA_GCRISR_INTR6_Pos)  /*!< PDMA GCRISR: INTR6 Mask */
N
N#define PDMA_GCRISR_INTR5_Pos                       5                               /*!< PDMA GCRISR: INTR5 Position */
N#define PDMA_GCRISR_INTR5_Msk                       (1ul << PDMA_GCRISR_INTR5_Pos)  /*!< PDMA GCRISR: INTR5 Mask */ 
N
N#define PDMA_GCRISR_INTR4_Pos                       4                               /*!< PDMA GCRISR: INTR4 Position */
N#define PDMA_GCRISR_INTR4_Msk                       (1ul << PDMA_GCRISR_INTR4_Pos)  /*!< PDMA GCRISR: INTR4 Mask */
N
N#define PDMA_GCRISR_INTR3_Pos                       3                               /*!< PDMA GCRISR: INTR3 Position */
N#define PDMA_GCRISR_INTR3_Msk                       (1ul << PDMA_GCRISR_INTR3_Pos)  /*!< PDMA GCRISR: INTR3 Mask */
N
N#define PDMA_GCRISR_INTR2_Pos                       2                               /*!< PDMA GCRISR: INTR2 Position */
N#define PDMA_GCRISR_INTR2_Msk                       (1ul << PDMA_GCRISR_INTR2_Pos)  /*!< PDMA GCRISR: INTR2 Mask */
N
N#define PDMA_GCRISR_INTR1_Pos                       1                               /*!< PDMA GCRISR: INTR1 Position */
N#define PDMA_GCRISR_INTR1_Msk                       (1ul << PDMA_GCRISR_INTR1_Pos)  /*!< PDMA GCRISR: INTR1 Mask */
N
N#define PDMA_GCRISR_INTR0_Pos                       0                               /*!< PDMA GCRISR: INTR0 Position */
N#define PDMA_GCRISR_INTR0_Msk                       (1ul << PDMA_GCRISR_INTR0_Pos)  /*!< PDMA GCRISR: INTR0 Mask */
N
N/* PDMA PDSSR2 Bit Field Definitions */
N#define PDMA_PDSSR2_I2S_TXSEL_Pos                   4                                       /*!< PDMA PDSSR2: I2S_TXSEL Position */
N#define PDMA_PDSSR2_I2S_TXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_TXSEL_Pos)    /*!< PDMA PDSSR2: I2S_TXSEL Mask */
N
N#define PDMA_PDSSR2_I2S_RXSEL_Pos                   0                                       /*!< PDMA PDSSR2: I2S_RXSEL Position */
N#define PDMA_PDSSR2_I2S_RXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_RXSEL_Pos)    /*!< PDMA PDSSR2: I2S_RXSEL Mask */
N/*@}*/ /* end of group NUC200_DMA */
N
N
N/*----------------------------- Cyclic Redundancy Check (CRC) Controller -----------------------------*/
N/** @addtogroup NUC200_CRC NUC200 CRC
N  Memory Mapped Structure for NUC200 Series Cyclic Redundancy Check
N  @{
N */
Ntypedef struct
N{
N    /**
N     * CRC_CTL
N     * ===================================================================================================
N     * Offset: 0x00  CRC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  CTL;
X    volatile uint32_t  CTL;
N
N    /**
N     * CRC_DMASAR 
N     * ===================================================================================================
N     * Offset: 0x04  CRC DMA Transfer Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DMASAR;
X    volatile uint32_t  DMASAR;
N
N    __I  uint32_t  RESERVED0;
X    volatile const  uint32_t  RESERVED0;
N
N    /**
N     * CRC_DMABCR 
N     * ===================================================================================================
N     * Offset: 0x0C  CRC DMA Transfer Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DMABCR ;
X    volatile uint32_t  DMABCR ;
N
N    __I  uint32_t  RESERVED1;
X    volatile const  uint32_t  RESERVED1;
N
N    /**
N     * CRC_DMACSAR
N     * ===================================================================================================
N     * Offset: 0x14  CRC DMA Current Source Address Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  DMACSAR;
X    volatile const  uint32_t  DMACSAR;
N
N    __I  uint32_t  RESERVED2;
X    volatile const  uint32_t  RESERVED2;
N
N    /**
N     * CRC_DMACBCR
N     * ===================================================================================================
N     * Offset: 0x1C  CRC DMA Current Byte Count Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  DMACBCR;
X    volatile const  uint32_t  DMACBCR;
N
N    /**
N     * CRC_DMAIER 
N     * ===================================================================================================
N     * Offset: 0x20  CRC DMA Interrupt Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DMAIER ;
X    volatile uint32_t  DMAIER ;
N
N    /**
N     * CRC_DMAISR 
N     * ===================================================================================================
N     * Offset: 0x24  CRC DMA Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  DMAISR;
X    volatile uint32_t  DMAISR;
N
N    __I  uint32_t  RESERVED3[22];
X    volatile const  uint32_t  RESERVED3[22];
N
N    /**
N     * CRC_WDATA 
N     * ===================================================================================================
N     * Offset: 0x80  CRC Write Data Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  WDATA;
X    volatile uint32_t  WDATA;
N
N    /**
N     * CRC_SEED 
N     * ===================================================================================================
N     * Offset: 0x84  CRC Seed Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t  SEED;
X    volatile uint32_t  SEED;
N
N    /**
N     * CRC_CHECKSUM
N     * ===================================================================================================
N     * Offset: 0x88  CRC Checksum Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I  uint32_t  CHECKSUM;
X    volatile const  uint32_t  CHECKSUM;
N} CRC_T;
N
N/* CRC CTL Bit Field Definitions */
N#define CRC_CTL_CRC_MODE_Pos            30                                      /*!< CRC CRC_CTL : CRC_MODE Position */
N#define CRC_CTL_CRC_MODE_Msk            (0x3ul << CRC_CTL_CRC_MODE_Pos)         /*!< CRC CRC_CTL : CRC_MODE Mask */
N
N#define CRC_CTL_CPU_WDLEN_Pos           28                                      /*!< CRC CRC_CTL : CPU_WDLEN Position */
N#define CRC_CTL_CPU_WDLEN_Msk           (0x3ul << CRC_CTL_CPU_WDLEN_Pos)        /*!< CRC CRC_CTL : CPU_WDLEN Mask */
N
N#define CRC_CTL_CHECKSUM_COM_Pos        27                                      /*!< CRC CRC_CTL : CHECKSUM_COM Position */
N#define CRC_CTL_CHECKSUM_COM_Msk        (1ul << CRC_CTL_CHECKSUM_COM_Pos)       /*!< CRC CRC_CTL : CHECKSUM_COM Mask */
N
N#define CRC_CTL_WDATA_COM_Pos           26                                      /*!< CRC CRC_CTL : WDATA_COM Position */
N#define CRC_CTL_WDATA_COM_Msk           (1ul << CRC_CTL_WDATA_COM_Pos)          /*!< CRC CRC_CTL : WDATA_COM Mask */
N
N#define CRC_CTL_CHECKSUM_RVS_Pos        25                                      /*!< CRC CRC_CTL : CHECKSUM_RVS Position */
N#define CRC_CTL_CHECKSUM_RVS_Msk        (1ul << CRC_CTL_CHECKSUM_RVS_Pos)       /*!< CRC CRC_CTL : CHECKSUM_RVS Mask */
N
N#define CRC_CTL_WDATA_RVS_Pos           24                                      /*!< CRC CRC_CTL : WDATA_RVS Position */
N#define CRC_CTL_WDATA_RVS_Msk           (1ul << CRC_CTL_WDATA_RVS_Pos)          /*!< CRC CRC_CTL : WDATA_RVS Mask */
N
N#define CRC_CTL_TRIG_EN_Pos             23                                      /*!< CRC CRC_CTL : TRIG_EN Position */
N#define CRC_CTL_TRIG_EN_Msk             (1ul << CRC_CTL_TRIG_EN_Pos)            /*!< CRC CRC_CTL : TRIG_EN Mask */
N    
N#define CRC_CTL_CRC_RST_Pos             1                                       /*!< CRC CRC_CTL : CRC_RST Position */
N#define CRC_CTL_CRC_RST_Msk             (1ul << CRC_CTL_CRC_RST_Pos)            /*!< CRC CRC_CTL : CRC_RST Mask */
N
N#define CRC_CTL_CRCCEN_Pos              0                                       /*!< CRC CRC_CTL : CRCCEN Position */
N#define CRC_CTL_CRCCEN_Msk              (1ul << CRC_CTL_CRCCEN_Pos)             /*!< CRC CRC_CTL : CRCCEN Mask */
N
N/* CRC DMASAR Bit Field Definitions */
N#define CRC_DMASAR_CRC_DMASAR_Pos       0                                               /*!< CRC CRC_DMASAR : CRC_DMASAR Position */
N#define CRC_DMASAR_CRC_DMASAR_Msk       (0xFFFFFFFFul << CRC_DMASAR_CRC_DMASAR_Pos)     /*!< CRC CRC_DMASAR : CRC_DMASAR Mask */
N
N/* CRC DMABCR Bit Field Definitions */
N#define CRC_DMABCR_CRC_DMABCR_Pos       0                                               /*!< CRC CRC_DMABCR : CRC_DMABCR Position */
N#define CRC_DMABCR_CRC_DMABCR_Msk       (0xFFFFul << CRC_DMABCR_CRC_DMABCR_Pos)         /*!< CRC CRC_DMABCR : CRC_DMABCR Mask */
N
N/* CRC DMACSAR Bit Field Definitions */
N#define CRC_DMACSAR_CRC_DMACSAR_Pos     0                                               /*!< CRC CRC_DMACSAR : CRC_DMACSAR Position */
N#define CRC_DMACSAR_CRC_DMACSAR_Msk     (0xFFFFFFFFul << CRC_DMACSAR_CRC_DMACSAR_Pos)   /*!< CRC CRC_DMACSAR : CRC_DMACSAR Mask */
N
N/* CRC DMACBCR Bit Field Definitions */
N#define CRC_DMACBCR_CRC_DMACBCR_Pos     0                                               /*!< CRC CRC_DMACBCR : DMACBCR Position */
N#define CRC_DMACBCR_CRC_DMACBCR_Msk     (0xFFFFul << CRC_DMACBCR_CRC_DMACBCR_Pos)       /*!< CRC CRC_DMACBCR : DMACBCR Mask */
N
N/* CRC DMAIER Bit Field Definitions */
N#define CRC_DMAIER_CRC_BLKD_IE_Pos      1                                               /*!< CRC CRC_DMAIER : CRC_BLKD_IE Position */
N#define CRC_DMAIER_CRC_BLKD_IE_Msk      (1ul << CRC_DMAIER_CRC_BLKD_IE_Pos)             /*!< CRC CRC_DMAIER : CRC_BLKD_IE Mask */
N
N#define CRC_DMAIER_CRC_TABORT_IE_Pos    0                                               /*!< CRC CRC_DMAIER : CRC_TABORT_IE Position */
N#define CRC_DMAIER_CRC_TABORT_IE_Msk    (1ul << CRC_DMAIER_CRC_TABORT_IE_Pos)           /*!< CRC CRC_DMAIER : CRC_TABORT_IE Mask */
N
N/* CRC DMAISR Bit Field Definitions */
N#define CRC_DMAISR_CRC_BLKD_IF_Pos      1                                               /*!< CRC CRC_DMAISR : CRC_BLKD_IF Position */
N#define CRC_DMAISR_CRC_BLKD_IF_Msk      (1ul << CRC_DMAISR_CRC_BLKD_IF_Pos)             /*!< CRC CRC_DMAISR : CRC_BLKD_IF Mask */
N
N#define CRC_DMAISR_CRC_TABORT_IF_Pos    0                                               /*!< CRC CRC_DMAISR : CRC_TABORT_IF Position */
N#define CRC_DMAISR_CRC_TABORT_IF_Msk    (1ul << CRC_DMAISR_CRC_TABORT_IF_Pos)           /*!< CRC CRC_DMAISR : CRC_TABORT_IF Mask */
N
N/* CRC WDATA Bit Field Definitions */
N#define CRC_WDATA_CRC_WDATA_Pos         0                                               /*!< CRC CRC_WDATA : CRC_WDATA Position */
N#define CRC_WDATA_CRC_WDATA_Msk         (0xFFFFFFFFul << CRC_WDATA_CRC_WDATA_Pos)       /*!< CRC CRC_WDATA : CRC_WDATA Mask */
N
N/* CRC SEED Bit Field Definitions */
N#define CRC_SEED_CRC_SEED_Pos           0                                               /*!< CRC CRC_SEED : CRC_SEED Position */
N#define CRC_SEED_CRC_SEED_Msk           (0xFFFFFFFFul << CRC_SEED_CRC_SEED_Pos)         /*!< CRC CRC_SEED : CRC_SEED Mask */
N
N/* CRC CHECKSUM Bit Field Definitions */
N#define CRC_CHECKSUM_CRC_CHECKSUM_Pos   0                                               /*!< CRC CRC_CHECKSUM : CRC_CHECKSUM Position */
N#define CRC_CHECKSUM_CRC_CHECKSUM_Msk   (0xFFFFFFFFul << CRC_CHECKSUM_CRC_CHECKSUM_Pos) /*!< CRC CRC_CHECKSUM : CRC_CHECKSUM Mask */
N/*@}*/ /* end of group NUC200_CRC */
N
N/*----------------------------- PWM Controller -------------------------------*/
N
N/** @addtogroup NUC200_PWM NUC200 PWM
N  Memory Mapped Structure for NUC200 Series PWM Generator and Capture Timer
N  @{
N */
Ntypedef struct
N{
N    /**
N     * PPR
N     * ===================================================================================================
N     * Offset: 0x00  PWM Pre-Scale Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CP01      |Clock pre-scalar 0(PWM counter 0 & 1 for group A and PWM counter 4 & 5 for group B)
N     * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
N     * |        |          |If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM 
N     * |        |          |counter will be stopped also.
N     * |[15:8]  |CP23      |Clock pre-scalar 2(PWM counter 2 & 3 for group A and PWM counter 6 & 7 for group B)
N     * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
N     * |        |          |If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM 
N     * |        |          |counter will be stopped also.
N     * |[23:16] |DZI01     |Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair 
N     * |        |          |for PWM group A, PWM4 and PWM5 pair for PWM group B)
N     * |        |          |These 8 bits determine dead zone length.
N     * |        |          |The unit time of dead zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK
N     * |        |          |where xy, could be 01 or 45, depends on selected PWM channel.
N     * |[31:24] |DZI23     |Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair 
N     * |        |          |for PWM group A, PWM6 and PWM7 pair for PWM group B)
N     * |        |          |These 8 bits determine dead zone length.
N     * |        |          |The unit time of dead zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK
N     * |        |          |where xy, could be 23 or 67, depends on selected PWM channel.
N     */    
N    __IO uint32_t PPR;
X    volatile uint32_t PPR;
N
N    /**
N     * CSR
N     * ===================================================================================================
N     * Offset: 0x04  PWM Clock Source Divider Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |(Table is the same as CSR3)
N     * |[6:4]   |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |(Table is the same as CSR3)
N     * |[10:8]  |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |(Table is the same as CSR3)
N     * |[14:12] |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
N     * |        |          |Select clock input for timer.
N     * |        |          |CSRx[2:0] = Input clock divider
N     * |        |          |100 = 1
N     * |        |          |011 = 16
N     * |        |          |010 = 8
N     * |        |          |001 = 4
N     * |        |          |000 = 2
N     */    
N    __IO uint32_t CSR;
X    volatile uint32_t CSR;
N
N    /**
N     * PCR
N     * ===================================================================================================
N     * Offset: 0x08  PWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CH0EN     |PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.
N     * |[4]     |DZEN01    |Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A, 
N     * |        |          |PWM4 and PWM5 pair for PWM group B)
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a 
N     * |        |          |complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a 
N     * |        |          |complementary pair for PWM group B.
N     * |[5]     |DZEN23    |Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A, 
N     * |        |          |PWM6 and PWM7 pair for PWM group B)
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable
N     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a 
N     * |        |          |complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a 
N     * |        |          |complementary pair for PWM group B.
N     * |[8]     |CH1EN     |PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[10]    |CH1INV    |PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[11]    |CH1MOD    |PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.
N     * |[16]    |CH2EN     |PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[18]    |CH2INV    |PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[19]    |CH2MOD    |PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.
N     * |[24]    |CH3EN     |PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for 
N     * |        |          |group B)
N     * |        |          |1 = Enable corresponding PWM-Timer Start Run
N     * |        |          |0 = Stop corresponding PWM-Timer Running
N     * |[26]    |CH3INV    |PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for 
N     * |        |          |group B)
N     * |        |          |1 = Inverter ON
N     * |        |          |0 = Inverter OFF
N     * |[27]    |CH3MOD    |PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7 
N     * |        |          |for group B)
N     * |        |          |1 = Auto-reload Mode
N     * |        |          |0 = One-Shot Mode
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.
N     */    
N    __IO uint32_t PCR;
X    volatile uint32_t PCR;
N
N    /**
N     * CNR0
N     * ===================================================================================================
N     * Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR0;
X    volatile uint32_t CNR0;
N
N    /**
N     * CMR0
N     * ===================================================================================================
N     * Offset: 0x10  PWM Comparator 0 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR0;
X    volatile uint32_t CMR0;
N
N    /**
N     * PDR0
N     * ===================================================================================================
N     * Offset: 0x14  PWM Data 0 Register(current counter 0 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR0;
X    volatile const  uint32_t PDR0;
N
N    /**
N     * CNR1
N     * ===================================================================================================
N     * Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR1;
X    volatile uint32_t CNR1;
N
N    /**
N     * CMR1
N     * ===================================================================================================
N     * Offset: 0x1C  PWM Comparator 1 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR1;
X    volatile uint32_t CMR1;
N
N    /**
N     * PDR1
N     * ===================================================================================================
N     * Offset: 0x20  PWM Data 1 Register(current counter 1 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR1;
X    volatile const  uint32_t PDR1;
N
N    /**
N     * CNR2
N     * ===================================================================================================
N     * Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR2;
X    volatile uint32_t CNR2;
N
N    /**
N     * CMR2
N     * ===================================================================================================
N     * Offset: 0x28  PWM Comparator 2 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR2;
X    volatile uint32_t CMR2;
N
N    /**
N     * PDR2
N     * ===================================================================================================
N     * Offset: 0x2C  PWM Data 2 Register(current counter 2 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR2;
X    volatile const  uint32_t PDR2;
N
N    /**
N     * CNR3
N     * ===================================================================================================
N     * Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNR       | 
N     * |        |          |PWM Counter/Timer Loaded Value 
N     * |        |          |CNR determines the PWM period. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CNR3;
X    volatile uint32_t CNR3;
N
N    /**
N     * CMR3
N     * ===================================================================================================
N     * Offset: 0x34  PWM Comparator 3 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMR       | 
N     * |        |          |PWM Comparator Register 
N     * |        |          |CNR determines the PWM duty. 
N     * |        |          | 
N     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
N     * |        |          |45 or 67, depends on selected PWM channel. 
N     * |        |          | 
N     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
N     * |        |          | 
N     * |        |          |CMR >= CNR: PWM output is always high. 
N     * |        |          | 
N     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
N     * |        |          | 
N     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
N     * |        |          | 
N     * |        |          |(Unit = one PWM clock cycle) 
N     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N     */    
N    __IO uint32_t CMR3;
X    volatile uint32_t CMR3;
N
N    /**
N     * PDR3
N     * ===================================================================================================
N     * Offset: 0x38  PWM Data 3 Register(current counter 3 value)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PDR       | 
N     * |        |          |PWM Data Register 
N     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
N     */    
N    __I  uint32_t PDR3;
X    volatile const  uint32_t PDR3;
N
N    /**
N     * PBCR
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t PBCR;
X    volatile uint32_t PBCR;
N
N    /**
N     * PIER
N     * ===================================================================================================
N     * Offset: 0x40  PWM Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWMIE0    |PWM channel 0 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     * |[1]     |PWMIE1    |PWM channel 1 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     * |[2]     |PWMIE2    |PWM channel 2 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     * |[3]     |PWMIE3    |PWM channel 3 Interrupt Enable
N     * |        |          |1 = Enable
N     * |        |          |0 = Disable 
N     */    
N    __IO uint32_t PIER;
X    volatile uint32_t PIER;
N
N    /**
N     * PIIR
N     * ===================================================================================================
N     * Offset: 0x44  PWM Interrupt Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWMIF0    |PWM channel 0 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM0 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     * |[1]     |PWMIF1    |PWM channel 1 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM1 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     * |[2]     |PWMIF2    |PWM channel 2 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM2 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     * |[3]     |PWMIF3    |PWM channel 3 Interrupt Status
N     * |        |          |Flag is set by hardware when PWM3 down counter reaches zero, software can clear this 
N     * |        |          |bit by writing a one to it.
N     */    
N    __IO uint32_t PIIR;
X    volatile uint32_t PIIR;
N
N    /**
N     * RESERVE1
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __I uint32_t    RESERVE1[2];
X    volatile const uint32_t    RESERVE1[2];
N
N    /**
N     * CCR0
N     * ===================================================================================================
N     * Offset: 0x50  Capture 0/1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INV0      | 
N     * |        |          |PWM Group Channel 0 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[1]     |CRL_IE0   |PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 0 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[2]     |CFL_IE0   |PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 0 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[3]     |CAPCH0EN  |Capture Channel 0 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 0.
N     * |        |          |0 = Disable capture function on PWM group channel 0
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 0 Interrupt.
N     * |[4]     |CAPIF0    | 
N     * |        |          |Capture0 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs 
N     * |        |          |at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[6]     |CRLRI0    | 
N     * |        |          |CRLR0 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[7]     |CFLRI0    | 
N     * |        |          |CFLR0 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[16]    |INV1      | 
N     * |        |          |PWM Group Channel 1 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[17]    |CRL_IE1   |PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 1 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[18]    |CFL_IE1   |PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 1 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[19]    |CAPCH1EN  |Capture Channel 1 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 1.
N     * |        |          |0 = Disable capture function on PWM group channel 1
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 1 Interrupt.
N     * |[20]    |CAPIF1    | 
N     * |        |          |Capture1 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs 
N     * |        |          |at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[22]    |CRLRI1    | 
N     * |        |          |CRLR1 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[23]    |CFLRI1    | 
N     * |        |          |CFLR1 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     */    
N    __IO uint32_t CCR0;
X    volatile uint32_t CCR0;
N
N    /**
N     * CCR2
N     * ===================================================================================================
N     * Offset: 0x54  Capture 2/3 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INV2      | 
N     * |        |          |PWM Group Channel 2 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[1]     |CRL_IE2   |PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 2 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[2]     |CFL_IE2   |PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 2 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[3]     |CAPCH2EN  |Capture Channel 2 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 2.
N     * |        |          |0 = Disable capture function on PWM group channel 2
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 2 Interrupt.
N     * |[4]     |CAPIF2    | 
N     * |        |          |Capture2 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs 
N     * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[6]     |CRLRI2    | 
N     * |        |          |CRLR2 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[7]     |CFLRI2    | 
N     * |        |          |CFLR2 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[16]    |INV3      | 
N     * |        |          |PWM Group Channel 3 Inverter ON/OFF 
N     * |        |          | 
N     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
N     * |        |          |0 = Inverter OFF
N     * |[17]    |CRL_IE3   |PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable rising latch interrupt
N     * |        |          |0 = Disable rising latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 3 has rising transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[18]    |CFL_IE3   |PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
N     * |        |          |1 = Enable falling latch interrupt
N     * |        |          |0 = Disable falling latch interrupt
N     * |        |          |When Enable, if Capture detects PWM group channel 3 has falling transition, Capture 
N     * |        |          |issues an Interrupt.
N     * |[19]    |CAPCH3EN  |Capture Channel 3 transition Enable/Disable
N     * |        |          |1 = Enable capture function on PWM group channel 3.
N     * |        |          |0 = Disable capture function on PWM group channel 3
N     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
N     * |        |          |latch) and CFLR (Falling latch).
N     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
N     * |        |          |channel 3 Interrupt.
N     * |[20]    |CAPIF3    | 
N     * |        |          |Capture3 Interrupt Indication Flag 
N     * |        |          | 
N     * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs 
N     * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause 
N     * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1). 
N     * |        |          |This flag is clear by software with a write 1 to itself.
N     * |[22]    |CRLRI3    | 
N     * |        |          |CRLR3 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     * |[23]    |CFLRI3    | 
N     * |        |          |CFLR3 Latched Indicator Bit 
N     * |        |          | 
N     * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of 
N     * |        |          |PWM down-counter and this bit is set by hardware. 
N     * |        |          | 
N     * |        |          |Clear this bit by writing a one to it.
N     */    
N    __IO uint32_t CCR2;
X    volatile uint32_t CCR2;
N
N    /**
N     * CRLR0
N     * ===================================================================================================
N     * Offset: 0x58  Capture 0 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR0;
X    volatile uint32_t CRLR0;
N
N    /**
N     * CFLR0
N     * ===================================================================================================
N     * Offset: 0x5C  Capture 0 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR0;
X    volatile uint32_t CFLR0;
N
N    /**
N     * CRLR1
N     * ===================================================================================================
N     * Offset: 0x60  Capture 1 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR1;
X    volatile uint32_t CRLR1;
N
N    /**
N     * CFLR1
N     * ===================================================================================================
N     * Offset: 0x64  Capture 1 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR1;
X    volatile uint32_t CFLR1;
N
N    /**
N     * CRLR2
N     * ===================================================================================================
N     * Offset: 0x68  Capture 2 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR2;
X    volatile uint32_t CRLR2;
N
N    /**
N     * CFLR2
N     * ===================================================================================================
N     * Offset: 0x6C  Capture 2 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR2;
X    volatile uint32_t CFLR2;
N
N    /**
N     * CRLR3
N     * ===================================================================================================
N     * Offset: 0x70  Capture 3 Rising Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CRLR      |Capture Rising Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N     */    
N    __IO uint32_t CRLR3;
X    volatile uint32_t CRLR3;
N
N    /**
N     * CFLR3
N     * ===================================================================================================
N     * Offset: 0x74  Capture 3 Falling Latch Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CFLR      |Capture Falling Latch Register
N     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N     */    
N    __IO uint32_t CFLR3;
X    volatile uint32_t CFLR3;
N
N    /**
N     * CAPENR
N     * ===================================================================================================
N     * Offset: 0x78  Capture Input Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |CAPENR    |Capture Input Enable Register
N     * |        |          |There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or 
N     * |        |          |OFF. 
N     * |        |          |0 = OFF (PWMx multi-function pin input does not affect input capture function.)
N     * |        |          |1 = (PWMx multi-function pin input will affect its input capture function.)
N     * |        |          |CAPENR
N     * |        |          |Bit 3210 for PWM group A
N     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [0] 
N     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [1] 
N     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [2]
N     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [3]
N     * |        |          |Bit 3210 for PWM group B
N     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [4] 
N     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [5] 
N     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [6]
N     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [7]
N     */    
N    __IO uint32_t CAPENR;
X    volatile uint32_t CAPENR;
N
N    /**
N     * POE
N     * ===================================================================================================
N     * Offset: 0x7C  PWM Output Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWM0      |PWM Channel 0 Output Enable Register
N     * |        |          |1 = Enable PWM channel 0 output to pin.
N     * |        |          |0 = Disable PWM channel 0 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     * |[1]     |PWM1      |PWM Channel 1 Output Enable Register
N     * |        |          |1 = Enable PWM channel 1 output to pin.
N     * |        |          |0 = Disable PWM channel 1 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     * |[2]     |PWM2      |PWM Channel 2 Output Enable Register
N     * |        |          |1 = Enable PWM channel 2 output to pin.
N     * |        |          |0 = Disable PWM channel 2 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     * |[3]     |PWM3      |PWM Channel 3 Output Enable Register
N     * |        |          |1 = Enable PWM channel 3 output to pin.
N     * |        |          |0 = Disable PWM channel 3 output to pin.
N     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
N     */    
N    __IO uint32_t POE;
X    volatile uint32_t POE;
N
N    /**
N     * TCON
N     * ===================================================================================================
N     * Offset: 0x80  PWM Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TCON;
X    volatile uint32_t TCON;
N
N    /**
N     * TSTATUS
N     * ===================================================================================================
N     * Offset: 0x84  PWM Trigger Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */    
N    __IO uint32_t TSTATUS;
X    volatile uint32_t TSTATUS;
N
N    /**
N     * SYNCBUSY0
N     * ===================================================================================================
N     * Offset: 0x88  PWM0 Synchronous Busy Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */     
N    __IO uint32_t  SYNCBUSY0;
X    volatile uint32_t  SYNCBUSY0;
N
N    /**
N     * SYNCBUSY0
N     * ===================================================================================================
N     * Offset: 0x8C  PWM1 Synchronous Busy Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */     
N    __IO uint32_t  SYNCBUSY1;
X    volatile uint32_t  SYNCBUSY1;
N    
N    /**
N     * SYNCBUSY0
N     * ===================================================================================================
N     * Offset: 0x90  PWM2 Synchronous Busy Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */     
N    __IO uint32_t  SYNCBUSY2;
X    volatile uint32_t  SYNCBUSY2;
N    
N    /**
N     * SYNCBUSY0
N     * ===================================================================================================
N     * Offset: 0x94  PWM3 Synchronous Busy Status Register
N     * ---------------------------------------------------------------------------------------------------
N     */     
N    __IO uint32_t  SYNCBUSY3;
X    volatile uint32_t  SYNCBUSY3;
N                    
N} PWM_T;
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM PPR: DZI23 Position */
N#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM PPR: DZI23 Mask */
N
N#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM PPR: DZI01 Position */
N#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM PPR: DZI01 Mask */
N
N#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM PPR: CP23 Position */
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM PPR: CP23 Mask */
N
N#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM PPR: CP01 Position */
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM PPR: CP01 Mask */
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM CSR: CSR3 Position */
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM CSR: CSR3 Mask */
N
N#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM CSR: CSR2 Position */
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM CSR: CSR2 Mask */
N
N#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM CSR: CSR1 Position */
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM CSR: CSR1 Mask */
N
N#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM CSR: CSR0 Position */
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM CSR: CSR0 Mask */
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM PCR: PWM23TYPE Position */
N#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM PCR: PWM23TYPE Mask */
N
N#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM PCR: PWM01TYPE Position */
N#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM PCR: PWM01TYPE Mask */
N
N#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM PCR: CH3MOD Position */
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM PCR: CH3MOD Mask */
N
N#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM PCR: CH3INV Position */
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM PCR: CH3INV Mask */
N
N#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM PCR: CH3PINV Position */
N#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM PCR: CH3PINV Mask */
N
N#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM PCR: CH3EN Position */
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM PCR: CH3EN Mask */
N
N#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM PCR: CH2MOD Position */
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM PCR: CH2MOD Mask */
N
N#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM PCR: CH2INV Position */
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM PCR: CH2INV Mask */
N
N#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM PCR: CH2PINV Position */
N#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM PCR: CH2PINV Mask */
N
N#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM PCR: CH2EN Position */
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM PCR: CH2EN Mask */
N
N#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM PCR: CH1MOD Position */
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM PCR: CH1MOD Mask */
N
N#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM PCR: CH1INV Position */
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM PCR: CH1INV Mask */
N
N#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM PCR: CH1PINV Position */
N#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM PCR: CH1PINV Mask */
N
N#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM PCR: CH1EN Position */
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM PCR: CH1EN Mask */
N
N#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM PCR: DZEN23 Position */
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM PCR: DZEN23 Mask */
N
N#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM PCR: DZEN01 Position */
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM PCR: DZEN01 Mask */
N
N#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM PCR: CH0MOD Position */
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM PCR: CH0MOD Mask */
N
N#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM PCR: CH0INV Position */
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM PCR: CH0INV Mask */
N
N#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM PCR: CH0PINV Position */
N#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM PCR: CH0PINV Mask */
N
N#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM PCR: CH0EN Position */
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM PCR: CH0EN Mask */
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM CNR: CNR Position */
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM CNR: CNR Mask */
N
N/* PWM CMR Bit Field Definitions */
N#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM CMR: CMR Position */
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM CMR: CMR Mask */
N
N/* PWM PDR Bit Field Definitions */
N#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM PDR: PDR Position */
N#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM PDR: PDR Mask */
N
N/* PWM PBCR Bit Field Definitions */
N#define PWM_PBCR_BCn_Pos                         0                                  /*!< PWM PBCR: BCn Position */
N#define PWM_PBCR_BCn_Msk                         (1ul << PWM_PBCR_BCn_Pos)          /*!< PWM PBCR: BCn Mask */
N
N/* PWM PIER Bit Field Definitions */
N
N#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM PIER: INT23TYPE Position */
N#define PWM_PIER_INT23TYPE_Msk                     (1ul << PWM_PIER_INT23TYPE_Pos)  /*!< PWM PIER: INT23TYPE Mask */
N
N#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM PIER: INT01TYPE Position */
N#define PWM_PIER_INT01TYPE_Msk                     (1ul << PWM_PIER_INT01TYPE_Pos)  /*!< PWM PIER: INT01TYPE Mask */
N
N#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM PIER: PWMDIE3 Position */
N#define PWM_PIER_PWMDIE3_Msk                     (1ul << PWM_PIER_PWMDIE3_Pos)      /*!< PWM PIER: PWMDIE3 Mask */
N
N#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM PIER: PWMDIE2 Position */
N#define PWM_PIER_PWMDIE2_Msk                     (1ul << PWM_PIER_PWMDIE2_Pos)      /*!< PWM PIER: PWMDIE2 Mask */
N
N#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM PIER: PWMDIE1 Position */
N#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM PIER: PWMDIE1 Mask */
N
N#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM PIER: PWMDIE0 Position */
N#define PWM_PIER_PWMDIE0_Msk                     (1ul << PWM_PIER_PWMDIE0_Pos)      /*!< PWM PIER: PWMDIE0 Mask */
N
N#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM PIER: PWMIE3 Position */
N#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM PIER: PWMIE3 Mask */
N
N#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM PIER: PWMIE2 Position */
N#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM PIER: PWMIE2 Mask */
N
N#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM PIER: PWMIE1 Position */
N#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM PIER: PWMIE1 Mask */
N
N#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM PIER: PWMIE0 Position */
N#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM PIER: PWMIE0 Mask */
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM PIIR: PWMDIF3 Position */
N#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM PIIR: PWMDIF3 Mask */
N
N#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM PIIR: PWMDIF2 Position */
N#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM PIIR: PWMDIF2 Mask */
N
N#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM PIIR: PWMDIF1 Position */
N#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM PIIR: PWMDIF1 Mask */
N
N#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM PIIR: PWMDIF0 Position */
N#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM PIIR: PWMDIF0 Mask */
N
N#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM PIIR: PWMIF3 Position */
N#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM PIIR: PWMIF3 Mask */
N
N#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM PIIR: PWMIF2 Position */
N#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM PIIR: PWMIF2 Mask */
N
N#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM PIIR: PWMIF1 Position */
N#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM PIIR: PWMIF1 Mask */
N
N#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM PIIR: PWMIF0 Position */
N#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM PIIR: PWMIF0 Mask */
N
N/* PWM CCR0 Bit Field Definitions */
N#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM CCR0: CFLRI1 Position */
N#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM CCR0: CFLRI1 Mask */
N
N#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM CCR0: CRLRI1 Position */
N#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM CCR0: CRLRI1 Mask */
N
N#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM CCR0: CAPIF1 Position */
N#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM CCR0: CAPIF1 Mask */
N
N#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM CCR0: CAPCH1EN Position */
N#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM CCR0: CAPCH1EN Mask */
N
N#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM CCR0: CFL_IE1 Position */
N#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM CCR0: CFL_IE1 Mask */
N
N#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM CCR0: CRL_IE1 Position */
N#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM CCR0: CRL_IE1 Mask */
N
N#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM CCR0: INV1 Position */
N#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM CCR0: INV1 Mask */
N
N#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM CCR0: CFLRI0 Position */
N#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM CCR0: CFLRI0 Mask */
N
N#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM CCR0: CRLRI0 Position */
N#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM CCR0: CRLRI0 Mask */
N
N#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM CCR0: CAPIF0 Position */
N#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM CCR0: CAPIF0 Mask */
N
N#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM CCR0: CAPCH0EN Position */
N#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM CCR0: CAPCH0EN Mask */
N
N#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM CCR0: CFL_IE0 Position */
N#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM CCR0: CFL_IE0 Mask */
N
N#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM CCR0: CRL_IE0 Position */
N#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM CCR0: CRL_IE0 Mask */
N
N#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM CCR0: INV0 Position */
N#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM CCR0: INV0 Mask */
N
N/* PWM CCR2 Bit Field Definitions */
N#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM CCR2: CFLRI3 Position */
N#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM CCR2: CFLRI3 Mask */
N
N#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM CCR2: CRLRI3 Position */
N#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM CCR2: CRLRI3 Mask */
N
N#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM CCR2: CAPIF3 Position */
N#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM CCR2: CAPIF3 Mask */
N
N#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM CCR2: CAPCH3EN Position */
N#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM CCR2: CAPCH3EN Mask */
N
N#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM CCR2: CFL_IE3 Position */
N#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM CCR2: CFL_IE3 Mask */
N
N#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM CCR2: CRL_IE3 Position */
N#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM CCR2: CRL_IE3 Mask */
N
N#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM CCR2: INV3 Position */
N#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM CCR2: INV3 Mask */
N
N#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM CCR2: CFLRI2 Position */
N#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM CCR2: CFLRI2 Mask */
N
N#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM CCR2: CRLRI2 Position */
N#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM CCR2: CRLRI2 Mask */
N
N#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM CCR2: CAPIF2 Position */
N#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM CCR2: CAPIF2 Mask */
N
N#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM CCR2: CAPCH2EN Position */
N#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM CCR2: CAPCH2EN Mask */
N
N#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM CCR2: CFL_IE2 Position */
N#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM CCR2: CFL_IE2 Mask */
N
N#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM CCR2: CRL_IE2 Position */
N#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM CCR2: CRL_IE2 Mask */
N
N#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM CCR2: INV2 Position */
N#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM CCR2: INV2 Mask */
N
N/* PWM CRLR Bit Field Definitions */
N#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM CRLR: CRLR Position */
N#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM CRLR: CRLR Mask */
N
N/* PWM CFLR Bit Field Definitions */
N#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM CFLR: CFLR Position */
N#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM CFLR: CFLR Mask */
N
N/* PWM CAPENR Bit Field Definitions */
N#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM CAPENR: CINEN3 Position */
N#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM CAPENR: CINEN3 Mask */   
N
N#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM CAPENR: CINEN2 Position */
N#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM CAPENR: CINEN2 Mask */  
N
N#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM CAPENR: CINEN1 Position */
N#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM CAPENR: CINEN1 Mask */  
N
N#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM CAPENR: CINEN0 Position */
N#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM CAPENR: CINEN0 Mask */ 
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_POE3_Pos                        3                                   /*!< PWM POE: POE3 Position */
N#define PWM_POE_POE3_Msk                        (1ul << PWM_POE_POE3_Pos)           /*!< PWM POE: POE3 Mask */   
N
N#define PWM_POE_POE2_Pos                        2                                   /*!< PWM POE: POE2 Position */
N#define PWM_POE_POE2_Msk                        (1ul << PWM_POE_POE2_Pos)           /*!< PWM POE: POE2 Mask */  
N
N#define PWM_POE_POE1_Pos                        1                                   /*!< PWM POE: POE1 Position */
N#define PWM_POE_POE1_Msk                        (1ul << PWM_POE_POE1_Pos)           /*!< PWM POE: POE1 Mask */  
N
N#define PWM_POE_POE0_Pos                        0                                   /*!< PWM POE: POE0 Position */
N#define PWM_POE_POE0_Msk                        (1ul << PWM_POE_POE0_Pos)           /*!< PWM POE: POE0 Mask */  
N
N/* PWM TCON Bit Field Definitions */
N
N#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM TCON: PWM3TEN Position */
N#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM TCON: PWM3TEN Mask */ 
N
N#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM TCON: PWM2TEN Position */
N#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM TCON: PWM2TEN Mask */ 
N
N#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM TCON: PWM1TEN Position */
N#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM TCON: PWM1TEN Mask */ 
N
N#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM TCON: PWM0TEN Position */
N#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM TCON: PWM0TEN Mask */ 
N
N/* PWM TSTATUS Bit Field Definitions */
N
N#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM TSTATUS: PWM3TF Position */
N#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM TSTATUS: PWM3TF Mask */ 
N
N#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM TSTATUS: PWM2TF Position */
N#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM TSTATUS: PWM2TF Mask */ 
N
N#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM TSTATUS: PWM1TF Position */
N#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM TSTATUS: PWM1TF Mask */ 
N
N#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM TSTATUS: PWM0TF Position */
N#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM TSTATUS: PWM0TF Mask */ 
N
N/* PWM SYNCBUSY0 Bit Field Definitions */
N#define PWM_SYNCBUSY0_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY0: S_BUSY Position */
N#define PWM_SYNCBUSY0_S_BUSY_Msk                (1ul << PWM_SYNCBUSY0_S_BUSY_Pos)   /*!< PWM SYNCBUSY0: S_BUSY Mask */ 
N
N/* PWM SYNCBUSY1 Bit Field Definitions */
N#define PWM_SYNCBUSY1_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY1: S_BUSY Position */
N#define PWM_SYNCBUSY1_S_BUSY_Msk                (1ul << PWM_SYNCBUSY1_S_BUSY_Pos)   /*!< PWM SYNCBUSY1: S_BUSY Mask */ 
N
N/* PWM SYNCBUSY2 Bit Field Definitions */
N#define PWM_SYNCBUSY2_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY2: S_BUSY Position */
N#define PWM_SYNCBUSY2_S_BUSY_Msk                (1ul << PWM_SYNCBUSY2_S_BUSY_Pos)   /*!< PWM SYNCBUSY2: S_BUSY Mask */ 
N
N/* PWM SYNCBUSY3 Bit Field Definitions */
N#define PWM_SYNCBUSY3_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY3: S_BUSY Position */
N#define PWM_SYNCBUSY3_S_BUSY_Msk                (1ul << PWM_SYNCBUSY3_S_BUSY_Pos)   /*!< PWM SYNCBUSY3: S_BUSY Mask */ 
N/*@}*/ /* end of group NUC200_PWM */
N
N
N/*----------------------------- I2S Controller -------------------------------*/
N/** @addtogroup NUC200_I2S NUC200 I2S
N  Memory Mapped Structure for NUC200 Series I2S Interface Controller
N  @{
N */
Ntypedef struct
N{
N    __IO uint32_t CON;                /*!< Offset: 0x00  I2S Control Register               */
X    volatile uint32_t CON;                 
N    __IO uint32_t CLKDIV;             /*!< Offset: 0x04  I2S Clock Divider Register         */
X    volatile uint32_t CLKDIV;              
N    __IO uint32_t IE;                 /*!< Offset: 0x08  I2S Interrupt Enable Register      */
X    volatile uint32_t IE;                  
N    __I  uint32_t STATUS;             /*!< Offset: 0x0C  I2S Status Register                */
X    volatile const  uint32_t STATUS;              
N    __O  uint32_t TXFIFO;             /*!< Offset: 0x10  I2S Transmit FIFO Register         */
X    volatile  uint32_t TXFIFO;              
N    __I  uint32_t RXFIFO;             /*!< Offset: 0x14  I2S Receive FIFO Register          */
X    volatile const  uint32_t RXFIFO;              
N} I2S_T;
N
N
N/* I2S I2SCON Bit Field Definitions */
N#define I2S_CON_RXLCH_Pos                    23                                   /*!< I2S I2SCON: RXLCH Position         */
N#define I2S_CON_RXLCH_Msk                    (1ul << I2S_CON_RXLCH_Pos)           /*!< I2S I2SCON: RXLCH Mask             */
N
N#define I2S_CON_RXDMA_Pos                    21                                   /*!< I2S I2SCON: RXDMA Position         */
N#define I2S_CON_RXDMA_Msk                    (1ul << I2S_CON_RXDMA_Pos)           /*!< I2S I2SCON: RXDMA Mask             */
N
N#define I2S_CON_TXDMA_Pos                    20                                   /*!< I2S I2SCON: TXDMA Position         */
N#define I2S_CON_TXDMA_Msk                    (1ul << I2S_CON_TXDMA_Pos)           /*!< I2S I2SCON: TXDMA Mask             */
N
N#define I2S_CON_CLR_RXFIFO_Pos               19                                   /*!< I2S I2SCON: CLR_RXFIFO Position    */
N#define I2S_CON_CLR_RXFIFO_Msk               (1ul << I2S_CON_CLR_RXFIFO_Pos)      /*!< I2S I2SCON: CLR_RXFIFO Mask        */
N
N#define I2S_CON_CLR_TXFIFO_Pos               18                                   /*!< I2S I2SCON: CLR_TXFIFO Position    */
N#define I2S_CON_CLR_TXFIFO_Msk               (1ul << I2S_CON_CLR_TXFIFO_Pos)      /*!< I2S I2SCON: CLR_TXFIFO Mask        */
N
N#define I2S_CON_LCHZCEN_Pos                  17                                   /*!< I2S I2SCON: LCHZCEN Position       */
N#define I2S_CON_LCHZCEN_Msk                  (1ul << I2S_CON_LCHZCEN_Pos)         /*!< I2S I2SCON: LCHZCEN Mask           */
N
N#define I2S_CON_RCHZCEN_Pos                  16                                   /*!< I2S I2SCON: RCHZCEN Position       */
N#define I2S_CON_RCHZCEN_Msk                  (1ul << I2S_CON_RCHZCEN_Pos)         /*!< I2S I2SCON: RCHZCEN Mask           */
N
N#define I2S_CON_MCLKEN_Pos                   15                                   /*!< I2S I2SCON: MCLKEN Position        */
N#define I2S_CON_MCLKEN_Msk                   (1ul << I2S_CON_MCLKEN_Pos)          /*!< I2S I2SCON: MCLKEN Mask            */
N
N#define I2S_CON_RXTH_Pos                     12                                   /*!< I2S I2SCON: RXTH Position          */
N#define I2S_CON_RXTH_Msk                     (7ul << I2S_CON_RXTH_Pos)            /*!< I2S I2SCON: RXTH Mask              */
N
N#define I2S_CON_TXTH_Pos                     9                                    /*!< I2S I2SCON: TXTH Position          */
N#define I2S_CON_TXTH_Msk                     (7ul << I2S_CON_TXTH_Pos)            /*!< I2S I2SCON: TXTH Mask              */
N
N#define I2S_CON_SLAVE_Pos                    8                                    /*!< I2S I2SCON: SLAVE Position         */
N#define I2S_CON_SLAVE_Msk                    (1ul << I2S_CON_SLAVE_Pos)           /*!< I2S I2SCON: SLAVE Mask             */
N
N#define I2S_CON_FORMAT_Pos                   7                                    /*!< I2S I2SCON: FORMAT Position        */
N#define I2S_CON_FORMAT_Msk                   (1ul << I2S_CON_FORMAT_Pos)          /*!< I2S I2SCON: FORMAT Mask            */
N
N#define I2S_CON_MONO_Pos                     6                                    /*!< I2S I2SCON: MONO Position          */
N#define I2S_CON_MONO_Msk                     (1ul << I2S_CON_MONO_Pos)            /*!< I2S I2SCON: MONO Mask              */
N
N#define I2S_CON_WORDWIDTH_Pos                4                                    /*!< I2S I2SCON: WORDWIDTH Position     */
N#define I2S_CON_WORDWIDTH_Msk                (3ul << I2S_CON_WORDWIDTH_Pos)       /*!< I2S I2SCON: WORDWIDTH Mask         */
N
N#define I2S_CON_MUTE_Pos                     3                                    /*!< I2S I2SCON: MUTE Position          */
N#define I2S_CON_MUTE_Msk                     (1ul << I2S_CON_MUTE_Pos)            /*!< I2S I2SCON: MUTE Mask              */
N
N#define I2S_CON_RXEN_Pos                     2                                    /*!< I2S I2SCON: RXEN Position          */
N#define I2S_CON_RXEN_Msk                     (1ul << I2S_CON_RXEN_Pos)            /*!< I2S I2SCON: RXEN Mask              */
N
N#define I2S_CON_TXEN_Pos                     1                                    /*!< I2S I2SCON: TXEN Position          */
N#define I2S_CON_TXEN_Msk                     (1ul << I2S_CON_TXEN_Pos)            /*!< I2S I2SCON: TXEN Mask              */
N
N#define I2S_CON_I2SEN_Pos                    0                                    /*!< I2S I2SCON: I2SEN Position         */
N#define I2S_CON_I2SEN_Msk                    (1ul << I2S_CON_I2SEN_Pos)           /*!< I2S I2SCON: I2SEN Mask             */
N
N/* I2S I2SCLKDIV Bit Field Definitions */
N#define I2S_CLKDIV_BCLK_DIV_Pos              8                                       /*!< I2S I2SCLKDIV: BCLK_DIV Position   */
N#define I2S_CLKDIV_BCLK_DIV_Msk              (0xFFul << I2S_CLKDIV_BCLK_DIV_Pos)  /*!< I2S I2SCLKDIV: BCLK_DIV Mask       */
N
N#define I2S_CLKDIV_MCLK_DIV_Pos              0                                       /*!< I2S I2SCLKDIV: MCLK_DIV Position   */
N#define I2S_CLKDIV_MCLK_DIV_Msk              (7ul << I2S_CLKDIV_MCLK_DIV_Pos)     /*!< I2S I2SCLKDIV: MCLK_DIV Mask       */
N
N/* I2S I2SIE Bit Field Definitions */
N#define I2S_IE_LZCIE_Pos                     12                                      /*!< I2S I2SIE: LZCIE Position          */
N#define I2S_IE_LZCIE_Msk                     (1ul << I2S_IE_LZCIE_Pos)            /*!< I2S I2SIE: LZCIE Mask              */
N
N#define I2S_IE_RZCIE_Pos                     11                                   /*!< I2S I2SIE: RZCIE Position          */
N#define I2S_IE_RZCIE_Msk                     (1ul << I2S_IE_RZCIE_Pos)            /*!< I2S I2SIE: RZCIE Mask              */
N
N#define I2S_IE_TXTHIE_Pos                    10                                   /*!< I2S I2SIE: TXTHIE Position         */
N#define I2S_IE_TXTHIE_Msk                    (1ul << I2S_IE_TXTHIE_Pos)           /*!< I2S I2SIE: TXTHIE Mask             */
N                                     
N#define I2S_IE_TXOVFIE_Pos                   9                                    /*!< I2S I2SIE: TXOVFIE Position        */
N#define I2S_IE_TXOVFIE_Msk                   (1ul << I2S_IE_TXOVFIE_Pos)          /*!< I2S I2SIE: TXOVFIE Mask            */
N
N#define I2S_IE_TXUDFIE_Pos                   8                                    /*!< I2S I2SIE: TXUDFIE Position        */
N#define I2S_IE_TXUDFIE_Msk                   (1ul << I2S_IE_TXUDFIE_Pos)          /*!< I2S I2SIE: TXUDFIE Mask            */
N
N#define I2S_IE_RXTHIE_Pos                    2                                    /*!< I2S I2SIE: RXTHIE Position         */
N#define I2S_IE_RXTHIE_Msk                    (1ul << I2S_IE_RXTHIE_Pos)           /*!< I2S I2SIE: RXTHIE Mask             */
N                                     
N#define I2S_IE_RXOVFIE_Pos                   1                                    /*!< I2S I2SIE: RXOVFIE Position        */
N#define I2S_IE_RXOVFIE_Msk                   (1ul << I2S_IE_RXOVFIE_Pos)          /*!< I2S I2SIE: RXOVFIE Mask            */
N
N#define I2S_IE_RXUDFIE_Pos                   0                                    /*!< I2S I2SIE: RXUDFIE Position        */
N#define I2S_IE_RXUDFIE_Msk                   (1ul << I2S_IE_RXUDFIE_Pos)          /*!< I2S I2SIE: RXUDFIE Mask            */
N
N
N/* I2S I2SSTATUS Bit Field Definitions */
N#define I2S_STATUS_TX_LEVEL_Pos              28                                      /*!< I2S I2SSTATUS: TX_LEVEL Position   */
N#define I2S_STATUS_TX_LEVEL_Msk              (0xFul << I2S_STATUS_TX_LEVEL_Pos)   /*!< I2S I2SSTATUS: TX_LEVEL Mask       */
N
N#define I2S_STATUS_RX_LEVEL_Pos              24                                   /*!< I2S I2SSTATUS: RX_LEVEL Position   */
N#define I2S_STATUS_RX_LEVEL_Msk              (0xFul << I2S_STATUS_RX_LEVEL_Pos)   /*!< I2S I2SSTATUS: RX_LEVEL Mask       */
N
N#define I2S_STATUS_LZCF_Pos                  23                                      /*!< I2S I2SSTATUS: LZCF Position       */
N#define I2S_STATUS_LZCF_Msk                  (1ul << I2S_STATUS_LZCF_Pos)         /*!< I2S I2SSTATUS: LZCF Mask           */
N
N#define I2S_STATUS_RZCF_Pos                  22                                   /*!< I2S I2SSTATUS: RZCF Position       */
N#define I2S_STATUS_RZCF_Msk                  (1ul << I2S_STATUS_RZCF_Pos)         /*!< I2S I2SSTATUS: RZCF Mask           */
N
N#define I2S_STATUS_TXBUSY_Pos                21                                   /*!< I2S I2SSTATUS: TXBUSY Position     */
N#define I2S_STATUS_TXBUSY_Msk                (1ul << I2S_STATUS_TXBUSY_Pos)       /*!< I2S I2SSTATUS: TXBUSY Mask         */
N
N#define I2S_STATUS_TXEMPTY_Pos               20                                   /*!< I2S I2SSTATUS: TXEMPTY Position    */
N#define I2S_STATUS_TXEMPTY_Msk               (1ul << I2S_STATUS_TXEMPTY_Pos)      /*!< I2S I2SSTATUS: TXEMPTY Mask        */
N
N#define I2S_STATUS_TXFULL_Pos                19                                   /*!< I2S I2SSTATUS: TXFULL Position     */
N#define I2S_STATUS_TXFULL_Msk                (1ul << I2S_STATUS_TXFULL_Pos)       /*!< I2S I2SSTATUS: TXFULL Mask         */
N
N#define I2S_STATUS_TXTHF_Pos                 18                                   /*!< I2S I2SSTATUS: TXTHF Position      */
N#define I2S_STATUS_TXTHF_Msk                 (1ul << I2S_STATUS_TXTHF_Pos)        /*!< I2S I2SSTATUS: TXTHF Mask          */
N
N#define I2S_STATUS_TXOVF_Pos                 17                                   /*!< I2S I2SSTATUS: TXOVF Position      */
N#define I2S_STATUS_TXOVF_Msk                 (1ul << I2S_STATUS_TXOVF_Pos)        /*!< I2S I2SSTATUS: TXOVF Mask          */
N
N#define I2S_STATUS_TXUDF_Pos                 16                                   /*!< I2S I2SSTATUS: TXUDF Position      */
N#define I2S_STATUS_TXUDF_Msk                 (1ul << I2S_STATUS_TXUDF_Pos)        /*!< I2S I2SSTATUS: TXUDF Mask          */
N
N#define I2S_STATUS_RXEMPTY_Pos               12                                   /*!< I2S I2SSTATUS: RXEMPTY Position    */
N#define I2S_STATUS_RXEMPTY_Msk               (1ul << I2S_STATUS_RXEMPTY_Pos)      /*!< I2S I2SSTATUS: RXEMPTY Mask        */
N
N#define I2S_STATUS_RXFULL_Pos                11                                   /*!< I2S I2SSTATUS: RXFULL Position     */
N#define I2S_STATUS_RXFULL_Msk                (1ul << I2S_STATUS_RXFULL_Pos)       /*!< I2S I2SSTATUS: RXFULL Mask         */
N
N#define I2S_STATUS_RXTHF_Pos                 10                                   /*!< I2S I2SSTATUS: RXTHF Position      */
N#define I2S_STATUS_RXTHF_Msk                 (1ul << I2S_STATUS_RXTHF_Pos)        /*!< I2S I2SSTATUS: RXTHF Mask          */
N
N#define I2S_STATUS_RXOVF_Pos                 9                                    /*!< I2S I2SSTATUS: RXOVF Position      */
N#define I2S_STATUS_RXOVF_Msk                 (1ul << I2S_STATUS_RXOVF_Pos)        /*!< I2S I2SSTATUS: RXOVF Mask          */
N
N#define I2S_STATUS_RXUDF_Pos                 8                                    /*!< I2S I2SSTATUS: RXUDF Position      */
N#define I2S_STATUS_RXUDF_Msk                 (1ul << I2S_STATUS_RXUDF_Pos)        /*!< I2S I2SSTATUS: RXUDF Mask          */
N
N#define I2S_STATUS_RIGHT_Pos                 3                                    /*!< I2S I2SSTATUS: RIGHT Position      */
N#define I2S_STATUS_RIGHT_Msk                 (1ul << I2S_STATUS_RIGHT_Pos)        /*!< I2S I2SSTATUS: RIGHT Mask          */
N
N#define I2S_STATUS_I2STXINT_Pos              2                                    /*!< I2S I2SSTATUS: I2STXINT Position   */
N#define I2S_STATUS_I2STXINT_Msk              (1ul << I2S_STATUS_I2STXINT_Pos)     /*!< I2S I2SSTATUS: I2STXINT Mask       */
N
N#define I2S_STATUS_I2SRXINT_Pos              1                                    /*!< I2S I2SSTATUS: I2SRXINT Position   */
N#define I2S_STATUS_I2SRXINT_Msk              (1ul << I2S_STATUS_I2SRXINT_Pos)     /*!< I2S I2SSTATUS: I2SRXINT Mask       */
N
N#define I2S_STATUS_I2SINT_Pos                0                                    /*!< I2S I2SSTATUS: I2SINT Position     */
N#define I2S_STATUS_I2SINT_Msk                (1ul << I2S_STATUS_I2SINT_Pos)       /*!< I2S I2SSTATUS: I2SINT Mask         */
N
N/*@}*/ /* end of group NUC200_I2S */
N
N
N
N/*----------------------------- Smart Card Host Interface -------------------------------*/
N
N/** @addtogroup NUC200_SMARTCARD NUC200 SMARTCARD
N  Memory Mapped Structure for NUC200 Series Smart Card Host Interface
N  @{
N */
Ntypedef struct
N{  
N    union {
N        __I  uint32_t  RBR;     /*!< Offset: 0x00  SC Receiving Buffer Register */
X        volatile const  uint32_t  RBR;      
N        __O  uint32_t  THR;     /*!< Offset: 0x00  SC Transmit Holding Register */
X        volatile  uint32_t  THR;      
N    };
N  
N    __IO uint32_t  CTL;         /*!< Offset: 0x04  SC Control Register */
X    volatile uint32_t  CTL;          
N    __IO uint32_t  ALTCTL;      /*!< Offset: 0x08  SC Alternate Control State Register */
X    volatile uint32_t  ALTCTL;       
N    __IO uint32_t  EGTR;        /*!< Offset: 0x0C  SC Extend Guard Time Register */        
X    volatile uint32_t  EGTR;                 
N    __IO uint32_t  RFTMR;       /*!< Offset: 0x10  SC Receiver buffer Time Out Register */
X    volatile uint32_t  RFTMR;        
N    __IO uint32_t  ETUCR;       /*!< Offset: 0x14  SC ETU Control Register */
X    volatile uint32_t  ETUCR;        
N    __IO uint32_t  IER;         /*!< Offset: 0x18  SC Interrupt Enable Register */
X    volatile uint32_t  IER;          
N    __IO uint32_t  ISR;         /*!< Offset: 0x1C  SC Interrupt Status Register (Read Only) */
X    volatile uint32_t  ISR;          
N    __IO uint32_t  TRSR;        /*!< Offset: 0x20  SC Transfer Status Register (Read Only) */
X    volatile uint32_t  TRSR;         
N    __IO uint32_t  PINCSR;      /*!< Offset: 0x24  SC Pin Control State Register  */
X    volatile uint32_t  PINCSR;       
N    __IO uint32_t  TMR0;        /*!< Offset: 0x28  SC Internal Timer Control Register 0 */
X    volatile uint32_t  TMR0;         
N    __IO uint32_t  TMR1;        /*!< Offset: 0x2C  SC Internal Timer Control Register 1 */
X    volatile uint32_t  TMR1;         
N    __IO uint32_t  TMR2;        /*!< Offset: 0x30  SC Internal Timer Control Register 2 */
X    volatile uint32_t  TMR2;         
N    uint32_t       RESERVE0[1]; /*!< Offset: 0x34  SC Reserve */
N    __I  uint32_t  TDRA;        /*!< Offset: 0x38  SC Timer Current Data Register A */
X    volatile const  uint32_t  TDRA;         
N    __I  uint32_t  TDRB;        /*!< Offset: 0x3C  SC Timer Current Data Register B */
X    volatile const  uint32_t  TDRB;         
N} SC_T;
N
N/* SC RBR Bit Field Definitions */
N#define SC_RBR_RBR_Pos                      0                                /*!< SC RBR: RBR Position */
N#define SC_RBR_RBR_Msk                      (0xFFul << SC_RBR_RBR_Pos)       /*!< SC RBR: RBR Mask */
N
N/* SC THR Bit Field Definitions */
N#define SC_THR_THR_Pos                      0                                /*!< SC THR: THR Position */
N#define SC_THR_THR_Msk                      (0xFFul << SC_THR_THR_Pos)       /*!< SC THR: THR Mask */
N
N/* SC CTL Bit Field Definitions */
N#define SC_CTL_CD_DEB_SEL_Pos               24                               /*!< SC CTL: CD_DEB_SEL Position */
N#define SC_CTL_CD_DEB_SEL_Msk               (3ul << SC_CTL_CD_DEB_SEL_Pos)   /*!< SC CTL: CD_DEB_SEL Mask */
N
N#define SC_CTL_TX_ERETRY_EN_Pos             23                               /*!< SC CTL: TX_ERETRY_EN Position */
N#define SC_CTL_TX_ERETRY_EN_Msk             (1ul << SC_CTL_TX_ERETRY_EN_Pos) /*!< SC CTL: TX_ERETRY_EN Mask */
N
N#define SC_CTL_TX_ERETRY_Pos                20                               /*!< SC CTL: TX_ERETRY Position */
N#define SC_CTL_TX_ERETRY_Msk                (7ul << SC_CTL_TX_ERETRY_Pos)    /*!< SC CTL: TX_ERETRY Mask */
N
N#define SC_CTL_RX_ERETRY_EN_Pos             19                               /*!< SC CTL: RX_ERETRY_EN Position */
N#define SC_CTL_RX_ERETRY_EN_Msk             (1ul << SC_CTL_RX_ERETRY_EN_Pos) /*!< SC CTL: RX_ERETRY_EN Mask */
N
N#define SC_CTL_RX_ERETRY_Pos                16                               /*!< SC CTL: RX_ERETRY Position */
N#define SC_CTL_RX_ERETRY_Msk                (7ul << SC_CTL_RX_ERETRY_Pos)    /*!< SC CTL: RX_ERETRY Mask */
N
N#define SC_CTL_SLEN_Pos                     15                               /*!< SC CTL: SLEN Position */
N#define SC_CTL_SLEN_Msk                     (1ul << SC_CTL_SLEN_Pos)         /*!< SC CTL: SLEN Mask */
N
N#define SC_CTL_TMR_SEL_Pos                  13                               /*!< SC CTL: TMR_SEL Position */
N#define SC_CTL_TMR_SEL_Msk                  (3ul << SC_CTL_TMR_SEL_Pos)      /*!< SC CTL: TMR_SEL Mask */
N
N#define SC_CTL_BGT_Pos                      8                                /*!< SC CTL: BGT Position */
N#define SC_CTL_BGT_Msk                      (0x1Ful << SC_CTL_BGT_Pos)       /*!< SC CTL: BGT Mask */
N
N#define SC_CTL_RX_FTRI_LEV_Pos              6                                /*!< SC CTL: RX_FTRI_LEV Position */
N#define SC_CTL_RX_FTRI_LEV_Msk              (3ul << SC_CTL_RX_FTRI_LEV_Pos)  /*!< SC CTL: RX_FTRI_LEV Mask */
N
N#define SC_CTL_CON_SEL_Pos                  4                                /*!< SC CTL: CON_SEL Position */
N#define SC_CTL_CON_SEL_Msk                  (3ul << SC_CTL_CON_SEL_Pos)      /*!< SC CTL: CON_SEL Mask */
N
N#define SC_CTL_AUTO_CON_EN_Pos              3                                /*!< SC CTL: AUTO_CON_EN Position */
N#define SC_CTL_AUTO_CON_EN_Msk              (1ul << SC_CTL_AUTO_CON_EN_Pos)  /*!< SC CTL: AUTO_CON_EN Mask */
N
N#define SC_CTL_DIS_TX_Pos                   2                                /*!< SC CTL: DIS_TX Position */
N#define SC_CTL_DIS_TX_Msk                   (1ul << SC_CTL_DIS_TX_Pos)       /*!< SC CTL: DIS_TX Mask */
N
N#define SC_CTL_DIS_RX_Pos                   1                                /*!< SC CTL: DIS_RX Position */
N#define SC_CTL_DIS_RX_Msk                   (1ul << SC_CTL_DIS_RX_Pos)       /*!< SC CTL: DIS_RX Mask */
N
N#define SC_CTL_SC_CEN_Pos                   0                                /*!< SC CTL: SC_CEN Position */
N#define SC_CTL_SC_CEN_Msk                   (1ul << SC_CTL_SC_CEN_Pos)       /*!< SC CTL: SC_CEN Mask */
N
N/* SC ALTCTL Bit Field Definitions */
N#define SC_ALTCTL_TMR2_ATV_Pos              15                               /*!< SC ALTCTL: TMR2_ATV Position */
N#define SC_ALTCTL_TMR2_ATV_Msk              (1ul << SC_ALTCTL_TMR2_ATV_Pos)  /*!< SC ALTCTL: TMR2_ATV Mask */
N
N#define SC_ALTCTL_TMR1_ATV_Pos              14                               /*!< SC ALTCTL: TMR1_ATV Position */
N#define SC_ALTCTL_TMR1_ATV_Msk              (1ul << SC_ALTCTL_TMR1_ATV_Pos)  /*!< SC ALTCTL: TMR1_ATV Mask */
N
N#define SC_ALTCTL_TMR0_ATV_Pos              13                               /*!< SC ALTCTL: TMR0_ATV Position */
N#define SC_ALTCTL_TMR0_ATV_Msk              (1ul << SC_ALTCTL_TMR0_ATV_Pos)  /*!< SC ALTCTL: TMR0_ATV Mask */
N
N#define SC_ALTCTL_RX_BGT_EN_Pos             12                               /*!< SC ALTCTL: RX_BGT_EN Position */
N#define SC_ALTCTL_RX_BGT_EN_Msk             (1ul << SC_ALTCTL_RX_BGT_EN_Pos) /*!< SC ALTCTL: RX_BGT_EN Mask */
N
N#define SC_ALTCTL_INIT_SEL_Pos              8                                /*!< SC ALTCTL: INIT_SEL Position */
N#define SC_ALTCTL_INIT_SEL_Msk              (3ul << SC_ALTCTL_INIT_SEL_Pos)  /*!< SC ALTCTL: INIT_SEL Mask */
N
N#define SC_ALTCTL_TMR2_SEN_Pos              7                                /*!< SC ALTCTL: TMR2_SEN Position */
N#define SC_ALTCTL_TMR2_SEN_Msk              (1ul << SC_ALTCTL_TMR2_SEN_Pos)  /*!< SC ALTCTL: TMR2_SEN Mask */
N
N#define SC_ALTCTL_TMR1_SEN_Pos              6                                /*!< SC ALTCTL: TMR1_SEN Position */
N#define SC_ALTCTL_TMR1_SEN_Msk              (1ul << SC_ALTCTL_TMR1_SEN_Pos)  /*!< SC ALTCTL: TMR1_SEN Mask */
N
N#define SC_ALTCTL_TMR0_SEN_Pos              5                                /*!< SC ALTCTL: TMR0_SEN Position */
N#define SC_ALTCTL_TMR0_SEN_Msk              (1ul << SC_ALTCTL_TMR0_SEN_Pos)  /*!< SC ALTCTL: TMR0_SEN Mask */
N
N#define SC_ALTCTL_WARST_EN_Pos              4                                /*!< SC ALTCTL: WARST_EN Position */
N#define SC_ALTCTL_WARST_EN_Msk              (1ul << SC_ALTCTL_WARST_EN_Pos)  /*!< SC ALTCTL: WARST_EN Mask */
N
N#define SC_ALTCTL_ACT_EN_Pos                3                                /*!< SC ALTCTL: ACT_EN Position */
N#define SC_ALTCTL_ACT_EN_Msk                (1ul << SC_ALTCTL_ACT_EN_Pos)    /*!< SC ALTCTL: ACT_EN Mask */
N
N#define SC_ALTCTL_DACT_EN_Pos               2                                /*!< SC ALTCTL: DACT_EN Position */
N#define SC_ALTCTL_DACT_EN_Msk               (1ul << SC_ALTCTL_DACT_EN_Pos)   /*!< SC ALTCTL: DACT_EN Mask */
N
N#define SC_ALTCTL_RX_RST_Pos                1                                /*!< SC ALTCTL: RX_RST Position */
N#define SC_ALTCTL_RX_RST_Msk                (1ul << SC_ALTCTL_RX_RST_Pos)    /*!< SC ALTCTL: RX_RST Mask */
N
N#define SC_ALTCTL_TX_RST_Pos                0                                /*!< SC ALTCTL: TX_RST Position */
N#define SC_ALTCTL_TX_RST_Msk                (1ul << SC_ALTCTL_TX_RST_Pos)    /*!< SC ALTCTL: TX_RST Mask */
N
N/* SC EGTR Bit Field Definitions */
N#define SC_EGTR_EGT_Pos                     0                               /*!< SC EGTR: EGT Position */
N#define SC_EGTR_EGT_Msk                     (0xFFul << SC_EGTR_EGT_Pos)     /*!< SC EGTR: EGT Mask */
N
N/* SC RFTMR Bit Field Definitions */
N#define SC_RFTMR_RFTM_Pos                   0                               /*!< SC RFTMR: RFTM Position */
N#define SC_RFTMR_RFTM_Msk                   (0x1FFul << SC_RFTMR_RFTM_Pos)  /*!< SC RFTMR: RFTM Mask */
N
N/* SC ETUCR Bit Field Definitions */
N#define SC_ETUCR_COMPEN_EN_Pos              15                               /*!< SC ETUCR: COMPEN_EN Position */
N#define SC_ETUCR_COMPEN_EN_Msk              (1ul << SC_ETUCR_COMPEN_EN_Pos)  /*!< SC ETUCR: COMPEN_EN Mask */
N
N#define SC_ETUCR_ETU_RDIV_Pos               0                                   /*!< SC ETUCR: ETU_RDIV Position */
N#define SC_ETUCR_ETU_RDIV_Msk               (0xFFFul << SC_ETUCR_ETU_RDIV_Pos)  /*!< SC ETUCR: ETU_RDIV Mask */
N
N/* SC IER Bit Field Definitions */
N#define SC_IER_ACON_ERR_IE_Pos              10                                  /*!< SC IER: ACON_ERR_IE Position */
N#define SC_IER_ACON_ERR_IE_Msk              (1ul << SC_IER_ACON_ERR_IE_Pos)     /*!< SC IER: ACON_ERR_IE Mask */
N
N#define SC_IER_RTMR_IE_Pos                  9                               /*!< SC IER: RTMR_IE Position */
N#define SC_IER_RTMR_IE_Msk                  (1ul << SC_IER_RTMR_IE_Pos)     /*!< SC IER: RTMR_IE Mask */
N
N#define SC_IER_INIT_IE_Pos                  8                               /*!< SC IER: INIT_IE Position */
N#define SC_IER_INIT_IE_Msk                  (1ul << SC_IER_INIT_IE_Pos)     /*!< SC IER: INIT_IE Mask */
N
N#define SC_IER_CD_IE_Pos                    7                               /*!< SC IER: CD_IE Position */
N#define SC_IER_CD_IE_Msk                    (1ul << SC_IER_CD_IE_Pos)       /*!< SC IER: CD_IE Mask */
N
N#define SC_IER_BGT_IE_Pos                   6                               /*!< SC IER: BGT_IE Position */
N#define SC_IER_BGT_IE_Msk                   (1ul << SC_IER_BGT_IE_Pos)      /*!< SC IER: BGT_IE Mask */
N
N#define SC_IER_TMR2_IE_Pos                  5                               /*!< SC IER: TMR2_IE Position */
N#define SC_IER_TMR2_IE_Msk                  (1ul << SC_IER_TMR2_IE_Pos)     /*!< SC IER: TMR2_IE Mask */
N
N#define SC_IER_TMR1_IE_Pos                  4                               /*!< SC IER: TMR1_IE Position */
N#define SC_IER_TMR1_IE_Msk                  (1ul << SC_IER_TMR1_IE_Pos)     /*!< SC IER: TMR1_IE Mask */
N
N#define SC_IER_TMR0_IE_Pos                  3                               /*!< SC IER: TMR0_IE Position */
N#define SC_IER_TMR0_IE_Msk                  (1ul << SC_IER_TMR0_IE_Pos)     /*!< SC IER: TMR0_IE Mask */
N
N#define SC_IER_TERR_IE_Pos                  2                               /*!< SC IER: TERR_IE Position */
N#define SC_IER_TERR_IE_Msk                  (1ul << SC_IER_TERR_IE_Pos)     /*!< SC IER: TERR_IE Mask */
N
N#define SC_IER_TBE_IE_Pos                   1                               /*!< SC IER: TBE_IE Position */
N#define SC_IER_TBE_IE_Msk                   (1ul << SC_IER_TBE_IE_Pos)      /*!< SC IER: TBE_IE Mask */
N
N#define SC_IER_RDA_IE_Pos                   0                               /*!< SC IER: RDA_IE Position */
N#define SC_IER_RDA_IE_Msk                   (1ul << SC_IER_RDA_IE_Pos)      /*!< SC IER: RDA_IE Mask */
N
N/* SC ISR Bit Field Definitions */
N#define SC_ISR_ACON_ERR_IS_Pos              10                              /*!< SC ISR: ACON_ERR_IS Position */
N#define SC_ISR_ACON_ERR_IS_Msk              (1ul << SC_ISR_ACON_ERR_IS_Pos) /*!< SC ISR: ACON_ERR_IS Mask */
N
N#define SC_ISR_RTMR_IS_Pos                  9                               /*!< SC ISR: RTMR_IS Position */
N#define SC_ISR_RTMR_IS_Msk                  (1ul << SC_ISR_RTMR_IS_Pos)     /*!< SC ISR: RTMR_IS Mask */
N
N#define SC_ISR_INIT_IS_Pos                  8                               /*!< SC ISR: INIT_IS Position */
N#define SC_ISR_INIT_IS_Msk                  (1ul << SC_ISR_INIT_IS_Pos)     /*!< SC ISR: INIT_IS Mask */
N
N#define SC_ISR_CD_IS_Pos                    7                               /*!< SC ISR: CD_IS Position */
N#define SC_ISR_CD_IS_Msk                    (1ul << SC_ISR_CD_IS_Pos)       /*!< SC ISR: CD_IS Mask */
N
N#define SC_ISR_BGT_IS_Pos                   6                               /*!< SC ISR: BGT_IS Position */
N#define SC_ISR_BGT_IS_Msk                   (1ul << SC_ISR_BGT_IS_Pos)      /*!< SC ISR: BGT_IS Mask */
N
N#define SC_ISR_TMR2_IS_Pos                  5                               /*!< SC ISR: TMR2_IS Position */
N#define SC_ISR_TMR2_IS_Msk                  (1ul << SC_ISR_TMR2_IS_Pos)     /*!< SC ISR: TMR2_IS Mask */
N
N#define SC_ISR_TMR1_IS_Pos                  4                               /*!< SC ISR: TMR1_IS Position */
N#define SC_ISR_TMR1_IS_Msk                  (1ul << SC_ISR_TMR1_IS_Pos)     /*!< SC ISR: TMR1_IS Mask */
N
N#define SC_ISR_TMR0_IS_Pos                  3                               /*!< SC ISR: TMR0_IS Position */
N#define SC_ISR_TMR0_IS_Msk                  (1ul << SC_ISR_TMR0_IS_Pos)     /*!< SC ISR: TMR0_IS Mask */
N
N#define SC_ISR_TERR_IS_Pos                  2                               /*!< SC ISR: TERR_IS Position */
N#define SC_ISR_TERR_IS_Msk                  (1ul << SC_ISR_TERR_IS_Pos)     /*!< SC ISR: TERR_IS Mask */
N
N#define SC_ISR_TBE_IS_Pos                   1                               /*!< SC ISR: TXBE_IS Position */
N#define SC_ISR_TBE_IS_Msk                   (1ul << SC_ISR_TBE_IS_Pos)      /*!< SC ISR: TXBE_IS Mask */
N
N#define SC_ISR_RDA_IS_Pos                   0                               /*!< SC ISR: RDA_IS Position */
N#define SC_ISR_RDA_IS_Msk                   (1ul << SC_ISR_RDA_IS_Pos)      /*!< SC ISR: RDA_IS Mask */
N
N
N/* SC TRSR Bit Field Definitions */
N#define SC_TRSR_TX_ATV_Pos                  31                              /*!< SC TRSR: TX_ATV Position */
N#define SC_TRSR_TX_ATV_Msk                  (1ul << SC_TRSR_TX_ATV_Pos)     /*!< SC TRSR: TX_ATV Mask */
N
N#define SC_TRSR_TX_OVER_REERR_Pos           30                                  /*!< SC TRSR: TX_OVER_REERR Position */
N#define SC_TRSR_TX_OVER_REERR_Msk           (1ul << SC_TRSR_TX_OVER_REERR_Pos)  /*!< SC TRSR: TX_OVER_REERR Mask */
N
N#define SC_TRSR_TX_REERR_Pos                29                               /*!< SC TRSR: TX_REERR Position */
N#define SC_TRSR_TX_REERR_Msk                (1ul << SC_TRSR_TX_REERR_Pos)    /*!< SC TRSR: TX_REERR Mask */
N
N#define SC_TRSR_TX_POINT_F_Pos              24                               /*!< SC TRSR: TX_POINT_F Position */
N#define SC_TRSR_TX_POINT_F_Msk              (7ul << SC_TRSR_TX_POINT_F_Pos)  /*!< SC TRSR: TX_POINT_F Mask */
N
N#define SC_TRSR_RX_ATV_Pos                  23                               /*!< SC TRSR: RX_ATV Position */
N#define SC_TRSR_RX_ATV_Msk                  (1ul << SC_TRSR_RX_ATV_Pos)      /*!< SC TRSR: RX_ATV Mask */
N
N#define SC_TRSR_RX_OVER_REERR_Pos           22                                  /*!< SC TRSR: RX_OVER_REERR Position */
N#define SC_TRSR_RX_OVER_REERR_Msk           (1ul << SC_TRSR_RX_OVER_REERR_Pos)  /*!< SC TRSR: RX_OVER_REERR Mask */
N
N#define SC_TRSR_RX_REERR_Pos                21                                  /*!< SC TRSR: RX_REERR Position */
N#define SC_TRSR_RX_REERR_Msk                (1ul << SC_TRSR_RX_REERR_Pos)       /*!< SC TRSR: RX_REERR Mask */
N
N#define SC_TRSR_RX_POINT_F_Pos              16                                  /*!< SC TRSR: RX_POINT_F Position */
N#define SC_TRSR_RX_POINT_F_Msk              (7ul << SC_TRSR_RX_POINT_F_Pos)     /*!< SC TRSR: RX_POINT_F Mask */
N
N#define SC_TRSR_TX_FULL_F_Pos               10                                  /*!< SC TRSR: TX_FULL_F Position */
N#define SC_TRSR_TX_FULL_F_Msk               (1ul << SC_TRSR_TX_FULL_F_Pos)      /*!< SC TRSR: TX_FULL_F Mask */
N
N#define SC_TRSR_TX_EMPTY_F_Pos              9                                   /*!< SC TRSR: TX_EMPTY_F Position */
N#define SC_TRSR_TX_EMPTY_F_Msk              (1ul << SC_TRSR_TX_EMPTY_F_Pos)     /*!< SC TRSR: TX_EMPTY_F Mask */
N
N#define SC_TRSR_TX_OVER_F_Pos               8                                   /*!< SC TRSR: TX_OVER_F Position */
N#define SC_TRSR_TX_OVER_F_Msk               (1ul << SC_TRSR_TX_OVER_F_Pos)      /*!< SC TRSR: TX_OVER_F Mask */
N
N#define SC_TRSR_RX_EBR_F_Pos                6                                   /*!< SC TRSR: RX_EBR_F Position */
N#define SC_TRSR_RX_EBR_F_Msk                (1ul << SC_TRSR_RX_EBR_F_Pos)       /*!< SC TRSR: RX_EBR_F Mask */
N
N#define SC_TRSR_RX_EFR_F_Pos                5                                   /*!< SC TRSR: RX_EFR_F Position */
N#define SC_TRSR_RX_EFR_F_Msk                (1ul << SC_TRSR_RX_EFR_F_Pos)       /*!< SC TRSR: RX_EFR_F Mask */
N
N#define SC_TRSR_RX_EPA_F_Pos                4                                   /*!< SC TRSR: RX_EPA_F Position */
N#define SC_TRSR_RX_EPA_F_Msk                (1ul << SC_TRSR_RX_EPA_F_Pos)       /*!< SC TRSR: RX_EPA_F Mask */
N
N#define SC_TRSR_RX_FULL_F_Pos               2                                   /*!< SC TRSR: RX_FULL_F Position */
N#define SC_TRSR_RX_FULL_F_Msk               (1ul << SC_TRSR_RX_FULL_F_Pos)      /*!< SC TRSR: RX_FULL_F Mask */
N
N#define SC_TRSR_RX_EMPTY_F_Pos              1                                   /*!< SC TRSR: RX_EMPTY_F Position */
N#define SC_TRSR_RX_EMPTY_F_Msk              (1ul << SC_TRSR_RX_EMPTY_F_Pos)     /*!< SC TRSR: RX_EMPTY_F Mask */
N
N#define SC_TRSR_RX_OVER_F_Pos               0                                   /*!< SC TRSR: RX_OVER_F Position */
N#define SC_TRSR_RX_OVER_F_Msk               (1ul << SC_TRSR_RX_OVER_F_Pos)      /*!< SC TRSR: RX_OVER_F Mask */
N
N/* SC PINCSR Bit Field Definitions */
N#define SC_PINCSR_SC_DATA_I_ST_Pos          16                                  /*!< SC PINCSR: SC_DATA_I_ST Position */
N#define SC_PINCSR_SC_DATA_I_ST_Msk          (1ul << SC_PINCSR_SC_DATA_I_ST_Pos) /*!< SC PINCSR: SC_DATA_I_ST Mask */
N
N#define SC_PINCSR_POW_INV_Pos               11                                  /*!< SC PINCSR: POW_INV Position */
N#define SC_PINCSR_POW_INV_Msk               (1ul << SC_PINCSR_POW_INV_Pos)      /*!< SC PINCSR: POW_INV Mask */
N
N#define SC_PINCSR_CD_LEV_Pos                10                                  /*!< SC PINCSR: CD_LEV Position */
N#define SC_PINCSR_CD_LEV_Msk                (1ul << SC_PINCSR_CD_LEV_Pos)       /*!< SC PINCSR: CD_LEV Mask */
N
N#define SC_PINCSR_SC_DATA_O_Pos             9                                   /*!< SC PINCSR: SC_DATA_O Position */
N#define SC_PINCSR_SC_DATA_O_Msk             (1ul << SC_PINCSR_SC_DATA_O_Pos)    /*!< SC PINCSR: SC_DATA_O Mask */
N
N#define SC_PINCSR_SC_OEN_ST_Pos             8                                   /*!< SC PINCSR: SC_OEN_ST Position */
N#define SC_PINCSR_SC_OEN_ST_Msk             (1ul << SC_PINCSR_SC_OEN_ST_Pos)    /*!< SC PINCSR: SC_OEN_ST Mask */
N
N#define SC_PINCSR_ADAC_CD_EN_Pos            7                                   /*!< SC PINCSR: ADAC_CD_EN Position */
N#define SC_PINCSR_ADAC_CD_EN_Msk            (1ul << SC_PINCSR_ADAC_CD_EN_Pos)   /*!< SC PINCSR: ADAC_CD_EN Mask */
N
N#define SC_PINCSR_CLK_KEEP_Pos              6                                   /*!< SC PINCSR: CLK_KEEP Position */
N#define SC_PINCSR_CLK_KEEP_Msk              (1ul << SC_PINCSR_CLK_KEEP_Pos)     /*!< SC PINCSR: CLK_KEEP Mask */
N
N#define SC_PINCSR_CLK_STOP_LEV_Pos          5                                   /*!< SC PINCSR: CLK_STOP_LEV Position */
N#define SC_PINCSR_CLK_STOP_LEV_Msk          (1ul << SC_PINCSR_CLK_STOP_LEV_Pos) /*!< SC PINCSR: CLK_STOP_LEV Mask */
N
N#define SC_PINCSR_CD_PIN_ST_Pos             4                                   /*!< SC PINCSR: CD_PIN_ST Position */
N#define SC_PINCSR_CD_PIN_ST_Msk             (1ul << SC_PINCSR_CD_PIN_ST_Pos)    /*!< SC PINCSR: CD_PIN_ST Mask */
N
N#define SC_PINCSR_CD_INS_F_Pos              3                                   /*!< SC PINCSR: CD_INS_F Position */
N#define SC_PINCSR_CD_INS_F_Msk              (1ul << SC_PINCSR_CD_INS_F_Pos)     /*!< SC PINCSR: CD_INS_F Mask */
N
N#define SC_PINCSR_CD_REM_F_Pos              2                                   /*!< SC PINCSR: CD_REM_F Position */
N#define SC_PINCSR_CD_REM_F_Msk              (1ul << SC_PINCSR_CD_REM_F_Pos)     /*!< SC PINCSR: CD_REM_F Mask */
N
N#define SC_PINCSR_SC_RST_Pos                1                                   /*!< SC PINCSR: SC_RST Position */
N#define SC_PINCSR_SC_RST_Msk                (1ul << SC_PINCSR_SC_RST_Pos)       /*!< SC PINCSR: SC_RST Mask */
N
N#define SC_PINCSR_POW_EN_Pos                0                                   /*!< SC PINCSR: POW_EN Position */
N#define SC_PINCSR_POW_EN_Msk                (1ul << SC_PINCSR_POW_EN_Pos)       /*!< SC PINCSR: POW_EN Mask */
N
N/* SC TMR0 Bit Field Definitions */
N#define SC_TMR0_MODE_Pos                    24                              /*!< SC TMR0: MODE Position */
N#define SC_TMR0_MODE_Msk                    (0xFul << SC_TMR0_MODE_Pos)     /*!< SC TMR0: MODE Mask */
N
N#define SC_TMR0_CNT_Pos                     0                               /*!< SC TMR0: CNT Position */
N#define SC_TMR0_CNT_Msk                     (0xFFFFFFul << SC_TMR0_CNT_Pos) /*!< SC TMR0: CNT Mask */
N
N/* SC TMR1 Bit Field Definitions */
N#define SC_TMR1_MODE_Pos                    24                              /*!< SC TMR1: MODE Position */
N#define SC_TMR1_MODE_Msk                    (0xFul << SC_TMR1_MODE_Pos)     /*!< SC TMR1: MODE Mask */
N
N#define SC_TMR1_CNT_Pos                     0                               /*!< SC TMR1: CNT Position */
N#define SC_TMR1_CNT_Msk                     (0xFFul << SC_TMR1_CNT_Pos)     /*!< SC TMR1: CNT Mask */
N
N/* SC TMR2 Bit Field Definitions */
N#define SC_TMR2_MODE_Pos                    24                              /*!< SC TMR2: MODE Position */
N#define SC_TMR2_MODE_Msk                    (0xFul << SC_TMR2_MODE_Pos)     /*!< SC TMR2: MODE Mask */
N
N#define SC_TMR2_CNT_Pos                     0                               /*!< SC TMR2: CNT Position */
N#define SC_TMR2_CNT_Msk                     (0xFFul << SC_TMR2_CNT_Pos)     /*!< SC TMR2: CNT Mask */
N
N/* SC TDRA Bit Field Definitions */
N#define SC_TDRA_TDR0_Pos                    0                                   /*!< SC TDRA: TDR0 Position */
N#define SC_TDRA_TDR0_Msk                    (0xFFFFFFul << SC_TDRA_TDR0_Pos)    /*!< SC TDRA: TDR0 Mask */
N
N/* SC TDRB Bit Field Definitions */
N#define SC_TDRB_TDR2_Pos                    8                               /*!< SC TDRB: TDR2 Position */
N#define SC_TDRB_TDR2_Msk                    (0xFFul << SC_TDRB_TDR2_Pos)    /*!< SC TDRB: TDR2 Mask */
N
N#define SC_TDRB_TDR1_Pos                    0                               /*!< SC TDRB: TDR1 Position */
N#define SC_TDRB_TDR1_Msk                    (0xFFul << SC_TDRB_TDR1_Pos)    /*!< SC TDRB: TDR1 Mask */
N
N
N/*@}*/ /* end of group NUC200_SMARTCARD */
N/*@}*/ /* end of group NUC200 */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup NUC200_PERIPHERAL_MEM_MAP NUC200 Peripheral Memory Map
N  Memory Mapped Structure for NUC200 Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE        + 0x4000)                   /*!< GPIO Base Address                                   */
N#define PA_BASE             (GPIO_BASE               )                   /*!< GPIO PORTA Base Address                             */  
N#define PB_BASE             (GPIO_BASE       + 0x0040)                   /*!< GPIO PORTB Base Address                             */
N#define PC_BASE             (GPIO_BASE       + 0x0080)                   /*!< GPIO PORTC Base Address                             */
N#define PD_BASE             (GPIO_BASE       + 0x00C0)                   /*!< GPIO PORTD Base Address                             */
N#define PE_BASE             (GPIO_BASE       + 0x0100)                   /*!< GPIO PORTE Base Address                             */
N#define PF_BASE             (GPIO_BASE       + 0x0140)                   /*!< GPIO PORTF Base Address                             */
N#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
N#define GPIO_PIN_DATA_BASE  (GPIO_BASE       + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
N
N
N#define UART0_BASE           (APB1_BASE      + 0x50000)
N#define UART1_BASE           (APB2_BASE      + 0x50000)
N#define UART2_BASE           (APB2_BASE      + 0x54000)
N
N
N#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
N#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
N#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
N#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
N
N#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watchdog Timer Base Address                      */
N
N#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watchdog Timer Base Address               */
N
N#define SPI0_BASE            (APB1_BASE      + 0x30000)
N#define SPI1_BASE            (APB1_BASE      + 0x34000)
N#define SPI2_BASE            (APB2_BASE      + 0x30000)
N#define SPI3_BASE            (APB2_BASE      + 0x34000)
N
N#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
N#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
N
N#define RTC_BASE             (APB1_BASE      + 0x08000)                 /*!< RTC Base Address                                 */
N
N#define ADC_BASE             (APB1_BASE      + 0xE0000)
N
N#define ACMP_BASE            (APB1_BASE      + 0xD0000)   
N
N#define SYSCLK_BASE          (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
N
N#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
N
N#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
N
N#define FMC_BASE             (AHB_BASE       + 0x0C000)
N
N#define PS2_BASE             (APB2_BASE      + 0x00000)					/*!< PS/2 Base Address                                 */
N
N#define CAN0_BASE            (APB2_BASE      + 0x80000)
N#define CAN1_BASE            (APB2_BASE      + 0x84000)
N#define C_CAN_BASE           (APB2_BASE      + 0x88000)
N
N#define USBD_BASE            (APB1_BASE      + 0x60000)
N
N#define PDMA0_BASE           (AHB_BASE       + 0x08000)                 /*!< PDMA0 Base Address                               */
N#define PDMA1_BASE           (AHB_BASE       + 0x08100)                 /*!< PDMA1 Base Address                               */
N#define PDMA2_BASE           (AHB_BASE       + 0x08200)                 /*!< PDMA2 Base Address                               */
N#define PDMA3_BASE           (AHB_BASE       + 0x08300)                 /*!< PDMA3 Base Address                               */
N#define PDMA4_BASE           (AHB_BASE       + 0x08400)                 /*!< PDMA4 Base Address                               */
N#define PDMA5_BASE           (AHB_BASE       + 0x08500)                 /*!< PDMA5 Base Address                               */
N#define PDMA6_BASE           (AHB_BASE       + 0x08600)                 /*!< PDMA6 Base Address                               */
N#define PDMA7_BASE           (AHB_BASE       + 0x08700)                 /*!< PDMA7 Base Address                               */
N#define PDMA8_BASE           (AHB_BASE       + 0x08800)                 /*!< PDMA8 Base Address                               */
N
N#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)                 /*!< PDMA Grobal Base Address                               */
N
N#define CRC_BASE             (AHB_BASE       + 0x08E00)                 /*!< CRC Base Address                                 */
N
N#define PWMA_BASE            (APB1_BASE      + 0x40000)                 /*!< PWMA Base Address                                */
N#define PWMB_BASE            (APB2_BASE      + 0x40000)                 /*!< PWMB Base Address                                */
N
N#define SC0_BASE             (APB2_BASE      + 0x90000)                 /*!< SC0 Base Address                                */
N#define SC1_BASE             (APB2_BASE      + 0x94000)                 /*!< SC1 Base Address                               */
N#define SC2_BASE             (APB2_BASE      + 0x98000)                 /*!< SC2 Base Address                               */
N
N#define I2S_BASE             (APB2_BASE      + 0xA0000)
N
N/*@}*/ /* end of group NUC200_PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                         Peripheral Definitions                             */
N/******************************************************************************/
N
N/** @addtogroup NUC200_PERIPHERAL NUC200 Peripheral Definitions
N  The Definitions of NUC200 Series Peripheral
N  @{
N */
N#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
N#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
N#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
N#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
N#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
N#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
N#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */ 
N
N#define UART0               ((UART_T *) UART0_BASE)
N#define UART1               ((UART_T *) UART1_BASE)
N#define UART2               ((UART_T *) UART2_BASE)
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< Timer0 Configuration Struct                      */
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< Timer1 Configuration Struct                      */
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< Timer2 Configuration Struct                      */
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< Timer3 Configuration Struct                      */
N
N#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watchdog Timer Configuration Struct              */
N
N#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watchdog Timer Configuration Struct       */
N
N#define SPI0                ((SPI_T *) SPI0_BASE)
N#define SPI1                ((SPI_T *) SPI1_BASE)
N#define SPI2                ((SPI_T *) SPI2_BASE)
N#define SPI3                ((SPI_T *) SPI3_BASE)
N
N#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
N#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
N
N#define I2S                 ((I2S_T *) I2S_BASE)
N
N#define RTC                 ((RTC_T *) RTC_BASE)                        /*!< RTC Configuration Struct                         */
N
N#define ADC                 ((ADC_T *) ADC_BASE)
N
N#define ACMP                ((ACMP_T *) ACMP_BASE)
N
N#define SYSCLK              ((SYSCLK_T *) SYSCLK_BASE)                  /*!< System Clock Controller Configuration Struct     */
N
N#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
N
N#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
N
N#define FMC                 ((FMC_T *) FMC_BASE)
N
N#define PS2                 ((PS2_T *) PS2_BASE)						/*!< PS/2 Configuration Struct                        */
N
N#define CAN                 ((CAN_T *) CAN0_BASE)
N#define CAN0                ((CAN_T *) CAN0_BASE)
N#define CAN1                ((CAN_T *) CAN1_BASE)
N
N#define USBD                ((USBD_T *) USBD_BASE)
N
N#define PDMA0               ((PDMA_T *) PDMA0_BASE)                     /*!< PDMA0 Configuration Struct                       */
N#define PDMA1               ((PDMA_T *) PDMA1_BASE)                     /*!< PDMA1 Configuration Struct                       */
N#define PDMA2               ((PDMA_T *) PDMA2_BASE)                     /*!< PDMA2 Configuration Struct                       */
N#define PDMA3               ((PDMA_T *) PDMA3_BASE)                     /*!< PDMA3 Configuration Struct                       */
N#define PDMA4               ((PDMA_T *) PDMA4_BASE)                     /*!< PDMA4 Configuration Struct                       */
N#define PDMA5               ((PDMA_T *) PDMA5_BASE)                     /*!< PDMA5 Configuration Struct                       */
N#define PDMA6               ((PDMA_T *) PDMA6_BASE)                     /*!< PDMA6 Configuration Struct                       */
N#define PDMA7               ((PDMA_T *) PDMA7_BASE)                     /*!< PDMA7 Configuration Struct                       */
N#define PDMA8               ((PDMA_T *) PDMA8_BASE)                     /*!< PDMA8 Configuration Struct                       */
N
N#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)              /*!< PDMA Global Configuration Struct                 */
N
N#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
N
N#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
N#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
N
N#define SC0                 ((SC_T *) SC0_BASE)                         /*!< SC0 Configuration Struct                        */
N#define SC1                 ((SC_T *) SC1_BASE)                         /*!< SC1 Configuration Struct                        */
N#define SC2                 ((SC_T *) SC2_BASE)                         /*!< SC2 Configuration Struct                        */
N
N/*@}*/ /* end of group NUC200_PERIPHERAL */
N
N#define UNLOCKREG(x)        do{*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88}while(*((__IO uint32_t *)(GCR_BASE + 0x100))==0)
N#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00;     
N
N#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
N#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
N
N//=============================================================================
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N
N#define outpw(port,value)   *((volatile unsigned int *)(port))=(value)
N#define inpw(port)          (*((volatile unsigned int *)(port)))
N#define outpb(port,value)   *((volatile unsigned char *)(port))=(value)
N#define inpb(port)          (*((volatile unsigned char *)(port)))
N#define outps(port,value)   *((volatile unsigned short *)(port))=(value)
N#define inps(port)          (*((volatile unsigned short *)(port)))
N
N#define outp32(port,value)  *((volatile unsigned int *)(port))=(value)
N#define inp32(port)         (*((volatile unsigned int *)(port)))
N#define outp8(port,value)   *((volatile unsigned char *)(port))=(value)
N#define inp8(port)          (*((volatile unsigned char *)(port)))
N#define outp16(port,value)  *((volatile unsigned short *)(port))=(value)
N#define inp16(port)         (*((volatile unsigned short *)(port)))
N
N
N#define E_SUCCESS   0
N#ifndef NULL
N#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE     1
N#define DISABLE    0
N
N/* Define one bit mask */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/ 
N#include "SYS.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\SYS.h" 1
N/**************************************************************************//**
N * @file     SYS.h
N * @version  V1.00
N * $Revision: 12 $
N * $Date: 12/11/09 8:04p $
N * @brief    NUC200 Series Global Control and Clock Control Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#include "NUC200Series.h"
L 1 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 1
N    /*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                             */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#ifndef __NUC200Series_H__
S#define __NUC200Series_H__
S
S              
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S*/
S 
Stypedef enum IRQn
S{
S/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
S  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
S  HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
S  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                       */
S  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                       */
S  SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                   */
S
S/******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
S  BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */ 
S  WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
S  EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
S  EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
S  GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
S  GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
S  PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
S  PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
S  TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
S  TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
S  TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
S  TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
S  UART02_IRQn               = 12,      /*!< UART0/UART2 Interrupt                                */
S  UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
S  SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
S  SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
S  SPI2_IRQn                 = 16,       /*!< SPI2 Interrupt                                       */
S  SPI3_IRQn                 = 17,       /*!< SPI3 Interrupt                                       */
S  I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
S  I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
S  CAN0_IRQn                 = 20,       /*!< CAN0 Interrupt                                       */
S  CAN1_IRQn                 = 21,       /*!< CAN1 Interrupt                                       */
S  SC012_IRQn                = 22,       /*!< SC0/SC1/SC2 Interrupt                                */
S  USBD_IRQn                 = 23,       /*!< USB device Interrupt                                 */
S  PS2_IRQn                  = 24,       /*!< PS/2 device Interrupt                                */
S  ACMP_IRQn                 = 25,       /*!< ACMP0 Interrupt                                      */
S  PDMA_IRQn                 = 26,       /*!< PDMA Interrupt                                       */
S  I2S_IRQn                  = 27,       /*!< I2S Interrupt                                        */
S  PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
S  ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
S  IRC_IRQn                  = 30,       /*!< IRC TRIM Interrupt                                   */
S  RTC_IRQn                  = 31        /*!< RTC Interrupt                                        */
S} IRQn_Type;
S
S
S/*
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M0 Processor and Core Peripherals */
S#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
S#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
S#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
S
S
S#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
S#include "system_NUC200Series.h"              /* NUC200 System                                          */
S
S#if defined ( __CC_ARM   )
S#pragma anon_unions
S#endif
S
S
S/*-------------------------------- Device Specific Peripheral registers structures ---------------------*/
S/** @addtogroup NUC200 NUC200 Peripheral Register
S  NUC200 Series Peripheral Control Registers
S  @{
S */
S
S
S/*--------------------- General Purpose I/O (GPIO) ---------------------*/
S/** @addtogroup NUC200_GPIO NUC200 GPIO
S  Memory Mapped Structure for NUC200 Series General Purpose I/O
S  @{
S */
Stypedef struct
S{
S    /**
S     * PMD
S     * ===================================================================================================
S     * Offset: 0x00  GPIO Port [A/B/C/D/E/F] I/O Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  PMD;                         
S
S    /**
S     * OFFD
S     * ===================================================================================================
S     * Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  OFFD;                        
S
S    /**
S     * DOUT
S     * ===================================================================================================
S     * Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DOUT;                        
S
S    /**
S     * DMASK
S     * ===================================================================================================
S     * Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DMASK;                       
S
S    /**
S     * PIN
S     * ===================================================================================================
S     * Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  PIN;                         
S
S    /**
S     * DBEN
S     * ===================================================================================================
S     * Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DBEN;                        
S
S    /**
S     * IMD
S     * ===================================================================================================
S     * Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  IMD;                         
S
S    /**
S     * IEN
S     * ===================================================================================================
S     * Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable Control
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  IEN;                         
S
S    /**
S     * ISRC
S     * ===================================================================================================
S     * Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  ISRC;                        
S} GPIO_T;                                  
S                                                
Stypedef struct                                  
S{                                               
S    /**
S     * DBNCECON
S     * ===================================================================================================
S     * Offset: 0x180 Interrupt De-bounce Cycle Control
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DBNCECON;                    
S} GPIO_DBNCECON_T;
S
S/* GPIO PMD Bit Field Definitions */
S#define GPIO_PMD_PMD15_Pos          30                                          /*!< GPIO PMD: PMD15 Position */
S#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)               /*!< GPIO PMD: PMD15 Mask */
S
S#define GPIO_PMD_PMD14_Pos          28                                          /*!< GPIO PMD: PMD14 Position */
S#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)               /*!< GPIO PMD: PMD14 Mask */
S
S#define GPIO_PMD_PMD13_Pos          26                                          /*!< GPIO PMD: PMD13 Position */
S#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)               /*!< GPIO PMD: PMD13 Mask */
S
S#define GPIO_PMD_PMD12_Pos          24                                          /*!< GPIO PMD: PMD12 Position */
S#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)               /*!< GPIO PMD: PMD12 Mask */
S
S#define GPIO_PMD_PMD11_Pos          22                                          /*!< GPIO PMD: PMD11 Position */
S#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)               /*!< GPIO PMD: PMD11 Mask */
S
S#define GPIO_PMD_PMD10_Pos          20                                          /*!< GPIO PMD: PMD10 Position */
S#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)               /*!< GPIO PMD: PMD10 Mask */
S
S#define GPIO_PMD_PMD9_Pos           18                                          /*!< GPIO PMD: PMD9 Position */
S#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)                /*!< GPIO PMD: PMD9 Mask */
S
S#define GPIO_PMD_PMD8_Pos           16                                          /*!< GPIO PMD: PMD8 Position */
S#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)                /*!< GPIO PMD: PMD8 Mask */
S
S#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO PMD: PMD7 Position */
S#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO PMD: PMD7 Mask */
S
S#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO PMD: PMD6 Position */    
S#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO PMD: PMD6 Mask */
S
S#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO PMD: PMD5 Position */
S#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO PMD: PMD5 Mask */
S
S#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO PMD: PMD4 Position */
S#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO PMD: PMD4 Mask */
S
S#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO PMD: PMD3 Position */
S#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO PMD: PMD3 Mask */
S
S#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO PMD: PMD2 Position */
S#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO PMD: PMD2 Mask */
S
S#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO PMD: PMD1 Position */
S#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO PMD: PMD1 Mask */
S
S#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO PMD: PMD0 Position */
S#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO PMD: PMD0 Mask */
S
S/* GPIO OFFD Bit Field Definitions */
S#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO OFFD: OFFD Position */
S#define GPIO_OFFD_OFFD_Msk          (0xFFFFul << GPIO_OFFD_OFFD_Pos)            /*!< GPIO OFFD: OFFD Mask */
S
S/* GPIO DOUT Bit Field Definitions */                                           
S#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO DOUT: DOUT Position */
S#define GPIO_DOUT_DOUT_Msk          (0xFFFFul << GPIO_DOUT_DOUT_Pos)            /*!< GPIO DOUT: DOUT Mask */
S
S/* GPIO DMASK Bit Field Definitions */
S#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO DMASK: DMASK Position */
S#define GPIO_DMASK_DMASK_Msk        (0xFFFFul << GPIO_DMASK_DMASK_Pos)          /*!< GPIO DMASK: DMASK Mask */
S
S/* GPIO PIN Bit Field Definitions */
S#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO PIN: PIN Position */   
S#define GPIO_PIN_PIN_Msk            (0xFFFFul << GPIO_PIN_PIN_Pos)              /*!< GPIO PIN: PIN Mask */
S
S/* GPIO DBEN Bit Field Definitions */
S#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO DBEN: DBEN Position */
S#define GPIO_DBEN_DBEN_Msk          (0xFFFFul << GPIO_DBEN_DBEN_Pos)            /*!< GPIO DBEN: DBEN Mask */
S
S/* GPIO IMD Bit Field Definitions */
S#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO IMD: IMD Position */
S#define GPIO_IMD_IMD_Msk            (0xFFFFul << GPIO_IMD_IMD_Pos)              /*!< GPIO IMD: IMD Mask */
S
S/* GPIO IEN Bit Field Definitions */
S#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO IEN: IR_EN Position */
S#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)            /*!< GPIO IEN: IR_EN Mask */
S
S#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO IEN: IF_EN Position */
S#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)            /*!< GPIO IEN: IF_EN Mask */
S
S/* GPIO ISRC Bit Field Definitions */
S#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO ISRC: ISRC Position */
S#define GPIO_ISRC_ISRC_Msk          (0xFFFFul << GPIO_ISRC_ISRC_Pos)            /*!< GPIO ISRC: ISRC Mask */
S
S/* GPIO DBNCECON Bit Field Definitions */
S#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO DBNCECON: ICLK_ON  Position */
S#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO DBNCECON: ICLK_ON  Mask */
S
S#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO DBNCECON: DBCLKSRC Position */
S#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO DBNCECON: DBCLKSRC Mask */
S
S#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO DBNCECON: DBCLKSEL Position */
S#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO DBNCECON: DBCLKSEL Mask */
S/*@}*/ /* end of group NUC200_GPIO */
S
S
S
S/*------------------------- UART Interface Controller ------------------------*/
S
S/** @addtogroup NUC200_UART NUC200 UART
S  Memory Mapped Structure for NUC200 Series UART Serial Interface Controller
S  @{
S */
Stypedef struct
S{
S                                
S    union {                             
S    __IO uint32_t DATA;                 
S
S    /**
S     * THR
S     * ===================================================================================================
S     * Offset: 0x00 Transmit Holding DATA
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |          |bitTransmittedData
S     * |        |          |Transmit Holding Register
S     * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB 
S     * |        |          |first).
S     */    
S    __IO uint32_t THR;                  
S
S    /**
S     * RBR
S     * ===================================================================================================
S     * Offset: 0x00 Receive Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |          |Receive Buffer Register
S     * |        |          |By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).
S     */    
S    __IO uint32_t RBR;                  
S    };
S
S    /**
S     * IER
S     * ===================================================================================================
S     * Offset: 0x04  UART Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable.
S     * |        |          |0 = Mask off INT_RDA
S     * |        |          |1 = Enable INT_RDA
S     * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable
S     * |        |          |0 = Mask off INT_THRE
S     * |        |          |1 = Enable INT_THRE
S     * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable 
S     * |        |          |0 = Mask off INT_RLS
S     * |        |          |1 = Enable INT_RLS
S     * |[3]     |Modem_IEN |Modem Status Interrupt Enable 
S     * |        |          |0 = Mask off INT_MOS
S     * |        |          |1 = Enable INT_MOS
S     * |[4]     |RTO_IEN   |Rx Time out Interrupt Enable
S     * |        |          |0 = Mask off INT_tout
S     * |        |          |1 = Enable INT_tout 
S     * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable
S     * |        |          |0 = Mask off INT_Buf_err
S     * |        |          |1 = Enable INT_Buf_err
S     * |[6]     |Wake_EN   |Wake up CPU function enable 
S     * |        |          |0 = Disable UART wake up CPU function
S     * |        |          |1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS 
S     * |        |          |change will wake up CPU from deep sleep mode.
S     * |[11]    |Time_Out_EN|Time-Out Counter Enable
S     * |        |          |1 = Enable Time-out counter.
S     * |        |          |0 = Disable Time-out counter.
S     * |[12]    |Auto_RTS_EN|RTS Auto Flow Control Enable 
S     * |        |          |1 = Enable RTS auto flow control.
S     * |        |          |0 = Disable RTS auto flow control.
S     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR 
S     * |[RTS_Tri_Lev], the UART will dessert RTS signal.|[13]      |Auto_CTS_EN
S     * |        |          |CTS Auto Flow Control Enable
S     * |        |          |1 = Enable CTS auto flow control.
S     * |        |          |0 = Disable CTS auto flow control.
S     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input 
S     * |        |          |assert (UART will not send data to device until CTS is asserted).
S     */    
S    __IO uint32_t IER;                  
S
S    /**
S     * FCR
S     * ===================================================================================================
S     * Offset: 0x08  UART FIFO Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RFR       |Rx Software Reset
S     * |        |          |When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are 
S     * |        |          |cleared.
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
S     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
S     * |[2]     |TFR       |Tx Software Reset
S     * |        |          |When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are 
S     * |        |          |cleared.
S     * |        |          |0 = Writing 0 to this bit has no effect.
S     * |        |          |1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
S     * |        |          |Note: This bit will auto clear and takes at least 3 UART engine clock cycles.
S     * |[7:4]   |RFITL     |Word Length Select
S     * |        |          |INTR_RDA Tigger Level(Bytes)
S     * |        |          |0000 = 01 Bytes
S     * |        |          |0001 = 04 Bytes
S     * |        |          |0010 = 08 Bytes
S     * |        |          |0011 = 14 Bytes
S     * |[8]     |RX_DIS    |Receiver Disable register.
S     * |        |          |The receiver is disabled or not (set 1 is disable receiver)
S     * |        |          |1: Disable Receiver
S     * |        |          |0: Enable Receiver
S     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before 
S     * |        |          |RS-485 enable function in UA_FUN_SEL. FUN_SEL is programmed.
S     * |[19:16] |RTS_Tri_Lev|Word Length Select
S     * |        |          |0000 = 01 Bytes
S     * |        |          |0001 = 04 Bytes
S     * |        |          |0010 = 08 Bytes
S     * |        |          |0011 = 14 Bytes
S     */    
S    __IO uint32_t FCR;                  
S
S    /**
S     * LCR
S     * ===================================================================================================
S     * Offset: 0x0C  UART Line Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WLS       |Word Length Select
S     * |        |          |00 = 5 bits
S     * |        |          |01 = 6 bits
S     * |        |          |10 = 7 bits
S     * |        |          |11 = 8 bits
S     * |[2]     |NSB       |Number of "STOP bit"
S     * |        |          |0= One "STOP bit" is generated in the transmitted data
S     * |        |          |1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
S     * |        |          |Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.
S     * |[3]     |PBE       |Parity Bit Enable
S     * |        |          |0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
S     * |        |          |1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.
S     * |[4]     |EPE       |Even Parity Enable
S     * |        |          |0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
S     * |        |          |1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
S     * |        |          |This bit has effect only when bit 3 (parity bit enable) is set.
S     * |[5]     |SPE       |Stick Parity Enable 
S     * |        |          |0 = Disable stick parity 
S     * |        |          |1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When 
S     * |        |          |PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.
S     * |[6]     |BCB       |Break Control Bit 
S     * |        |          |When this bit is set to logic 1, the serial data output (Tx) is forced to the Spacing State (logic 0). This bit 
S     * |        |          |acts only on Tx and has no effect on the transmitter logic.
S     */    
S    __IO uint32_t LCR;                  
S
S    /**
S     * MCR
S     * ===================================================================================================
S     * Offset: 0x10  UART Modem Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RTS       |RTS (Request-To-Send) Signal 
S     * |        |          |0: Drive RTS pin to logic 1 (If the Lev_RTS set to low level triggered).
S     * |        |          |1: Drive RTS pin to logic 0 (If the Lev_RTS set to low level triggered).
S     * |        |          |0: Drive RTS pin to logic 0 (If the Lev_RTS set to high level triggered).
S     * |        |          |1: Drive RTS pin to logic 1 (If the Lev_RTS set to high level triggered).
S     * |[9]     |Lev_RTS   |RTS Trigger Level 
S     * |        |          |This bit can change the RTS trigger level.
S     * |        |          |0= low level triggered
S     * |        |          |1= high level triggered
S     * |[13]    |RTS_St    |RTS Pin State 
S     * |        |          |This bit is the pin status of RTS.
S     */    
S    __IO uint32_t MCR;                  
S
S    /**
S     * MSR
S     * ===================================================================================================
S     * Offset: 0x14  UART Modem Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DCTSF     |Detect CTS State Change Flag 
S     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU 
S     * |        |          |when IER [Modem_IEN].
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[4]     |CTS_St    |CTS Pin Status 
S     * |        |          |This bit is the pin status of CTS. 
S     * |[8]     |Lev_CTS   |CTS Trigger Level
S     * |        |          |This bit can change the CTS trigger level.
S     * |        |          |0= low level triggered
S     * |        |          |1= high level triggered
S     */    
S    __IO uint32_t MSR;                  
S
S    /**
S     * FSR
S     * ===================================================================================================
S     * Offset: 0x18  UART FIFO Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |Rx_Over_IF|Rx overflow Error IF (Read Only) 
S     * |        |          |This bit is set when Rx FIFO overflow.
S     * |        |          |If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 16 bytes of 
S     * |        |          |UART0/UART1, this bit will be set.
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[3]     |RS-       |485_Add_Det
S     * |        |          |RS-485 Address Byte Detection Flag
S     * |        |          |This bit is set to logic 1 and set UA_RS-485_CSR [RS-485_Add_EN] whenever in RS-485 
S     * |        |          |mode the receiver detect any address byte received address byte character (bit9 = '1') bit", 
S     * |        |          |and it is reset whenever the CPU writes 1 to this bit.
S     * |        |          |Note: This field is used for RS-485 mode.
S     * |[4]     |PEF       |Parity Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", 
S     * |        |          |and is reset whenever the CPU writes 1 to this bit.
S     * |[5]     |FEF       |Framing Error Flag
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that 
S     * |        |          |is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset 
S     * |        |          |whenever the CPU writes 1 to this bit.
S     * |[6]     |BIF       |Break Interrupt Flag
S     * |        |          |This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" 
S     * |        |          |(logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data 
S     * |        |          |bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
S     * |[13:8]  |Rx_Pointer|Rx FIFO pointer (Read Only)
S     * |        |          |This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external 
S     * |        |          |device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer 
S     * |        |          |decreases one.
S     * |[14]    |Rx_Empty  |Receiver FIFO Empty (Read Only)
S     * |        |          |This bit initiate Rx FIFO empty or not.
S     * |        |          |When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be 
S     * |        |          |cleared when UART receives any new data.
S     * |[15]    |Rx_Full   |Receiver FIFO Full (Read Only)
S     * |        |          |This bit initiates Rx FIFO full or not.
S     * |        |          |This bit is set when Rx_Pointer is equal to 16(UART0/UART1), otherwise is cleared by 
S     * |        |          |hardware.
S     * |[21:16] |Tx_Pointer|TX FIFO Pointer (Read Only)
S     * |        |          |This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, 
S     * |        |          |Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift 
S     * |        |          |Register, Tx_Pointer decreases one.
S     * |[22]    |Tx_Empty  |Transmitter FIFO Empty (Read Only)
S     * |        |          |This bit indicates Tx FIFO empty or not.
S     * |        |          |When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware 
S     * |        |          |sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).
S     * |[23]    |Tx_Full   |Transmitter FIFO Full (Read Only)
S     * |        |          |This bit indicates Tx FIFO full or not.
S     * |        |          |This bit is set when Tx_Pointer is equal to 64/16(UART0/UART1), otherwise is cleared by 
S     * |        |          |hardware.
S     * |[24]    |Tx_Over_IF|Tx Overflow Error Interrupt Flag (Read Only)
S     * |        |          |If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
S     * |        |          |NOTE: This bit is cleared by writing 1 to itself.
S     * |[28]    |TE_Flag   |Transmitter Empty Flag (Read Only)
S     * |        |          |Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte 
S     * |        |          |has been transmitted.
S     * |        |          |Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not 
S     * |        |          |completed.
S     * |        |          |NOTE: This bit is read only. 
S     */    
S    __IO uint32_t FSR;                  
S
S    /**
S     * ISR
S     * ===================================================================================================
S     * Offset: 0x1C  UART Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only).
S     * |        |          |When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If 
S     * |        |          |IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
S     * |        |          |NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO 
S     * |        |          |drops below the threshold level (RFITL).
S     * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only). 
S     * |        |          |This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If 
S     * |        |          |IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and it will be cleared when writing data into THR (Tx FIFO not empty).
S     * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only).
S     * |        |          |In UART mode this bit is set when the Rx receive data have parity error, framing error or break 
S     * |        |          |error (at least one of 3 bits, BIF, FEF and PEF, is set). In RS-485 mode, the field includes RS-485 
S     * |        |          |Address Byte Detection Flag. If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS-485_Add_Det 
S     * |        |          |are cleared.
S     * |[3]     |Modem_IF  |MODEM Interrupt Flag (Read Only) 
S     * |        |          |This bit is set when the CTS pin has state change (DCTSF=1). If IER[Modem_IEN] is enabled, the 
S     * |        |          |Modem interrupt will be generated.
S     * |        |          |NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.
S     * |[4]     |Tout_IF   |Time Out Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Rx FIFO is not empty and no activities occur in the Rx FIFO and the time 
S     * |        |          |out counter equal to TOIC. If IER [Tout_IEN] is enabled, the Tout interrupt will be generated. 
S     * |        |          |NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.
S     * |[5]     |Buf_Err_IF|Buffer Error Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When 
S     * |        |          |Buf_Err_IF is set, the transfer maybe not correct. If IER[Buf_Err_IEN] is enabled, the buffer error 
S     * |        |          |interrupt will be generated.
S     * |        |          |NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared. 
S     * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator to Interrupt Controller (INT_RDA).
S     * |        |          |An AND output with inputs of RDA_IEN and RDA_IF
S     * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller (INT_THRE).
S     * |        |          |An AND output with inputs of THRE_IEN and THRE_IF
S     * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator to Interrupt Controller (INT_RLS). 
S     * |        |          |An AND output with inputs of RLS_IEN and RLS_IF
S     * |        |          |Note: In RS-485 mode, the field includes RS-485 Address Byte Detection Flag.
S     * |[11]    |Modem_INT |MODEM Status Interrupt Indicator to Interrupt Controller (INT_MOS). 
S     * |        |          |An AND output with inputs of Modem_IEN and Modem_IF
S     * |[12]    |Tout_INT  |Time Out Interrupt Indicator to Interrupt Controller (INT_Tout)
S     * |        |          |An AND output with inputs of RTO_IEN and Tout_IF
S     * |[13]    |Buf_Err_INT|Buffer Error Interrupt Indicator to Interrupt Controller (INT_Buf_err)
S     * |        |          |An AND output with inputs of BUF_ERR_IEN and Buf_Err_IF
S     */    
S    __IO uint32_t ISR;                  
S
S    /**
S     * TOR
S     * ===================================================================================================
S     * Offset: 0x20  UART Time Out Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6:0]   |TOIC      |Time Out Interrupt Comparator
S     * |        |          |The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO 
S     * |        |          |receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out 
S     * |        |          |interrupt comparator (TOIC), a receiver time out interrupt (INT_TOUT) is generated if UA_IER[RTO_IEN]. 
S     * |        |          |A new incoming data word or RX FIFO empty clears INT_TOUT. 
S     * |[15:8]  |DLY       |TX Delay time value
S     * |        |          |This field is use to programming the transfer delay time between the last stop bit leaving the TX-FIFO 
S     * |        |          |and the de-assertion of by setting UA_TOR. DLY register.
S     */    
S    __IO uint32_t TOR;                  
S
S    /**
S     * BAUD
S     * ===================================================================================================
S     * Offset: 0x24  UART Baud Rate Divisor Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |BRD_LowByte|Baud Rate Divider 
S     * |        |          |The low byte of the baud rate divider
S     * |[15:8]  |BRD_HighByte|Baud Rate Divider 
S     * |        |          |The high byte of the baud rate divider
S     * |[27:24] |Divider_X |Divider X
S     * |        |          |The baud rate divider M = X+1.
S     * |[28]    |DIV_X_ONE |Divider X equal 1
S     * |        |          |0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must > 8)
S     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must > 3).
S     * |[29]    |DIV_X_EN  |Divider X Enable
S     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is  
S     * |        |          |Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
S     * |        |          |0 = Disable divider X (the equation of M = 16)
S     * |        |          |1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must > 8).
S     * |        |          |NOTE: When in IrDA mode, this bit must disable.
S     */    
S    __IO uint32_t BAUD;                 
S
S    /**
S     * IRCR
S     * ===================================================================================================
S     * Offset: 0x28  UART IrDA Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |Tx_SELECT |Tx_SELECT
S     * |        |          |1: Enable IrDA transmitter
S     * |        |          |0: Enable IrDA receiver
S     * |[2]     |LB        |IrDA loop back mode for self test.
S     * |        |          |1: Enable IrDA loop back mode
S     * |        |          |0: Disable IrDA loop back mode
S     * |[5]     |INV_Tx    |INV_Tx
S     * |        |          |1= Inverse Tx output signal
S     * |        |          |0= No inversion
S     * |[6]     |INV_Rx    |INV_Rx
S     * |        |          |1= Inverse Rx input signal
S     * |        |          |0= No inversion
S     */    
S    __IO uint32_t IRCR;                 
S
S    /**
S     * ALT_CSR
S     * ===================================================================================================
S     * Offset: 0x2C  UART Alternate Control/Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8]     |RS-485_NMM|RS-485 Normal Multi-drop Operation Mode (NMM)
S     * |        |          |1: Enable RS-485 Normal Multi-drop Operation Mode (NMM)
S     * |        |          |0: Disable RS-485 Normal Multi-drop Operation Mode (NMM)
S     * |        |          |Note: It can't be active with RS-485_AAD operation mode.
S     * |[9]     |RS-485_AAD|RS-485 Auto Address Detection Operation Mode (AAD)
S     * |        |          |1: Enable RS-485 Auto Address Detection Operation Mode (AAD)
S     * |        |          |0: Disable RS-485 Auto Address Detection Operation Mode (AAD)
S     * |        |          |Note: It can't be active with RS-485_NMM operation mode.
S     * |[10]    |RS-485_AUD|RS-485 Auto Direction Mode (AUD)
S     * |        |          |1: Enable RS-485 Auto Direction Mode (AUD)
S     * |        |          |0: Disable RS-485 Auto Direction Mode (AUD)
S     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
S     * |[15]    |RS-485_Add_EN|RS-485 Address Detection Enable
S     * |        |          |This bit is use to enable RS-485 address detection mode. 
S     * |        |          |1: Enable address detection mode
S     * |        |          |0: Disable address detection mode 
S     * |        |          |Note: This field is used for RS-485 any operation mode.
S     * |[31:24] |ADDR_MATCH|Address match value register
S     * |        |          |This field contains the RS-485 address match values.
S     * |        |          |Note: This field is used for RS-485 auto address detection mode.
S     */    
S    __IO uint32_t ALT_CSR;               
S
S    /**
S     * FUN_SEL
S     * ===================================================================================================
S     * Offset: 0x30  UART Function Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |FUN_SEL   |Function Select Enable
S     * |        |          |00 = UART Function.
S     * |        |          |01 = Reserved.
S     * |        |          |10 = Enable IrDA Function.
S     * |        |          |11 = Enable RS-485 Function.
S     */    
S    __IO uint32_t FUN_SEL;               
S    __IO uint32_t LIN_CTL; 
S    __IO uint32_t LIN_SR; 
S} UART_T;
S
S
S
S
S/* UART THR Bit Field Definitions */
S#define UART_THR_THR_Pos         0                                          /*!< UART THR: THR Position  */
S#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART THR: THR Mask      */
S
S/* UART RBR Bit Field Definitions */
S#define UART_RBR_RBR_Pos         0                                          /*!< UART RBR: RBR Posistion */
S#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART RBR: RBR Mask      */
S
S/* UART IER Bit Field Definitions */
S#define UART_IER_DMA_RX_EN_Pos      15                                      /*!< UART IER: RX DMA Enable Posistion */  
S#define UART_IER_DMA_RX_EN_Msk      (1ul << UART_IER_DMA_RX_EN_Pos)         /*!< UART IER: RX DMA Enable Mask      */  
S
S#define UART_IER_DMA_TX_EN_Pos      14                                      /*!< UART IER: TX DMA Enable Posistion */  
S#define UART_IER_DMA_TX_EN_Msk      (1ul << UART_IER_DMA_TX_EN_Pos)         /*!< UART IER: TX DMA Enable Mask      */  
S
S#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART IER: AUTO_CTS_EN Posistion      */
S#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART IER: AUTO_CTS_EN Mask           */
S
S#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART IER: AUTO_RTS_EN Posistion      */
S#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART IER: AUTO_RTS_EN Mask           */
S
S#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART IER: TIME_OUT_EN Posistion      */
S#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART IER: TIME_OUT_EN Mask           */
S
S#define UART_IER_LIN_RX_BRK_IEN_Pos 8                                       /*!< UART IER: LIN_RX_BRK_IEN Posistion   */
S#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)    /*!< UART IER: LIN_RX_BRK_IEN Mask        */
S
S#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART IER: WAKE_EN Posistion          */
S#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART IER: WAKE_EN Mask               */
S
S#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART IER: BUF_ERR_IEN Posistion      */
S#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART IER: BUF_ERR_IEN Mask           */
S
S#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART IER: RTO_IEN Posistion          */
S#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART IER: RTO_IEN Mask               */
S
S#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART IER: MODEM_IEN Posistion        */
S#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART IER: MODEM_IEN Mask             */
S
S#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART IER: RLS_IEN Posistion          */
S#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART IER: RLS_IEN Mask               */
S
S#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART IER: THRE_IEN Posistion         */
S#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART IER: THRE_IEN Mask              */
S
S#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART IER: RDA_IEN Position           */
S#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART IER: RDA_IEN Mask               */
S
S/* UART FCR Bit Field Definitions */
S#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART FCR: RTS_TRI_LEV Position       */
S#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART FCR: RTS_TRI_LEV Mask           */
S
S#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART FCR: RX_DIS Position            */
S#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART FCR: RX_DIS Mask                */
S
S#define UART_FCR_RFITL_Pos          4                                       /*!< UART FCR: RFITL Position             */
S#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART FCR: RFITL Mask                 */
S
S#define UART_FCR_TFR_Pos            2                                       /*!< UART FCR: TFR Position               */
S#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART FCR: TFR Mask                   */
S
S#define UART_FCR_RFR_Pos            1                                       /*!< UART FCR: RFR Position               */
S#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART FCR: RFR Mask                   */
S
S/* UART LCR Bit Field Definitions */
S#define UART_LCR_BCB_Pos            6                                       /*!< UART LCR: BCB Position               */
S#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART LCR: BCB Mask                   */
S
S#define UART_LCR_SPE_Pos            5                                       /*!< UART LCR: SPE Position               */
S#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART LCR: SPE Mask                   */
S
S#define UART_LCR_EPE_Pos            4                                       /*!< UART LCR: EPE Position               */
S#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART LCR: EPE Mask                   */
S
S#define UART_LCR_PBE_Pos            3                                       /*!< UART LCR: PBE Position               */
S#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART LCR: PBE Mask                   */
S
S#define UART_LCR_NSB_Pos            2                                       /*!< UART LCR: NSB Position               */
S#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART LCR: NSB Mask                   */
S
S#define UART_LCR_WLS_Pos            0                                       /*!< UART LCR: WLS Position               */
S#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART LCR: WLS Mask                   */
S
S/* UART MCR Bit Field Definitions */
S#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART MCR: RTS_ST Position            */
S#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART MCR: RTS_ST Mask                */
S
S#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART MCR: LEV_RTS Position           */
S#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART MCR: LEV_RTS Mask               */
S
S#define UART_MCR_RTS_Pos            1                                       /*!< UART MCR: RTS Position               */
S#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART MCR: RTS Mask                   */
S
S/* UART MSR Bit Field Definitions */
S#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART MSR: LEV_CTS Position           */
S#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART MSR: LEV_CTS Mask               */
S
S#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART MSR: CTS_ST Position            */
S#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART MSR: CTS_ST Mask                */
S
S#define UART_MSR_DCTSF_Pos          0                                       /*!< UART MSR: DCTST Position             */
S#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART MSR: DCTST Mask                 */
S
S
S/* UART FSR Bit Field Definitions */
S#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART FSR: TE_FLAG Position           */
S#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART FSR: TE_FLAG Mask               */
S
S#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART FSR: TX_OVER_IF Position        */
S#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART FSR: TX_OVER_IF Mask            */
S
S#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART FSR: TX_FULL Position           */
S#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART FSR: TX_FULL Mask               */
S
S#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART FSR: TX_EMPTY Position          */
S#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART FSR: TX_EMPTY Mask              */
S
S#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART FSR: TX_POINTER Position        */
S#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART FSR: TX_POINTER Mask            */
S
S#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART FSR: RX_FULL Position           */
S#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART FSR: RX_FULL Mask               */
S
S#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART FSR: RX_EMPTY Position          */
S#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART FSR: RX_EMPTY Mask              */
S
S#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART FSR: RX_POINTERS Position       */
S#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART FSR: RX_POINTER Mask            */
S
S#define UART_FSR_BIF_Pos            6                                       /*!< UART FSR: BIF Position               */
S#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART FSR: BIF Mask                   */
S
S#define UART_FSR_FEF_Pos            5                                       /*!< UART FSR: FEF Position               */
S#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART FSR: FEF Mask                   */
S
S#define UART_FSR_PEF_Pos            4                                       /*!< UART FSR: PEF Position               */
S#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART FSR: PEF Mask                   */
S
S#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART FSR: RS485_ADD_DETF Position    */
S#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART FSR: RS485_ADD_DETF Mask        */
S
S#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART FSR: RX_OVER_IF Position        */
S#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART FSR: RX_OVER_IF Mask            */
S
S/* UART ISR Bit Field Definitions */
S#define UART_ISR_HW_LIN_RX_BREAK_INT_Pos   31                                           /*!< UART ISR: HW LIN_RX_BREAK_INT Position       */
S#define UART_ISR_HW_LIN_RX_BREAK_INT_Msk   (1ul << UART_ISR_HW_LIN_RX_BREAK_INT_Pos)    /*!< UART ISR: HW LIN_RX_BREAK_INT Mask           */
S
S#define UART_ISR_HW_BUF_ERR_INT_Pos        29                                       /*!< UART ISR: HW BUF_ERR_INT Position       */
S#define UART_ISR_HW_BUF_ERR_INT_Msk        (1ul << UART_ISR_HW_BUF_ERR_INT_Pos)     /*!< UART ISR: HW BUF_ERR_INT Mask           */
S
S#define UART_ISR_HW_TOUT_INT_Pos           28                                       /*!< UART ISR: HW TOUT_INT Position          */
S#define UART_ISR_HW_TOUT_INT_Msk           (1ul << UART_ISR_HW_TOUT_INT_Pos)        /*!< UART ISR: HW TOUT_INT Mask              */
S
S#define UART_ISR_HW_MODEM_INT_Pos          27                                       /*!< UART ISR: HW MODEM_INT Position         */
S#define UART_ISR_HW_MODEM_INT_Msk          (1ul << UART_ISR_HW_MODEM_INT_Pos)       /*!< UART ISR: HW MODEM_INT Mask             */
S    
S#define UART_ISR_HW_RLS_INT_Pos            26                                       /*!< UART ISR: HW RLS_INT Position           */
S#define UART_ISR_HW_RLS_INT_Msk            (1ul << UART_ISR_HW_RLS_INT_Pos)         /*!< UART ISR: HW RLS_INT Position           */
S
S#define UART_ISR_HW_LIN_RX_BREAK_IF_Pos    23                                       /*!< UART ISR: HW LIN_RX_BREAK_IF Position  */
S#define UART_ISR_HW_LIN_RX_BREAK_IF_Msk    (1ul << UART_ISR_HW_LIN_RX_BREAK_IF_Pos) /*!< UART ISR: HW LIN_RX_BREAK_IF Mask      */
S
S#define UART_ISR_HW_BUF_ERR_IF_Pos         21                                       /*!< UART ISR: HW BUF_ERR_IF Position       */
S#define UART_ISR_HW_BUF_ERR_IF_Msk         (1ul << UART_ISR_HW_BUF_ERR_IF_Pos)      /*!< UART ISR: HW BUF_ERR_IF Mask           */
S
S#define UART_ISR_HW_TOUT_IF_Pos            20                                       /*!< UART ISR: HW TOUT_IF Position          */
S#define UART_ISR_HW_TOUT_IF_Msk            (1ul << UART_ISR_HW_TOUT_IFF_Pos)        /*!< UART ISR: HW TOUT_IF Mask              */
S
S#define UART_ISR_HW_MODEM_IF_Pos           19                                       /*!< UART ISR: HW MODEM_IF Position         */
S#define UART_ISR_HW_MODEM_IF_Msk           (1ul << UART_ISR_HW_MODEM_IF_Pos)        /*!< UART ISR: HW MODEM_IF Mask             */
S
S#define UART_ISR_HW_RLS_IF_Pos             18                                       /*!< UART ISR: HW RLS_IF Position           */
S#define UART_ISR_HW_RLS_IF_Msk             (1ul << UART_ISR_HW_RLS_IF_Pos)          /*!< UART ISR: HW RLS_IF Mark               */
S
S#define UART_ISR_LIN_RX_BREAK_INT_Pos    15                                      /*!< UART ISR: LIN_RX_BREAK_INT Position       */
S#define UART_ISR_LIN_RX_BREAK_INT_Msk    (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)  /*!< UART ISR: LIN_RX_BREAK_INT Mask           */
S
S#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART ISR: BUF_ERR_INT Position       */
S#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART ISR: BUF_ERR_INT Mask           */
S
S#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART ISR: TOUT_INT Position          */
S#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART ISR: TOUT_INT Mask              */
S
S#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART ISR: MODEM_INT Position         */
S#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART ISR: MODEM_INT Mask             */
S
S#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART ISR: RLS_INT Position           */
S#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART ISR: RLS_INT Mask               */
S
S#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART ISR: THRE_INT Position          */
S#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART ISR: THRE_INT Mask              */
S
S#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART ISR: RDA_INT Position           */
S#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART ISR: RDA_INT Mask               */
S
S#define UART_ISR_LIN_RX_BREAK_IF_Pos 7                                      /*!< UART ISR: LIN RX BREAK IF Position   */
S#define UART_ISR_LIN_RX_BREAK_IF_Msk (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)  /*!< UART ISR: LIN RX BREAK IF Mask       */
S           
S#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART ISR: BUF_ERR_IF Position        */
S#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART ISR: BUF_ERR_IF Mask            */
S
S#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART ISR: TOUT_IF Position           */
S#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART ISR: TOUT_IF Mask               */
S
S#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART ISR: MODEM_IF Position          */
S#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART ISR: MODEM_IF Mask              */
S
S#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART ISR: RLS_IF Position            */
S#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART ISR: RLS_IF Mask                */
S
S#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART ISR: THRE_IF Position           */
S#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART ISR: THRE_IF Mask               */
S
S#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART ISR: RDA_IF Position            */
S#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART ISR: RDA_IF Mask                */
S
S
S/* UART TOR Bit Field Definitions */
S#define UART_TOR_DLY_Pos           8                                        /*!< UART TOR: DLY Position               */
S#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART TOR: DLY Mask                   */
S
S#define UART_TOR_TOIC_Pos          0                                        /*!< UART TOR: TOIC Position              */
S#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)
S
S/* UART BAUD Bit Field Definitions */
S#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
S#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
S
S#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
S#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
S
S#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
S#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
S
S#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
S#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
S
S/* UART IRCR Bit Field Definitions */
S#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART IRCR: INV_RX Position           */
S#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART IRCR: INV_RX Mask               */
S
S#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART IRCR: INV_TX Position           */
S#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART IRCR: INV_TX Mask               */
S
S#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART IRCR: TX_SELECT Position        */
S#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART IRCR: TX_SELECT Mask            */
S
S/* UART ALT_CSR Bit Field Definitions */
S#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART ALT_CSR: ADDR_MATCH Position    */
S#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART ALT_CSR: ADDR_MATCH Mask        */
S
S#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART ALT_CSR: RS485_ADD_EN Position  */
S#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART ALT_CSR: RS485_ADD_EN Mask      */
S
S#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART ALT_CSR: RS485_AUD Position     */
S#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART ALT_CSR: RS485_AUD Mask         */
S
S#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART ALT_CSR: RS485_AAD Position     */
S#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART ALT_CSR: RS485_AAD Mask         */
S
S#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART ALT_CSR: RS485_NMM Position     */
S#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART ALT_CSR: RS485_NMM Mask         */
S
S#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART ALT_CSR: LIN TX Break Mode Enable Position     */
S#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART ALT_CSR: LIN TX Break Mode Enable Mask         */
S
S#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART ALT_CSR: LIN RX Enable Position     */
S#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART ALT_CSR: LIN RX Enable Mask         */
S
S#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART ALT_CSR: UART LIN Break Field Length Position     */
S#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART ALT_CSR: UART LIN Break Field Length Mask         */
S
S/* UART FUN_SEL Bit Field Definitions */
S#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART FUN_SEL: FUN_SEL Position       */
S#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART FUN_SEL: FUN_SEL Mask           */
S
S/* UART LIN_CTL Bit Field Definitions */
S#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART LIN_CTL: LIN_PID Position       */
S#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART LIN_CTL: LIN_PID Mask           */
S
S#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART LIN_CTL: LIN_HEAD_SEL Position       */
S#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART LIN_CTL: LIN_HEAD_SEL Mask           */
S
S#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART LIN_CTL: LIN_BS_LEN Position       */
S#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART LIN_CTL: LIN_BS_LEN Mask           */
S
S#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART LIN_CTL: LIN_BKFL Position       */
S#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART LIN_CTL: LIN_BKFL Mask           */
S
S#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART LIN_CTL: BIT_ERR_EN Position       */
S#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART LIN_CTL: BIT_ERR_EN Mask           */
S
S#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART LIN_CTL: LIN_RX_DIS Position       */
S#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART LIN_CTL: LIN_RX_DIS Mask           */
S
S#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART LIN_CTL: LIN_BKDET_EN Position       */
S#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART LIN_CTL: LIN_BKDET_EN Mask           */
S
S#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART LIN_CTL: LIN_IDPEN Position       */
S#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART LIN_CTL: LIN_IDPEN Mask           */
S
S#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART LIN_CTL: LIN_SHD Position       */
S#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART LIN_CTL: LIN_SHD Mask           */
S
S#define UART_LIN_CTL_LIN_WAKE_EN_Pos    4                                          /*!< UART LIN_CTL: LIN_WAKE_EN Position       */
S#define UART_LIN_CTL_LIN_WAKE_EN_Msk    (1ul << UART_LIN_CTL_LIN_WAKE_EN_Pos)      /*!< UART LIN_CTL: LIN_WAKE_EN Mask           */
S
S#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART LIN_CTL: LINS_DUM_EN Position       */
S#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART LIN_CTL: LINS_DUM_EN Mask           */
S
S#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART LIN_CTL: LINS_ARS_EN Position       */
S#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART LIN_CTL: LINS_ARS_EN Mask           */
S
S#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART LIN_CTL: LINS_HDET_EN Position       */
S#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART LIN_CTL: LINS_HDET_EN Mask           */
S
S#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART LIN_CTL: LINS_EN Position       */
S#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART LIN_CTL: LINS_EN Mask           */
S
S/* UART LIN_SR Bit Field Definitions */
S#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART LIN_SR: LINS_SYNC_F Position       */
S#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART LIN_SR: LINS_SYNC_F Mask           */
S
S#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART LIN_SR: LINS_IDPERR_F Position       */
S#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART LIN_SR: LINS_IDPERR_F Mask           */
S
S#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART LIN_SR: LINS_HERR_F Position       */
S#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART LIN_SR: LINS_HERR_F Mask           */
S
S#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART LIN_SR: LINS_HDET_F Position       */
S#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART LIN_SR: LINS_HDET_F Mask           */
S
S/*@}*/ /* end of group NUC200_UART */
S
S
S/*----------------------------- Timer Controller (TMR) -----------------------------*/
S/** @addtogroup NUC200_TIMER NUC200 TIMER
S  Memory Mapped Structure for NUC200 Series Timer Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * TCSR
S     * ===================================================================================================
S     * Offset: 0x00  Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TCSR;                
S
S    /**
S     * TCMPR
S     * ===================================================================================================
S     * Offset: 0x04  Timer Compare Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TCMPR;		        
S
S    /**
S     * TISR
S     * ===================================================================================================
S     * Offset: 0x08  Timer Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TISR;		        
S
S    /**
S     * TDR
S     * ===================================================================================================
S     * Offset: 0x0C  Timer Data Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  TDR;			        
S
S    /**
S     * TCAP
S     * ===================================================================================================
S     * Offset: 0x10  Timer Capture Data Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  TCAP;		        
S
S    /**
S     * TEXCON
S     * ===================================================================================================
S     * Offset: 0x14  Timer External Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TEXCON;	            
S
S    /**
S     * TEXISR
S     * ===================================================================================================
S     * Offset: 0x18  Timer External Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  TEXISR;	            
S} TIMER_T;
S
S/* TIMER TCSR Bit Field Definitions */
S#define TIMER_TCSR_DBGACK_TMR_Pos   31											/*!< TIMER TCSR: DBGACK_TMR Position */
S#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER TCSR: DBGACK_TMR Mask */
S
S#define TIMER_TCSR_CEN_Pos          30											/*!< TIMER TCSR: CEN Position */
S#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)				    /*!< TIMER TCSR: CEN Mask */
S
S#define TIMER_TCSR_IE_Pos           29											/*!< TIMER TCSR: IE Position */
S#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)					/*!< TIMER TCSR: IE Mask */
S                                                                                 
S#define TIMER_TCSR_MODE_Pos         27											/*!< TIMER TCSR: MODE Position */
S#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)				/*!< TIMER TCSR: MODE Mask */
S
S#define TIMER_TCSR_CRST_Pos         26											/*!< TIMER TCSR: CRST Position */
S#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)				/*!< TIMER TCSR: CRST Mask */
S
S#define TIMER_TCSR_CACT_Pos         25											/*!< TIMER TCSR: CACT Position */
S#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)				/*!< TIMER TCSR: CACT Mask */
S
S#define TIMER_TCSR_CTB_Pos          24											/*!< TIMER TCSR: CTB Position */
S#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)					/*!< TIMER TCSR: CTB Mask */
S
S#define TIMER_TCSR_WAKE_EN_Pos      23											/*!< TIMER TCSR: WAKE_EN Position */
S#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)			    /*!< TIMER TCSR: WAKE_EN Mask */
S
S#define TIMER_TCSR_TDR_EN_Pos       16											/*!< TIMER TCSR: TDR_EN Position */
S#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)				/*!< TIMER TCSR: TDR_EN Mask */
S
S#define TIMER_TCSR_PRESCALE_Pos     0											/*!< TIMER TCSR: PRESCALE Position */
S#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)			/*!< TIMER TCSR: PRESCALE Mask */
S
S/* TIMER TCMPR Bit Field Definitions */
S#define TIMER_TCMP_TCMP_Pos         0											/*!< TIMER TCMPR: TCMP Position */
S#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)		    /*!< TIMER TCMPR: TCMP Mask */
S
S/* TIMER TISR Bit Field Definitions */
S#define TIMER_TISR_TWF_Pos          1											/*!< TIMER TISR: TWF Position */
S#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)					/*!< TIMER TISR: TWF Mask */
S
S#define TIMER_TISR_TIF_Pos          0											/*!< TIMER TISR: TIF Position */
S#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)					/*!< TIMER TISR: TIF Mask */
S
S/* TIMER TDR Bit Field Definitions */
S#define TIMER_TDR_TDR_Pos           0								            /*!< TIMER TDR: TDR Position */
S#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)	        /*!< TIMER TDR: TDR Mask */
S
S/* TIMER TCAP Bit Field Definitions */
S#define TIMER_TCAP_TCAP_Pos         0									        /*!< TIMER TCAP: TCAP Position */
S#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER TCAP: TCAP Mask */
S
S/* TIMER TEXCON Bit Field Definitions */
S#define TIMER_TEXCON_TCDB_Pos       7											/*!< TIMER TEXCON: TCDB Position */
S#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)				/*!< TIMER TEXCON: TCDB Mask */
S
S#define TIMER_TEXCON_TEXDB_Pos      6											/*!< TIMER TEXCON: TEXDB Position */
S#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)				/*!< TIMER TEXCON: TEXDB Mask */
S
S#define TIMER_TEXCON_TEXIEN_Pos     5											/*!< TIMER TEXCON: TEXIEN Position */
S#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)			/*!< TIMER TEXCON: TEXIEN Mask */
S
S#define TIMER_TEXCON_RSTCAPSEL_Pos  4											/*!< TIMER TEXCON: RSTCAPSEL Position */
S#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)			/*!< TIMER TEXCON: RSTCAPSEL Mask */
S
S#define TIMER_TEXCON_TEXEN_Pos      3											/*!< TIMER TEXCON: TEXEN Position */
S#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)				/*!< TIMER TEXCON: TEXEN Mask */
S
S#define TIMER_TEXCON_TEX_EDGE_Pos   1											/*!< TIMER TEXCON: TEX_EDGE Position */
S#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)		/*!< TIMER TEXCON: TEX_EDGE Mask */
S
S#define TIMER_TEXCON_TX_PHASE_Pos   0											/*!< TIMER TEXCON: TX_PHASE Position */
S#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)			/*!< TIMER TEXCON: TX_PHASE Mask */
S
S/* TIMER TEXISR Bit Field Definitions */
S#define TIMER_TEXISR_TEXIF_Pos      0											/*!< TIMER TEXISR: TEXIF Position */
S#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)				/*!< TIMER TEXISR: TEXIF Mask */
S/*@}*/ /* end of group NUC200_TIMER */
S
S
S/*----------------------------- Watchdog Timer (WDT) -----------------------------*/
S/** @addtogroup NUC200_WDT NUC200 WDT
S  Memory Mapped Structure for NUC200 Series Watchdog Timer
S  @{
S */
Stypedef struct
S{
S    /**
S     * WTCR
S     * ===================================================================================================
S     * Offset: 0x00  Watchdog Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WTCR;                 
S
S    /**
S     * WTCRALT
S     * ===================================================================================================
S     * Offset: 0x04  Watchdog Timer Alternative Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WTCRALT;              
S} WDT_T;
S
S/* WDT WTCR Bit Field Definitions */
S#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT WTCR : DBGACK_WDT Position */
S#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT WTCR : DBGACK_WDT Mask */
S
S#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT WTCR : WTIS Position */
S#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT WTCR : WTIS Mask */
S
S#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT WTCR : WTE Position */
S#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT WTCR : WTE Mask */
S
S#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT WTCR : WTIE Position */
S#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT WTCR : WTIE Mask */
S
S#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT WTCR : WTWKF Position */
S#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT WTCR : WTWKF Mask */
S
S#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT WTCR : WTWKE Position */
S#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT WTCR : WTWKE Mask */
S
S#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT WTCR : WTIF Position */
S#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT WTCR : WTIF Mask */
S
S#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT WTCR : WTRF Position */
S#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT WTCR : WTRF Mask */
S
S#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT WTCR : WTRE Position */
S#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT WTCR : WTRE Mask */
S
S#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT WTCR : WTR Position */
S#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT WTCR : WTR Mask */
S
S/* WDT WTCRALT Bit Field Definitions */
S#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT WTCRALT : WTRDSEL Position */
S#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT WTCRALT : WTRDSEL Mask */
S/*@}*/ /* end of group NUC200_WDT */
S
S
S/*----------------------------- Window Watchdog Timer (WWDT) -----------------------------*/
S/** @addtogroup NUC200_WWDT NUC200 WWDT
S  Memory Mapped Structure for NUC200 Series Window Watchdog Timer
S  @{
S */
Stypedef struct
S{
S    /**
S     * WWDTRLD
S     * ===================================================================================================
S     * Offset: 0x00  Window Watchdog Timer Reload Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WWDTRLD;
S
S    /**
S     * WWDTCR
S     * ===================================================================================================
S     * Offset: 0x04  Window Watchdog Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WWDTCR;
S
S    /**
S     * WWDTSR
S     * ===================================================================================================
S     * Offset: 0x08  Window Watchdog Timer Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WWDTSR;
S
S    /**
S     * WWDTCVR
S     * ===================================================================================================
S     * Offset: 0x0C  Window Watchdog Timer Counter Value Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  WWDTCVR;
S} WWDT_T;
S
S/* WWDT WWDTRLD Bit Field Definitions */
S#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT WWDTRLD : WWDTRLD Position */
S#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT WWDTRLD : WWDTRLD Mask */
S
S/* WWDT WWDTCR Bit Field Definitions */
S#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT WWDTCR : DBGACK_WWDT Position */
S#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT WWDTCR : DBGACK_WWDT Mask */
S
S#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT WWDTCR : WINCMP Position */
S#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT WWDTCR : WINCMP Mask */
S
S#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT WWDTCR : PERIODSEL Position */
S#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT WWDTCR : PERIODSEL Mask */
S
S#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT WWDTCR : WWDTIE Position */
S#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT WWDTCR : WWDTIE Mask */
S
S#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT WWDTCR : WWDTEN Position */
S#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT WWDTCR : WWDTEN Mask */
S
S/* WWDT WWDTSR Bit Field Definitions */
S#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT WWDTSR : WWDTRF Position */
S#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT WWDTSR : WWDTRF Mask */
S
S#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT WWDTSR : WWDTIF Position */
S#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT WWDTSR : WWDTIF Mask */
S
S/* WWDT WWDTCVR Bit Field Definitions */
S#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT WWDTCVR : WWDTRF Position */
S#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT WWDTCVR : WWDTRF Mask */
S/*@}*/ /* end of group NUC200_WWDT */
S
S
S/*------------------------- SPI Interface Controller -------------------------*/
S/** @addtogroup NUC200_SPI NUC200 SPI
S  Memory Mapped Structure for NUC200 Series SPI Controller
S  @{
S */
Stypedef struct
S{
S    __IO uint32_t CNTRL;      /*!< Offset: 0x00  SPI Control and Status Register   */
S    __IO uint32_t DIVIDER;    /*!< Offset: 0x04  SPI Clock Divider Register        */
S    __IO uint32_t SSR;        /*!< Offset: 0x08  SPI Slave Select Register         */
S    __I  uint32_t RESERVE0;
S    __I  uint32_t RX[2];      /*!< Offset: 0x10  Data Receive Register             */
S    __I  uint32_t RESERVE1;
S    __I  uint32_t RESERVE2;
S    __O  uint32_t TX[2];      /*!< Offset: 0x20  Data Transmit Register            */
S    __I  uint32_t RESERVE3;
S    __I  uint32_t RESERVE4;
S    __I  uint32_t RESERVE5;
S    __IO uint32_t VARCLK;     /*!< Offset: 0x34  Variable Clock Pattern Register   */
S    __IO uint32_t DMA;        /*!< Offset: 0x38  SPI DMA Control Register          */
S    __IO uint32_t CNTRL2;     /*!< Offset: 0x3C  SPI Control and Status Register 2 */
S    __IO uint32_t FIFO_CTL;   /*!< Offset: 0x40  SPI FIFO Control Register         */
S    __IO uint32_t STATUS;     /*!< Offset: 0x44  SPI Status Register               */
S} SPI_T;
S
S
S/* SPI_CNTRL Bit Field Definitions */
S#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI CNTRL: TX_FULL Position */
S#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI CNTRL: TX_FULL Mask     */
S
S#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI CNTRL: TX_EMPTY Position */
S#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI CNTRL: TX_EMPTY Mask     */
S
S#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI CNTRL: RX_FULL Position */
S#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI CNTRL: RX_FULL Mask     */
S
S#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI CNTRL: RX_EMPTY Position */
S#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI CNTRL: RX_EMPTY Mask     */
S
S#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI CNTRL: VARCLK_EN Position */
S#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI CNTRL: VARCLK_EN Mask     */
S
S#define SPI_CNTRL_TWOB_Pos         22                                     /*!< SPI CNTRL: TWOB Position */
S#define SPI_CNTRL_TWOB_Msk         (1ul << SPI_CNTRL_TWOB_Pos)            /*!< SPI CNTRL: TWOB Mask     */
S
S#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI CNTRL: FIFO Position */
S#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI CNTRL: FIFO Mask     */
S
S#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI CNTRL: REORDER Position */
S#define SPI_CNTRL_REORDER_Msk      (1ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI CNTRL: REORDER Mask     */
S
S#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI CNTRL: SLAVE Position */
S#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI CNTRL: SLAVE Mask     */
S
S#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI CNTRL: IE Position */
S#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI CNTRL: IE Mask     */
S
S#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI CNTRL: IF Position */
S#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI CNTRL: IF Mask     */
S
S#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI CNTRL: SP_CYCLE Position */
S#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI CNTRL: SP_CYCLE Mask     */
S
S#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI CNTRL: CLKP Position */
S#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI CNTRL: CLKP Mask     */
S
S#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI CNTRL: LSB Position */
S#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI CNTRL: LSB Mask     */
S
S#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI CNTRL: TX_BIT_LEN Position */
S#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI CNTRL: TX_BIT_LEN Mask     */
S
S#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI CNTRL: TX_NEG Position */
S#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI CNTRL: TX_NEG Mask     */
S
S#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI CNTRL: RX_NEG Position */
S#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI CNTRL: RX_NEG Mask     */
S
S#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI CNTRL: GO_BUSY Position */
S#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI CNTRL: GO_BUSY Mask     */
S
S/* SPI_DIVIDER Bit Field Definitions */
S#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI DIVIDER: DIVIDER2 Position */
S#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI DIVIDER: DIVIDER2 Mask */
S
S#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI DIVIDER: DIVIDER Position */
S#define SPI_DIVIDER_DIVIDER_Msk    (0xFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI DIVIDER: DIVIDER Mask */
S
S/* SPI_SSR Bit Field Definitions */
S#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI SSR: LTRIG_FLAG Position */
S#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI SSR: LTRIG_FLAG Mask */
S
S#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI SSR: SS_LTRIG Position */
S#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI SSR: SS_LTRIG Mask */
S
S#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI SSR: AUTOSS Position */
S#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI SSR: AUTOSS Mask */
S
S#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI SSR: SS_LVL Position */
S#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI SSR: SS_LVL Mask */
S
S#define SPI_SSR_SSR_Pos            0                                 /*!< SPI SSR: SSR Position */
S#define SPI_SSR_SSR_Msk            (3ul << SPI_SSR_SSR_Pos)          /*!< SPI SSR: SSR Mask */
S
S/* SPI_DMA Bit Field Definitions */
S#define SPI_DMA_PDMA_RST_Pos   2                                     /*!< SPI DMA: PDMA_RST Position */
S#define SPI_DMA_PDMA_RST_Msk   (1ul << SPI_DMA_PDMA_RST_Pos)         /*!< SPI DMA: PDMA_RST Mask */
S
S#define SPI_DMA_RX_DMA_GO_Pos   1                                    /*!< SPI DMA: RX_DMA_GO Position */
S#define SPI_DMA_RX_DMA_GO_Msk   (1ul << SPI_DMA_RX_DMA_GO_Pos)       /*!< SPI DMA: RX_DMA_GO Mask */
S
S#define SPI_DMA_TX_DMA_GO_Pos   0                                    /*!< SPI DMA: TX_DMA_GO Position */
S#define SPI_DMA_TX_DMA_GO_Msk   (1ul << SPI_DMA_TX_DMA_GO_Pos)       /*!< SPI DMA: TX_DMA_GO Mask */
S
S/* SPI_CNTRL2 Bit Field Definitions */
S#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI CNTRL2: BCn Position */
S#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI CNTRL2: BCn Mask */
S
S#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI CNTRL2: SS_INT_OPT Position */
S#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI CNTRL2: SS_INT_OPT Mask */
S
S#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI CNTRL2: DUAL_IO_EN Position */
S#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI CNTRL2: DUAL_IO_EN Mask */
S
S#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI CNTRL2: DUAL_IO_DIR Position */
S#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI CNTRL2: DUAL_IO_DIR Mask */
S
S#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI CNTRL2: SLV_START_INTSTS Position */
S#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI CNTRL2: SLV_START_INTSTS Mask */
S
S#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI CNTRL2: SSTA_INTEN Position */
S#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI CNTRL2: SSTA_INTEN Mask */
S
S#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI CNTRL2: SLV_ABORT Position */
S#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI CNTRL2: SLV_ABORT Mask */
S
S#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI CNTRL2: NOSLVSEL Position */
S#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI CNTRL2: NOSLVSEL Mask */
S
S/* SPI_FIFO_CTL Bit Field Definitions */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI FIFO_CTL: TX_THRESHOLD Position */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: TX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI FIFO_CTL: RX_THRESHOLD Position */
S#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: RX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI FIFO_CTL: TIMEOUT_INTEN Position */
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI FIFO_CTL: TIMEOUT_INTEN Mask */
S
S#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI FIFO_CTL: RXOV_INTEN Position */
S#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI FIFO_CTL: RXOV_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI FIFO_CTL: TX_INTEN Position */
S#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI FIFO_CTL: TX_INTEN Mask */
S
S#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI FIFO_CTL: RX_INTEN Position */
S#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI FIFO_CTL: RX_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI FIFO_CTL: TX_CLR Position */
S#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI FIFO_CTL: TX_CLR Mask */
S
S#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI FIFO_CTL: RX_CLR Position */
S#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI FIFO_CTL: RX_CLR Mask */
S
S/* SPI_STATUS Bit Field Definitions */
S#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI STATUS: TX_FIFO_COUNT Position */
S#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI STATUS: TX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI STATUS: TX_FULL Position */
S#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI STATUS: TX_FULL Mask */
S
S#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI STATUS: TX_EMPTY Position */
S#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI STATUS: TX_EMPTY Mask */
S
S#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI STATUS: RX_FULL Position */
S#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI STATUS: RX_FULL Mask */
S
S#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI STATUS: RX_EMPTY Position */
S#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI STATUS: RX_EMPTY Mask */
S
S#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI STATUS: TIMEOUT Position */
S#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI STATUS: TIMEOUT Mask */
S
S#define SPI_STATUS_IF_Pos   16                                                       /*!< SPI STATUS: IF Position */
S#define SPI_STATUS_IF_Msk   (1ul << SPI_STATUS_IF_Pos)                               /*!< SPI STATUS: IF Mask     */
S
S#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI STATUS: RX_FIFO_COUNT Position */
S#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI STATUS: RX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI STATUS: SLV_START_INTSTS Position */
S#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI STATUS: SLV_START_INTSTS Mask */
S
S#define SPI_STATUS_TX_INTSTS_Pos   4                                                 /*!< SPI STATUS: TX_INTSTS Position */
S#define SPI_STATUS_TX_INTSTS_Msk   (1ul << SPI_STATUS_TX_INTSTS_Pos)                 /*!< SPI STATUS: TX_INTSTS Mask */
S
S#define SPI_STATUS_RX_OVERRUN_Pos   2                                                /*!< SPI STATUS: RX_OVERRUN Position */
S#define SPI_STATUS_RX_OVERRUN_Msk   (1ul << SPI_STATUS_RX_OVERRUN_Pos)               /*!< SPI STATUS: RX_OVERRUN Mask */
S
S#define SPI_STATUS_RX_INTSTS_Pos   0                                                 /*!< SPI STATUS: RX_INTSTS Position */
S#define SPI_STATUS_RX_INTSTS_Msk   (1ul << SPI_STATUS_RX_INTSTS_Pos)                 /*!< SPI STATUS: RX_INTSTS Mask */
S
S/*@}*/ /* end of group NUC200_SPI */
S
S
S
S/*------------------------------ I2C Controller ------------------------------*/
S/** @addtogroup NUC200_I2C NUC200 I2C
S  Memory Mapped Structure for NUC200 Series I2C Serial Interface Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * I2CON
S     * ===================================================================================================
S     * Offset: 0x00  I2C Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2]     |AA        |Assert Acknowledge control bit. 
S     * |        |          |When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during 
S     * |        |          |the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from 
S     * |        |          |master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to 
S     * |        |          |address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge 
S     * |        |          |clock pulse on the SCL line.
S     * |[3]     |SI        |I2C Interrupt Flag. 
S     * |        |          |When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI 
S     * |        |          |(I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one 
S     * |        |          |to this bit.
S     * |[4]     |STO       |I2C STOP Flag. 
S     * |        |          |In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus 
S     * |        |          |condition if a STOP condition is detected this flag will be cleared by hardware automatically. 
S     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means 
S     * |        |          |it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
S     * |[5]     |STA       |I2C START Flag. 
S     * |        |          |Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition 
S     * |        |          |to bus when the bus is free.
S     * |[6]     |ENS1      |I2C controller is enabled/disable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function 
S     * |        |          |pin function of SDA and SCL must set to I2C function first.
S     * |[7]     |EI        |Enable interrupt. 
S     * |        |          |1 = Enable I2C interrupt.
S     * |        |          |0 = Disable I2C interrupt. 
S     */    
S    __IO uint32_t I2CON;	
S    
S     /**
S     * I2CADDR0
S     * ===================================================================================================
S     * Offset: 0x04  I2C Slave Address Register 0 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */   
S    __IO uint32_t I2CADDR0;    
S
S    /**
S     * I2CDAT
S     * ===================================================================================================
S     * Offset: 0x08  I2C Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CDAT    |I2C Data Register
S     * |        |          |Bit[7:0] is located with the 8-bit transferred data of I2C serial port. 
S     */    
S    __IO uint32_t I2CDAT;    
S    
S    /**
S     * I2CSTATUS
S     * ===================================================================================================
S     * Offset: 0x0C  I2C Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CSTATUS |I2C Status Register 
S     * |        |          |The status register of I2C:
S     * |        |          |The three least significant bits are always 0. The five most significant bits contain the status code. 
S     * |        |          |There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is 
S     * |        |          |requested. All other I2STATUS values correspond to defined I2C states. When each of these 
S     * |        |          |states is entered, a status interrupt is requested (SI = 1). A valid status code is present in 
S     * |        |          |I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle 
S     * |        |          |after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error 
S     * |        |          |occurs when a START or STOP condition is present at an illegal position in the formation frame. 
S     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an 
S     * |        |          |acknowledge bit.
S     */    
S    __I  uint32_t I2CSTATUS;        
S    
S    /**
S     * I2CLK
S     * ===================================================================================================
S     * Offset: 0x10  I2C Clock Divided Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CLK     |I2C clock divided Register
S     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).
S     */    
S    __IO uint32_t I2CLK;    
S    
S    /**
S     * I2CTOC
S     * ===================================================================================================
S     * Offset: 0x14  I2C Time-Out Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TIF       |Time-Out flag. 
S     * |        |          |1 = Time-Out falg is set by H/W. It can interrupt CPU.
S     * |        |          |0 = S/W can clear the flag.
S     * |[1]     |DIV4      |Time-Out counter input clock is divider by 4 
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |When Enable, The time-Out period is prolong 4 times.
S     * |[2]     |ENTI      |Time-out counter is enabled/disable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will 
S     * |        |          |reset counter and re-start up counting after SI is cleared.
S     */    
S    __IO uint32_t I2CTOC;    
S    
S    /**
S     * I2CADDR1
S     * ===================================================================================================
S     * Offset: 0x18  I2C Slave Address Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */    
S    __IO uint32_t I2CADDR1;    
S    
S    /**
S     * I2CADDR2
S     * ===================================================================================================
S     * Offset: 0x1C  I2C Slave Address Register 2 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */    
S    __IO uint32_t I2CADDR2;    
S    
S    /**
S     * I2CADDR3
S     * ===================================================================================================
S     * Offset: 0x20  I2C Slave Address Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = Disable General Call Function.
S     * |        |          |1 = Enable General Call Function.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven 
S     * |        |          |most significant bits must be loaded with the MCU's own address. The I2C hardware will react if 
S     * |        |          |either of the address is matched.
S     */    
S    __IO uint32_t I2CADDR3; 
S    
S    /**
S     * I2CADM0
S     * ===================================================================================================
S     * Offset: 0x24  I2C Slave Address Mask Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM0;    
S    
S    /**
S     * I2CADM1
S     * ===================================================================================================
S     * Offset: 0x28  I2C Slave Address Mask Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM1;    
S    
S    /**
S     * I2CADM2
S     * ===================================================================================================
S     * Offset: 0x2C  I2C Slave Address Mask Register 2 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM2;    
S    
S    /**
S     * I2CADM3
S     * ===================================================================================================
S     * Offset: 0x30  I2C Slave Address Mask Register 3 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2ADMx    |I2C Address Mask register
S     * |        |          |1 = Mask enable (the received corresponding address bit is don't care.)
S     * |        |          |0 = Mask disable (the received corresponding register bit should be exact the same as 
S     * |        |          |address register.) 
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register. 
S     * |        |          |When the bit in the address mask register is set to one, it means the received 
S     * |        |          |corresponding address bit is don't-care. If the bit is set to zero, that means the received 
S     * |        |          |corresponding register bit should be exact the same as address register.
S     */    
S    __IO uint32_t I2CADM3;    
S    
S    /**
S     * RESERVED0
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    uint32_t RESERVED0[2];
S      
S    /**
S     * I2CWKUPCON
S     * ===================================================================================================
S     * Offset: 0x3C  I2C Wake Up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKUPEN    |I2C Wakeup Function Enable
S     * |        |          |1 = Enable I2C wake up function.
S     * |        |          |0 = Disable I2C wake up function.
S     */    
S    __IO uint32_t I2CWKUPCON;
S    
S    /**
S     * I2CWKUPSTS
S     * ===================================================================================================
S     * Offset: 0x40  I2C Wake Up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKUPIF    |I2C Wakeup Interrupt Flag 
S     * |        |          |When chip is waked up from power down mode by I2C, this bit is set to 1. Software can 
S     * |        |          |write 1 to clear this bit.
S     */    
S    __IO uint32_t I2CWKUPSTS;            
S} I2C_T;
S
S/* I2C I2CON Bit Field Definitions */
S#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C I2CON: EI Position */
S#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C I2CON: EI Mask */
S
S#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C I2CON: ENS1 Position */
S#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C I2CON: ENS1 Mask */
S
S#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C I2CON: STA Position */
S#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C I2CON: STA Mask */
S
S#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C I2CON: STO Position */
S#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C I2CON: STO Mask */
S
S#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C I2CON: SI Position */
S#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C I2CON: SI Mask */
S
S#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C I2CON: AA Position */
S#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C I2CON: AA Mask */
S
S/* I2C I2CADDR Bit Field Definitions */
S#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C I2CADDR: I2CADDR Position */
S#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C I2CADDR: I2CADDR Mask */
S
S#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C I2CADDR: GC Position */
S#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C I2CADDR: GC Mask */
S
S/* I2C I2CDAT Bit Field Definitions */
S#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C I2CDAT: I2CDAT Position */
S#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C I2CDAT: I2CDAT Mask */
S
S/* I2C I2CSTATUS Bit Field Definitions */
S#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C I2CSTATUS: I2CSTATUS Position */
S#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C I2CSTATUS: I2CSTATUS Mask */
S
S/* I2C I2CLK Bit Field Definitions */
S#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C I2CLK: I2CLK Position */
S#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C I2CLK: I2CLK Mask */
S
S/* I2C I2CTOC Bit Field Definitions */
S#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C I2CTOC: ENTI Position */
S#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C I2CTOC: ENTI Mask */
S
S#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C I2CTOC: DIV4 Position */
S#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C I2CTOC: DIV4 Mask */
S
S#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C I2CTOC: TIF Position */
S#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C I2CTOC: TIF Mask */
S
S/* I2C I2CADM Bit Field Definitions */
S#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C I2CADM: I2CADM Position */
S#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C I2CADM: I2CADM Mask */
S
S/* I2C I2CWKUPCON Bit Field Definitions */
S#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C I2CWKUPCON: WKUPEN Position */
S#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C I2CWKUPCON: WKUPEN Mask */
S
S/* I2C I2CWKUPSTS Bit Field Definitions */
S#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C I2CWKUPSTS: WKUPIF Position */
S#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C I2CWKUPSTS: WKUPIF Mask */
S
S/*@}*/ /* end of group NUC200_I2C */
S
S
S/*-----------------------  Real Time Clock (RTC) ------------------*/
S/** @addtogroup NUC200_RTC NUC200 RTC
S  Memory Mapped Structure for NUC200 Series Real Time Clock
S  @{
S */
Stypedef struct
S{
S    /**
S     * INIR
S     * ===================================================================================================
S     * Offset: 0x00  RTC Initiation Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t INIR;
S
S    /**
S     * AER
S     * ===================================================================================================
S     * Offset: 0x04  RTC Access Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t AER;
S
S    /**
S     * FCR
S     * ===================================================================================================
S     * Offset: 0x08  RTC Frequency Compensation Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t FCR;
S
S    /**
S     * TLR
S     * ===================================================================================================
S     * Offset: 0x0C  RTC Time Loading Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TLR;
S
S    /**
S     * CLR
S     * ===================================================================================================
S     * Offset: 0x10  RTC Calendar Loading Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t CLR;
S
S    /**
S     * TSSR
S     * ===================================================================================================
S     * Offset: 0x14  RTC Time Scale Selection Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TSSR;
S
S    /**
S     * DWR
S     * ===================================================================================================
S     * Offset: 0x18  RTC Day of the Week Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t DWR;
S
S    /**
S     * TAR
S     * ===================================================================================================
S     * Offset: 0x1C  RTC Time Alarm Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TAR;
S
S    /**
S     * CAR
S     * ===================================================================================================
S     * Offset: 0x20  RTC Calendar Alarm Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t CAR;
S
S    /**
S     * LIR
S     * ===================================================================================================
S     * Offset: 0x24  RTC Leap Year Indication Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t LIR;
S
S    /**
S     * RIER
S     * ===================================================================================================
S     * Offset: 0x28  RTC Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t RIER;
S
S    /**
S     * RIIR
S     * ===================================================================================================
S     * Offset: 0x2C  RTC Interrupt Indication Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t RIIR;
S
S    /**
S     * TTR
S     * ===================================================================================================
S     * Offset: 0x30  RTC Time Tick Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TTR;
S} RTC_T;
S
S/* RTC INIR Bit Field Definitions */                                            
S#define RTC_INIR_INIR_Pos       0                                               /*!< RTC INIR: INIR Position */
S#define RTC_INIR_INIR_Msk       (0xFFFFFFFFul << RTC_INIR_INIR_Pos)             /*!< RTC INIR: INIR Mask */
S
S#define RTC_INIR_ACTIVE_Pos     0                                               /*!< RTC INIR: ACTIVE Position */
S#define RTC_INIR_ACTIVE_Msk     (1ul << RTC_INIR_ACTIVE_Pos)                    /*!< RTC INIR: ACTIVE Mask */
S
S/* RTC AER Bit Field Definitions */
S#define RTC_AER_ENF_Pos         16                                              /*!< RTC AER: ENF Position */
S#define RTC_AER_ENF_Msk         (1ul << RTC_AER_ENF_Pos)                        /*!< RTC AER: ENF Mask */
S
S#define RTC_AER_AER_Pos         0                                               /*!< RTC AER: AER Position */
S#define RTC_AER_AER_Msk         (0xFFFFul << RTC_AER_AER_Pos)                   /*!< RTC AER: AER Mask */
S
S/* RTC FCR Bit Field Definitions */
S#define RTC_FCR_INTEGER_Pos     8                                               /*!< RTC FCR: INTEGER Position */
S#define RTC_FCR_INTEGER_Msk     (0xFul << RTC_FCR_INTEGER_Pos)                  /*!< RTC FCR: INTEGER Mask */
S
S#define RTC_FCR_FRACTION_Pos    0                                               /*!< RTC FCR: FRACTION Position */
S#define RTC_FCR_FRACTION_Msk    (0x3Ful << RTC_FCR_FRACTION_Pos)                /*!< RTC FCR: FRACTION Mask */
S
S/* RTC TLR Bit Field Definitions */
S#define RTC_TLR_10HR_Pos        20                                              /*!< RTC TLR: 10HR Position */
S#define RTC_TLR_10HR_Msk        (0x3ul << RTC_TLR_10HR_Pos)                     /*!< RTC TLR: 10HR Mask */
S
S#define RTC_TLR_1HR_Pos         16                                              /*!< RTC TLR: 1HR Position */
S#define RTC_TLR_1HR_Msk         (0xFul << RTC_TLR_1HR_Pos)                      /*!< RTC TLR: 1HR Mask */
S
S#define RTC_TLR_10MIN_Pos       12                                              /*!< RTC TLR: 10MIN Position */
S#define RTC_TLR_10MIN_Msk       (0x7ul << RTC_TLR_10MIN_Pos)                    /*!< RTC TLR: 10MIN Mask */
S
S#define RTC_TLR_1MIN_Pos        8                                               /*!< RTC TLR: 1MIN Position */
S#define RTC_TLR_1MIN_Msk        (0xFul << RTC_TLR_1MIN_Pos)                     /*!< RTC TLR: 1MIN Mask */
S
S#define RTC_TLR_10SEC_Pos       4                                               /*!< RTC TLR: 10SEC Position */
S#define RTC_TLR_10SEC_Msk       (0x7ul << RTC_TLR_10SEC_Pos)                    /*!< RTC TLR: 10SEC Mask */
S
S#define RTC_TLR_1SEC_Pos        0                                               /*!< RTC TLR: 1SEC Position */
S#define RTC_TLR_1SEC_Msk        (0xFul << RTC_TLR_1SEC_Pos)                     /*!< RTC TLR: 1SEC Mask */
S
S/* RTC CLR Bit Field Definitions */
S#define RTC_CLR_10YEAR_Pos      20                                              /*!< RTC CLR: 10YEAR Position */
S#define RTC_CLR_10YEAR_Msk      (0xFul << RTC_CLR_10YEAR_Pos)                   /*!< RTC CLR: 10YEAR Mask */
S
S#define RTC_CLR_1YEAR_Pos       16                                              /*!< RTC CLR: 1YEAR Position */
S#define RTC_CLR_1YEAR_Msk       (0xFul << RTC_CLR_1YEAR_Pos)                    /*!< RTC CLR: 1YEAR Mask */ 
S
S#define RTC_CLR_10MON_Pos       12                                              /*!< RTC CLR: 10MON Position */
S#define RTC_CLR_10MON_Msk       (1ul << RTC_CLR_10MON_Pos)                      /*!< RTC CLR: 10MON Mask */
S
S#define RTC_CLR_1MON_Pos        8                                               /*!< RTC CLR: 1MON Position */
S#define RTC_CLR_1MON_Msk        (0xFul << RTC_CLR_1MON_Pos)                     /*!< RTC CLR: 1MON Mask */
S
S#define RTC_CLR_10DAY_Pos       4                                               /*!< RTC CLR: 10DAY Position */
S#define RTC_CLR_10DAY_Msk       (0x3ul << RTC_CLR_10DAY_Pos)                    /*!< RTC CLR: 10DAY Mask */
S
S#define RTC_CLR_1DAY_Pos        0                                               /*!< RTC CLR: 1DAY Position */
S#define RTC_CLR_1DAY_Msk        (0xFul << RTC_CLR_1DAY_Pos)                     /*!< RTC CLR: 1DAY Mask */
S
S/* RTC TSSR Bit Field Definitions */                                            
S#define RTC_TSSR_24H_12H_Pos    0                                               /*!< RTC TSSR: 24H_12H Position */
S#define RTC_TSSR_24H_12H_Msk    (1ul << RTC_TSSR_24H_12H_Pos)                   /*!< RTC TSSR: 24H_12H Mask */
S
S/* RTC DWR Bit Field Definitions */
S#define RTC_DWR_DWR_Pos         0                                               /*!< RTC DWR: DWR Position */
S#define RTC_DWR_DWR_Msk         (0x7ul << RTC_DWR_DWR_Pos)                      /*!< RTC DWR: DWR Mask */
S
S/* RTC TAR Bit Field Definitions */
S#define RTC_TAR_10HR_Pos        20                                              /*!< RTC TAR: 10HR Position */
S#define RTC_TAR_10HR_Msk        (0x3ul << RTC_TAR_10HR_Pos)                     /*!< RTC TAR: 10HR Mask */
S
S#define RTC_TAR_1HR_Pos         16                                              /*!< RTC TAR: 1HR Position */
S#define RTC_TAR_1HR_Msk         (0xFul << RTC_TAR_1HR_Pos)                      /*!< RTC TAR: 1HR Mask */
S
S#define RTC_TAR_10MIN_Pos       12                                              /*!< RTC TAR: 10MIN Position */
S#define RTC_TAR_10MIN_Msk       (0x7ul << RTC_TAR_10MIN_Pos)                    /*!< RTC TAR: 10MIN Mask */
S
S#define RTC_TAR_1MIN_Pos        8                                               /*!< RTC TAR: 1MIN Position */
S#define RTC_TAR_1MIN_Msk        (0xFul << RTC_TAR_1MIN_Pos)                     /*!< RTC TAR: 1MIN Mask */
S
S#define RTC_TAR_10SEC_Pos       4                                               /*!< RTC TAR: 10SEC Position */
S#define RTC_TAR_10SEC_Msk       (0x7ul << RTC_TAR_10SEC_Pos)                    /*!< RTC TAR: 10SEC Mask */
S
S#define RTC_TAR_1SEC_Pos        0                                               /*!< RTC TAR: 1SEC Position */
S#define RTC_TAR_1SEC_Msk        (0xFul << RTC_TAR_1SEC_Pos)                     /*!< RTC TAR: 1SEC Mask */
S
S/* RTC CAR Bit Field Definitions */
S#define RTC_CAR_10YEAR_Pos      20                                              /*!< RTC CAR: 10YEAR Position */
S#define RTC_CAR_10YEAR_Msk      (0xFul << RTC_CAR_10YEAR_Pos)                   /*!< RTC CAR: 10YEAR Mask */
S
S#define RTC_CAR_1YEAR_Pos       16                                              /*!< RTC CAR: 1YEAR Position */        
S#define RTC_CAR_1YEAR_Msk       (0xFul << RTC_CAR_1YEAR_Pos)                    /*!< RTC CAR: 1YEAR Mask */
S
S#define RTC_CAR_10MON_Pos       12                                              /*!< RTC CAR: 10MON Position */
S#define RTC_CAR_10MON_Msk       (1ul << RTC_CAR_10MON_Pos)                      /*!< RTC CAR: 10MON Mask */
S
S#define RTC_CAR_1MON_Pos        8                                               /*!< RTC CAR: 1MON Position */
S#define RTC_CAR_1MON_Msk        (0xFul << RTC_CAR_1MON_Pos)                     /*!< RTC CAR: 1MON Mask */
S
S#define RTC_CAR_10DAY_Pos       4                                               /*!< RTC CAR: 10DAY Position */
S#define RTC_CAR_10DAY_Msk       (0x3ul << RTC_CAR_10DAY_Pos)                    /*!< RTC CAR: 10DAY Mask */
S
S#define RTC_CAR_1DAY_Pos        0                                               /*!< RTC CAR: 1DAY Position */
S#define RTC_CAR_1DAY_Msk        (0xFul << RTC_CAR_1DAY_Pos)                     /*!< RTC CAR: 1DAY Mask */
S
S/* RTC LIR Bit Field Definitions */
S#define RTC_LIR_LIR_Pos         0                                               /*!< RTC LIR: LIR Position */
S#define RTC_LIR_LIR_Msk         (1ul << RTC_LIR_LIR_Pos)                        /*!< RTC LIR: LIR Mask */
S
S/* RTC RIER Bit Field Definitions */
S#define RTC_RIER_TIER_Pos       1                                               /*!< RTC RIER: TIER Position */
S#define RTC_RIER_TIER_Msk       (1ul << RTC_RIER_TIER_Pos)                      /*!< RTC RIER: TIER Mask */
S
S#define RTC_RIER_AIER_Pos       0                                               /*!< RTC RIER: AIER Position */
S#define RTC_RIER_AIER_Msk       (1ul << RTC_RIER_AIER_Pos)                      /*!< RTC RIER: AIER Mask */
S
S/* RTC RIIR Bit Field Definitions */
S#define RTC_RIIR_TIF_Pos        1                                               /*!< RTC RIIR: TIF Position */
S#define RTC_RIIR_TIF_Msk        (1ul << RTC_RIIR_TIF_Pos)                       /*!< RTC RIIR: TIF Mask */
S
S#define RTC_RIIR_AIF_Pos        0                                               /*!< RTC RIIR: AIF Position */
S#define RTC_RIIR_AIF_Msk        (1ul << RTC_RIIR_AIF_Pos)                       /*!< RTC RIIR: AIF Mask */
S
S/* RTC TTR Bit Field Definitions */
S#define RTC_TTR_TTR_Pos         0                                               /*!< RTC TTR: TTR Position */
S#define RTC_TTR_TTR_Msk         (0x7ul << RTC_TTR_TTR_Pos)                      /*!< RTC TTR: TTR Mask */
S/*@}*/ /* end of group NUC200_RTC */
S
S
S
S/*----------------------------- ADC Controller -------------------------------*/
S/** @addtogroup NUC200_ADC NUC200 ADC
S  Memory Mapped Structure for NUC200 Series ADC Controller
S  @{
S */
Stypedef struct
S{
S    __I  uint32_t ADDR[8];               /*!< Offset: 0x00  A/D Data Register              */
S    __IO uint32_t ADCR;                  /*!< Offset: 0x20  A/D Control Register           */
S    __IO uint32_t ADCHER;                /*!< Offset: 0x24  A/D Channel Enable Register    */
S    __IO uint32_t ADCMPR[2];             /*!< Offset: 0x28  A/D Compare Register 0 & 1     */
S    __IO uint32_t ADSR;                  /*!< Offset: 0x30  ADC Status Register            */
S    __I  uint32_t RESERVE0[3];
S    __I  uint32_t ADPDMA;                /*!< Offset: 0x40  ADC PDMA Current Transfer Data */
S} ADC_T;
S
S
S/* ADDR Bit Field Definitions */
S#define ADC_ADDR_VALID_Pos      17                                /*!< ADC ADDR: VALID Position */
S#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC ADDR: VALID Mask */
S
S#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC ADDR: OVERRUN Position */
S#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC ADDR: OVERRUN Mask */
S
S#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC ADDR: RSLT Position */
S#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC ADDR: RSLT Mask */
S
S/* ADCR Bit Field Definitions */
S#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC ADCR: DMOF Position */
S#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC ADCR: DMOF Mask */
S
S#define ADC_ADCR_ADST_Pos       11                                /*!< ADC ADCR: ADST Position */
S#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC ADCR: ADST Mask */
S
S#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC ADCR: DIFFEN Position */
S#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC ADCR: DIFFEN Mask */
S
S#define ADC_ADCR_PTEN_Pos       9                                 /*!< ADC ADCR: PTEN Position */
S#define ADC_ADCR_PTEN_Msk       (1ul << ADC_ADCR_PTEN_Pos)        /*!< ADC ADCR: PTEN Mask */
S
S#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC ADCR: TRGEN Position */
S#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC ADCR: TRGEN Mask */
S
S#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC ADCR: TRGCOND Position */
S#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC ADCR: TRGCOND Mask */
S
S#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC ADCR: TRGS Position */
S#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC ADCR: TRGS Mask */
S
S#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC ADCR: ADMD Position */
S#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC ADCR: ADMD Mask */
S
S#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC ADCR: ADIE Position */
S#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC ADCR: ADIE Mask */
S
S#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC ADCR: ADEN Position */
S#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC ADCR: ADEN Mask */
S
S/* ADCHER Bit Field Definitions */
S#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC ADCHER: PRESEL Position */
S#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC ADCHER: PRESEL Mask */
S
S#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC ADCHER: CHEN Position */
S#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC ADCHER: CHEN Mask */
S
S/* ADCMPR Bit Field Definitions */
S#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC ADCMPR: CMPD Position */
S#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC ADCMPR: CMPD Mask */
S
S#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC ADCMPR: CMPMATCNT Position */
S#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC ADCMPR: CMPMATCNT Mask */
S
S#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC ADCMPR: CMPCH Position */
S#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC ADCMPR: CMPCH Mask */
S
S#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC ADCMPR: CMPCOND Position */
S#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC ADCMPR: CMPCOND Mask */
S
S#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC ADCMPR: CMPIE Position */
S#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC ADCMPR: CMPIE Mask */
S
S#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC ADCMPR: CMPEN Position */
S#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC ADCMPR: CMPEN Mask */
S
S/* ADSR Bit Field Definitions */
S#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC ADSR: OVERRUN Position */
S#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC ADSR: OVERRUN Mask */
S
S#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC ADSR: VALID Position */
S#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC ADSR: VALID Mask */
S
S#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC ADSR: CHANNEL Position */
S#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC ADSR: CHANNEL Mask */
S
S#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC ADSR: BUSY Position */
S#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC ADSR: BUSY Mask */
S
S#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC ADSR: CMPF1 Position */
S#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC ADSR: CMPF1 Mask */
S
S#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC ADSR: CMPF0 Position */
S#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC ADSR: CMPF0 Mask */
S
S#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC ADSR: ADF Position */
S#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC ADSR: ADF Mask */
S
S/* ADPDMA Bit Field Definitions */
S#define ADC_ADPDMA_AD_PDMA_Pos     0                                     /*!< ADC ADPDMA: AD_PDMA Position */
S#define ADC_ADPDMA_AD_PDMA_Msk     (0x3FFFFul << ADC_ADPDMA_AD_PDMA_Pos) /*!< ADC ADPDMA: AD_PDMA Mask */
S
S/*@}*/ /* end of group NUC200_ADC */
S
S
S/*---------------------- Analog Comparator Controller -------------------------*/
S/** @addtogroup NUC200_ACMP NUC200 ACMP
S  Memory Mapped Structure for NUC200 Series ACMP Controller
S  @{
S */
Stypedef struct
S{
S        __IO uint32_t CMPCR[2];        /*!< Offset: 0x00  ACMP Comparator Control Register   */
S        __IO uint32_t CMPSR;           /*!< Offset: 0x08  ACMP Comparator Status Register   */
S
S} ACMP_T;
S
S
S/* CMPCR Bit Field Definitions */
S#define ACMP_CMPCR_CMPCN_Pos       4                                   /*!< ACMP CMPCR: CMPCN Position */
S#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)       /*!< ACMP CMPCR: CMPCN Mask */
S
S#define ACMP_CMPCR_CMP_HYSEN_Pos   2                                   /*!< ACMP CMPCR: CMP_HYSEN Position */
S#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)   /*!< ACMP CMPCR: CMP_HYSEN Mask */
S
S#define ACMP_CMPCR_CMPIE_Pos       1                                   /*!< ACMP CMPCR: CMPIE Position */
S#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)       /*!< ACMP CMPCR: CMPIE Mask */
S
S#define ACMP_CMPCR_CMPEN_Pos       0                                   /*!< ACMP CMPCR: CMPEN Position */
S#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)       /*!< ACMP CMPCR: CMPEN Mask */
S
S/* CMPSR Bit Field Definitions */
S#define ACMP_CMPSR_CO1_Pos     3                                 /*!< ACMP CMPSR: CO1 Position */
S#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)       /*!< ACMP CMPSR: CO1 Mask */
S
S#define ACMP_CMPSR_CO0_Pos     2                                 /*!< ACMP CMPSR: CO0 Position */
S#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)       /*!< ACMP CMPSR: CO0 Mask */
S
S#define ACMP_CMPSR_CMPF1_Pos   1                                 /*!< ACMP CMPSR: CMPF1 Position */
S#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)     /*!< ACMP CMPSR: CMPF1 Mask */
S
S#define ACMP_CMPSR_CMPF0_Pos   0                                 /*!< ACMP CMPSR: CMPF0 Position */
S#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)     /*!< ACMP CMPSR: CMPF0 Mask */
S
S/*@}*/ /* end of group NUC200_ACMP */
S
S
S
S/*---------------------------- Clock Controller ------------------------------*/
S/** @addtogroup NUC200_SYSCLK NUC200 System Clock Controller
S  Memory Mapped Structure for NUC200 Series System Clock Controller
S  @{
S */
Stypedef struct
S{
S    __IO uint32_t PWRCON;           
S    __IO uint32_t AHBCLK;           
S    __IO uint32_t APBCLK;           
S    __IO uint32_t CLKSTATUS;        
S    __IO uint32_t CLKSEL0;          
S    __IO uint32_t CLKSEL1;          
S    __IO uint32_t CLKDIV;           
S    __IO uint32_t CLKSEL2;           
S    __IO uint32_t PLLCON;           
S    __IO uint32_t FRQDIV;           
S    __IO uint32_t RESERVE[2];           
S    __IO uint32_t APBCLK1;             
S    __IO uint32_t CLKSEL3;          
S    __IO uint32_t CLKDIV1;                        
S} SYSCLK_T;
S
S/* SYSCLK PWRCON Bit Field Definitions */
S#define SYSCLK_PWRCON_PD_WAIT_CPU_Pos           8                                       /*!< SYSCLK PWRCON: PD_WAIT_CPU Position */
S#define SYSCLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << SYSCLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< SYSCLK PWRCON: PD_WAIT_CPU Mask */
S
S#define SYSCLK_PWRCON_PWR_DOWN_EN_Pos           7                                       /*!< SYSCLK PWRCON: PWR_DOWN_EN Position */
S#define SYSCLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << SYSCLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< SYSCLK PWRCON: PWR_DOWN_EN Mask */
S
S#define SYSCLK_PWRCON_PD_WU_STS_Pos             6                                       /*!< SYSCLK PWRCON: PD_WU_STS Position */
S#define SYSCLK_PWRCON_PD_WU_STS_Msk             (1ul << SYSCLK_PWRCON_PD_WU_STS_Pos)    /*!< SYSCLK PWRCON: PD_WU_STS Mask */
S
S#define SYSCLK_PWRCON_PD_WU_INT_EN_Pos          5                                       /*!< SYSCLK PWRCON: PD_WU_INT_EN Position */
S#define SYSCLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << SYSCLK_PWRCON_PD_WU_INT_EN_Pos) /*!< SYSCLK PWRCON: PD_WU_INT_EN Mask */
S
S#define SYSCLK_PWRCON_PD_WU_DLY_Pos             4                                       /*!< SYSCLK PWRCON: PD_WU_DLY Position */
S#define SYSCLK_PWRCON_PD_WU_DLY_Msk             (1ul << SYSCLK_PWRCON_PD_WU_DLY_Pos)    /*!< SYSCLK PWRCON: PD_WU_DLY Mask */
S
S#define SYSCLK_PWRCON_IRC10K_EN_Pos             3                                       /*!< SYSCLK PWRCON: IRC10K_EN Position */
S#define SYSCLK_PWRCON_IRC10K_EN_Msk             (1ul << SYSCLK_PWRCON_IRC10K_EN_Pos)    /*!< SYSCLK PWRCON: IRC10K_EN Mask */
S
S#define SYSCLK_PWRCON_IRC22M_EN_Pos             2                                       /*!< SYSCLK PWRCON: IRC22M_EN Position */
S#define SYSCLK_PWRCON_IRC22M_EN_Msk             (1ul << SYSCLK_PWRCON_IRC22M_EN_Pos)    /*!< SYSCLK PWRCON: IRC22M_EN Mask */
S
S#define SYSCLK_PWRCON_XTL32K_EN_Pos             1                                       /*!< SYSCLK PWRCON: XTL32K_EN Position */
S#define SYSCLK_PWRCON_XTL32K_EN_Msk             (1ul << SYSCLK_PWRCON_XTL32K_EN_Pos)    /*!< SYSCLK PWRCON: XTL32K_EN Mask */
S
S#define SYSCLK_PWRCON_XTL12M_EN_Pos             0                                       /*!< SYSCLK PWRCON: XTL12M_EN Position */
S#define SYSCLK_PWRCON_XTL12M_EN_Msk             (1ul << SYSCLK_PWRCON_XTL12M_EN_Pos)    /*!< SYSCLK PWRCON: XTL12M_EN Mask */
S
S/* SYSCLK AHBCLK Bit Field Definitions */
S#define SYSCLK_AHBCLK_ISP_EN_Pos                2                                       /*!< SYSCLK AHBCLK: ISP_EN Position */
S#define SYSCLK_AHBCLK_ISP_EN_Msk                (1ul << SYSCLK_AHBCLK_ISP_EN_Pos)       /*!< SYSCLK AHBCLK: ISP_EN Mask */
S
S#define SYSCLK_AHBCLK_PDMA_EN_Pos               1                                       /*!< SYSCLK AHBCLK: PDMA_EN Position */
S#define SYSCLK_AHBCLK_PDMA_EN_Msk               (1ul << SYSCLK_AHBCLK_PDMA_EN_Pos)      /*!< SYSCLK AHBCLK: PDMA_EN Mask */
S
S
S/* SYSCLK APBCLK Bit Field Definitions */
S#define SYSCLK_APBCLK_PS2_EN_Pos                31                                      /*!< SYSCLK APBCLK: PS2_EN Position */
S#define SYSCLK_APBCLK_PS2_EN_Msk                (1ul << SYSCLK_APBCLK_PS2_EN_Pos)       /*!< SYSCLK APBCLK: PS2_EN Mask */
S
S#define SYSCLK_APBCLK_ACMP_EN_Pos               30                                      /*!< SYSCLK APBCLK: ACMP_EN Position */
S#define SYSCLK_APBCLK_ACMP_EN_Msk               (1ul << SYSCLK_APBCLK_ACMP_EN_Pos)      /*!< SYSCLK APBCLK: ACMP_EN Mask */
S
S#define SYSCLK_APBCLK_I2S_EN_Pos                29                                      /*!< SYSCLK APBCLK: I2S_EN Position */
S#define SYSCLK_APBCLK_I2S_EN_Msk                (1ul << SYSCLK_APBCLK_I2S_EN_Pos)       /*!< SYSCLK APBCLK: I2S_EN Mask */
S
S#define SYSCLK_APBCLK_ADC_EN_Pos                28                                      /*!< SYSCLK APBCLK: ADC_EN Position */
S#define SYSCLK_APBCLK_ADC_EN_Msk                (1ul << SYSCLK_APBCLK_ADC_EN_Pos)       /*!< SYSCLK APBCLK: ADC_EN Mask */
S
S#define SYSCLK_APBCLK_USBD_EN_Pos               27                                      /*!< SYSCLK APBCLK: USBD_EN Position */
S#define SYSCLK_APBCLK_USBD_EN_Msk               (1ul << SYSCLK_APBCLK_USBD_EN_Pos)      /*!< SYSCLK APBCLK: USBD_EN Mask */
S
S#define SYSCLK_APBCLK_CAN1_EN_Pos               25                                      /*!< SYSCLK APBCLK: CAN1_EN Position */
S#define SYSCLK_APBCLK_CAN1_EN_Msk               (1ul << SYSCLK_APBCLK_CAN1_EN_Pos)      /*!< SYSCLK APBCLK: CAN1_EN Mask */
S
S#define SYSCLK_APBCLK_CAN0_EN_Pos               24                                      /*!< SYSCLK APBCLK: CAN0_EN Position */
S#define SYSCLK_APBCLK_CAN0_EN_Msk               (1ul << SYSCLK_APBCLK_CAN0_EN_Pos)      /*!< SYSCLK APBCLK: CAN0_EN Mask */
S
S#define SYSCLK_APBCLK_PWM67_EN_Pos              23                                      /*!< SYSCLK APBCLK: PWM67_EN Position */
S#define SYSCLK_APBCLK_PWM67_EN_Msk              (1ul << SYSCLK_APBCLK_PWM67_EN_Pos)     /*!< SYSCLK APBCLK: PWM67_EN Mask */
S
S#define SYSCLK_APBCLK_PWM45_EN_Pos              22                                      /*!< SYSCLK APBCLK: PWM45_EN Position */
S#define SYSCLK_APBCLK_PWM45_EN_Msk              (1ul << SYSCLK_APBCLK_PWM45_EN_Pos)     /*!< SYSCLK APBCLK: PWM45_EN Mask */
S
S#define SYSCLK_APBCLK_PWM23_EN_Pos              21                                      /*!< SYSCLK APBCLK: PWM23_EN Position */
S#define SYSCLK_APBCLK_PWM23_EN_Msk              (1ul << SYSCLK_APBCLK_PWM23_EN_Pos)     /*!< SYSCLK APBCLK: PWM23_EN Mask */
S
S#define SYSCLK_APBCLK_PWM01_EN_Pos              20                                      /*!< SYSCLK APBCLK: PWM01_EN Position */
S#define SYSCLK_APBCLK_PWM01_EN_Msk              (1ul << SYSCLK_APBCLK_PWM01_EN_Pos)     /*!< SYSCLK APBCLK: PWM01_EN Mask */
S
S#define SYSCLK_APBCLK_UART2_EN_Pos              18                                      /*!< SYSCLK APBCLK: UART2_EN Position */
S#define SYSCLK_APBCLK_UART2_EN_Msk              (1ul << SYSCLK_APBCLK_UART2_EN_Pos)     /*!< SYSCLK APBCLK: UART2_EN Mask */
S
S#define SYSCLK_APBCLK_UART1_EN_Pos              17                                      /*!< SYSCLK APBCLK: UART1_EN Position */
S#define SYSCLK_APBCLK_UART1_EN_Msk              (1ul << SYSCLK_APBCLK_UART1_EN_Pos)     /*!< SYSCLK APBCLK: UART1_EN Mask */
S
S#define SYSCLK_APBCLK_UART0_EN_Pos              16                                      /*!< SYSCLK APBCLK: UART0_EN Position */
S#define SYSCLK_APBCLK_UART0_EN_Msk              (1ul << SYSCLK_APBCLK_UART0_EN_Pos)     /*!< SYSCLK APBCLK: UART0_EN Mask */
S
S#define SYSCLK_APBCLK_SPI3_EN_Pos               15                                      /*!< SYSCLK APBCLK: SPI3_EN Position */
S#define SYSCLK_APBCLK_SPI3_EN_Msk               (1ul << SYSCLK_APBCLK_SPI3_EN_Pos)      /*!< SYSCLK APBCLK: SPI3_EN Mask */
S
S#define SYSCLK_APBCLK_SPI2_EN_Pos               14                                      /*!< SYSCLK APBCLK: SPI2_EN Position */
S#define SYSCLK_APBCLK_SPI2_EN_Msk               (1ul << SYSCLK_APBCLK_SPI2_EN_Pos)      /*!< SYSCLK APBCLK: SPI2_EN Mask */
S
S#define SYSCLK_APBCLK_SPI1_EN_Pos               13                                      /*!< SYSCLK APBCLK: SPI1_EN Position */
S#define SYSCLK_APBCLK_SPI1_EN_Msk               (1ul << SYSCLK_APBCLK_SPI1_EN_Pos)      /*!< SYSCLK APBCLK: SPI1_EN Mask */
S
S#define SYSCLK_APBCLK_SPI0_EN_Pos               12                                      /*!< SYSCLK APBCLK: SPI0_EN Position */
S#define SYSCLK_APBCLK_SPI0_EN_Msk               (1ul << SYSCLK_APBCLK_SPI0_EN_Pos)      /*!< SYSCLK APBCLK: SPI0_EN Mask */
S
S#define SYSCLK_APBCLK_I2C1_EN_Pos               9                                       /*!< SYSCLK APBCLK: I2C1_EN Position */
S#define SYSCLK_APBCLK_I2C1_EN_Msk               (1ul << SYSCLK_APBCLK_I2C1_EN_Pos)      /*!< SYSCLK APBCLK: I2C1_EN Mask */
S
S#define SYSCLK_APBCLK_I2C0_EN_Pos               8                                       /*!< SYSCLK APBCLK: I2C0_EN_ Position */
S#define SYSCLK_APBCLK_I2C0_EN_Msk               (1ul << SYSCLK_APBCLK_I2C0_EN_Pos)      /*!< SYSCLK APBCLK: I2C0_EN_ Mask */
S
S#define SYSCLK_APBCLK_FDIV_EN_Pos               6                                       /*!< SYSCLK APBCLK: FDIV_EN Position */
S#define SYSCLK_APBCLK_FDIV_EN_Msk               (1ul << SYSCLK_APBCLK_FDIV_EN_Pos)      /*!< SYSCLK APBCLK: FDIV_EN Mask */
S
S#define SYSCLK_APBCLK_TMR3_EN_Pos               5                                       /*!< SYSCLK APBCLK: TMR3_EN Position */
S#define SYSCLK_APBCLK_TMR3_EN_Msk               (1ul << SYSCLK_APBCLK_TMR3_EN_Pos)      /*!< SYSCLK APBCLK: TMR3_EN Mask */
S
S#define SYSCLK_APBCLK_TMR2_EN_Pos               4                                       /*!< SYSCLK APBCLK: TMR2_EN Position */
S#define SYSCLK_APBCLK_TMR2_EN_Msk               (1ul << SYSCLK_APBCLK_TMR2_EN_Pos)      /*!< SYSCLK APBCLK: TMR2_EN Mask */
S
S#define SYSCLK_APBCLK_TMR1_EN_Pos               3                                       /*!< SYSCLK APBCLK: TMR1_EN Position */
S#define SYSCLK_APBCLK_TMR1_EN_Msk               (1ul << SYSCLK_APBCLK_TMR1_EN_Pos)      /*!< SYSCLK APBCLK: TMR1_EN Mask */
S                                                
S#define SYSCLK_APBCLK_TMR0_EN_Pos               2                                       /*!< SYSCLK APBCLK: TMR0_EN Position */
S#define SYSCLK_APBCLK_TMR0_EN_Msk               (1ul << SYSCLK_APBCLK_TMR0_EN_Pos)      /*!< SYSCLK APBCLK: TMR0_EN Mask */      
S
S#define SYSCLK_APBCLK_RTC_EN_Pos                1                                       /*!< SYSCLK APBCLK: RTC_EN Position */
S#define SYSCLK_APBCLK_RTC_EN_Msk                (1ul << SYSCLK_APBCLK_RTC_EN_Pos)       /*!< SYSCLK APBCLK: RTC_EN Mask */
S
S#define SYSCLK_APBCLK_WDT_EN_Pos                0                                       /*!< SYSCLK APBCLK: WDT_EN Position */
S#define SYSCLK_APBCLK_WDT_EN_Msk                (1ul << SYSCLK_APBCLK_WDT_EN_Pos)       /*!< SYSCLK APBCLK: WDT_EN Mask */
S
S/* SYSCLK APBCLK1 Bit Field Definitions */
S#define SYSCLK_APBCLK1_SC2_EN_Pos                2                                      /*!< SYSCLK APBCLK1: SC2_EN Position */
S#define SYSCLK_APBCLK1_SC2_EN_Msk                (1ul << SYSCLK_APBCLK1_SC2_EN_Pos)     /*!< SYSCLK APBCLK1: SC2_EN Mask */
S
S#define SYSCLK_APBCLK1_SC1_EN_Pos                1                                      /*!< SYSCLK APBCLK1: SC1_EN Position */
S#define SYSCLK_APBCLK1_SC1_EN_Msk                (1ul << SYSCLK_APBCLK1_SC1_EN_Pos)     /*!< SYSCLK APBCLK1: SC1_EN Mask */
S
S#define SYSCLK_APBCLK1_SC0_EN_Pos                0                                      /*!< SYSCLK APBCLK1: SC0_EN Position */
S#define SYSCLK_APBCLK1_SC0_EN_Msk                (1ul << SYSCLK_APBCLK1_SC0_EN_Pos)     /*!< SYSCLK APBCLK1: SC0_EN Mask */
S
S/* SYSCLK CLKSTATUS Bit Field Definitions */
S#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                           /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Position */
S#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< SYSCLK CLKSTATUS: CLK_SW_FAIL Mask */
S
S#define SYSCLK_CLKSTATUS_IRC22M_STB_Pos         4                                           /*!< SYSCLK CLKSTATUS: IRC22M_STB Position */
S#define SYSCLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_IRC22M_STB_Pos)    /*!< SYSCLK CLKSTATUS: IRC22M_STB Mask */
S
S#define SYSCLK_CLKSTATUS_IRC10K_STB_Pos         3                                           /*!< SYSCLK CLKSTATUS: IRC10K_STB Position */
S#define SYSCLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_IRC10K_STB_Pos)    /*!< SYSCLK CLKSTATUS: IRC10K_STB Mask */
S
S#define SYSCLK_CLKSTATUS_PLL_STB_Pos            2                                           /*!< SYSCLK CLKSTATUS: PLL_STB Position */
S#define SYSCLK_CLKSTATUS_PLL_STB_Msk            (1ul << SYSCLK_CLKSTATUS_PLL_STB_Pos)       /*!< SYSCLK CLKSTATUS: PLL_STB Mask */
S
S#define SYSCLK_CLKSTATUS_XTL32K_STB_Pos         1                                           /*!< SYSCLK CLKSTATUS: XTL32K_STB Position */
S#define SYSCLK_CLKSTATUS_XTL32K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL32K_STB_Pos)    /*!< SYSCLK CLKSTATUS: XTL32K_STB Mask */
S
S#define SYSCLK_CLKSTATUS_XTL12M_STB_Pos         0                                           /*!< SYSCLK CLKSTATUS: XTL12M_STB Position */
S#define SYSCLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL12M_STB_Pos)    /*!< SYSCLK CLKSTATUS: XTL12M_STB Mask */
S
S/* SYSCLK CLKSEL0 Bit Field Definitions */
S#define SYSCLK_CLKSEL0_STCLK_S_Pos              3                                           /*!< SYSCLK CLKSEL0: STCLK_S Position */
S#define SYSCLK_CLKSEL0_STCLK_S_Msk              (7ul << SYSCLK_CLKSEL0_STCLK_S_Pos)         /*!< SYSCLK CLKSEL0: STCLK_S Mask */
S
S#define SYSCLK_CLKSEL0_HCLK_S_Pos               0                                           /*!< SYSCLK CLKSEL0: HCLK_S Position */
S#define SYSCLK_CLKSEL0_HCLK_S_Msk               (7ul << SYSCLK_CLKSEL0_HCLK_S_Pos)          /*!< SYSCLK CLKSEL0: HCLK_S Mask */
S
S/* SYSCLK CLKSEL1 Bit Field Definitions */
S#define SYSCLK_CLKSEL1_PWM23_S_Pos              30                                      /*!< SYSCLK CLKSEL1: PWM23_S Position */
S#define SYSCLK_CLKSEL1_PWM23_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM23_S_Pos)     /*!< SYSCLK CLKSEL1: PWM23_S Mask */
S
S#define SYSCLK_CLKSEL1_PWM01_S_Pos              28                                      /*!< SYSCLK CLKSEL1: PWM01_S Position */
S#define SYSCLK_CLKSEL1_PWM01_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM01_S_Pos)     /*!< SYSCLK CLKSEL1: PWM01_S Mask */
S
S#define SYSCLK_CLKSEL1_UART_S_Pos               24                                      /*!< SYSCLK CLKSEL1: UART_S Position */
S#define SYSCLK_CLKSEL1_UART_S_Msk               (3ul << SYSCLK_CLKSEL1_UART_S_Pos)      /*!< SYSCLK CLKSEL1: UART_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR3_S_Pos               20                                      /*!< SYSCLK CLKSEL1: TMR3_S Position */
S#define SYSCLK_CLKSEL1_TMR3_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR3_S_Pos)      /*!< SYSCLK CLKSEL1: TMR3_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR2_S_Pos               16                                      /*!< SYSCLK CLKSEL1: TMR2_S Position */
S#define SYSCLK_CLKSEL1_TMR2_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR2_S_Pos)      /*!< SYSCLK CLKSEL1: TMR2_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR1_S_Pos               12                                      /*!< SYSCLK CLKSEL1: TMR1_S Position */
S#define SYSCLK_CLKSEL1_TMR1_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR1_S_Pos)      /*!< SYSCLK CLKSEL1: TMR1_S Mask */
S
S#define SYSCLK_CLKSEL1_TMR0_S_Pos               8                                       /*!< SYSCLK CLKSEL1: TMR0_S Position */
S#define SYSCLK_CLKSEL1_TMR0_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR0_S_Pos)      /*!< SYSCLK CLKSEL1: TMR0_S Mask */
S
S#define SYSCLK_CLKSEL1_SPI3_S_Pos               7                                       /*!< SYSCLK CLKSEL1: SPI3_S Position */
S#define SYSCLK_CLKSEL1_SPI3_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI3_S_Pos)      /*!< SYSCLK CLKSEL1: SPI3_S Mask */
S
S#define SYSCLK_CLKSEL1_SPI2_S_Pos               6                                       /*!< SYSCLK CLKSEL1: SPI2_S Position */
S#define SYSCLK_CLKSEL1_SPI2_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI2_S_Pos)      /*!< SYSCLK CLKSEL1: SPI2_S Mask */
S
S#define SYSCLK_CLKSEL1_SPI1_S_Pos               5                                       /*!< SYSCLK CLKSEL1: SPI1_S Position */
S#define SYSCLK_CLKSEL1_SPI1_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI1_S_Pos)      /*!< SYSCLK CLKSEL1: SPI1_S Mask */
S
S#define SYSCLK_CLKSEL1_SPI0_S_Pos               4                                       /*!< SYSCLK CLKSEL1: SPI0_S Position */
S#define SYSCLK_CLKSEL1_SPI0_S_Msk               (1ul << SYSCLK_CLKSEL1_SPI0_S_Pos)      /*!< SYSCLK CLKSEL1: SPI0_S Mask */
S
S#define SYSCLK_CLKSEL1_ADC_S_Pos                2                                       /*!< SYSCLK CLKSEL1: ADC_S Position */
S#define SYSCLK_CLKSEL1_ADC_S_Msk                (3ul << SYSCLK_CLKSEL1_ADC_S_Pos)       /*!< SYSCLK CLKSEL1: ADC_S Mask */
S
S#define SYSCLK_CLKSEL1_WDT_S_Pos                0                                       /*!< SYSCLK CLKSEL1: WDT_S Position */
S#define SYSCLK_CLKSEL1_WDT_S_Msk                (3ul << SYSCLK_CLKSEL1_WDT_S_Pos)       /*!< SYSCLK CLKSEL1: WDT_S Mask */
S
S/* SYSCLK CLKSEL2 Bit Field Definitions */
S#define SYSCLK_CLKSEL2_WWDT_S_Pos              16                                       /*!< SYSCLK CLKSEL2: WWDT_S Position */
S#define SYSCLK_CLKSEL2_WWDT_S_Msk              (3ul << SYSCLK_CLKSEL2_WWDT_S_Pos)       /*!< SYSCLK CLKSEL2: WWDT_S Mask */
S
S#define SYSCLK_CLKSEL2_PWM67_S_EXT_Pos         11                                       /*!< SYSCLK CLKSEL2: PWM67_S_EXT Position */
S#define SYSCLK_CLKSEL2_PWM67_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM67_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM67_S_EXT Mask */
S
S#define SYSCLK_CLKSEL2_PWM45_S_EXT_Pos         10                                       /*!< SYSCLK CLKSEL2: PWM45_S_EXT Position */
S#define SYSCLK_CLKSEL2_PWM45_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM45_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM45_S_EXT Mask */
S
S#define SYSCLK_CLKSEL2_PWM23_S_EXT_Pos         9                                        /*!< SYSCLK CLKSEL2: PWM23_S_EXT Position */
S#define SYSCLK_CLKSEL2_PWM23_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM23_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM23_S_EXT Mask */
S
S#define SYSCLK_CLKSEL2_PWM01_S_EXT_Pos         8                                        /*!< SYSCLK CLKSEL2: PWM01_S_EXT Position */
S#define SYSCLK_CLKSEL2_PWM01_S_EXT_Msk         (1ul << SYSCLK_CLKSEL2_PWM01_S_EXT_Pos)  /*!< SYSCLK CLKSEL2: PWM01_S_EXT Mask */
S
S#define SYSCLK_CLKSEL2_PWM67_S_Pos              6                                       /*!< SYSCLK CLKSEL2: PWM67_S_ Position */
S#define SYSCLK_CLKSEL2_PWM67_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM67_S_Pos)     /*!< SYSCLK CLKSEL2: PWM67_S_ Mask */
S
S#define SYSCLK_CLKSEL2_PWM45_S_Pos              4                                       /*!< SYSCLK CLKSEL2: PWM45_S Position */
S#define SYSCLK_CLKSEL2_PWM45_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM45_S_Pos)      /*!< SYSCLK CLKSEL2: PWM45_S Mask */
S
S#define SYSCLK_CLKSEL2_FRQDIV_S_Pos             2                                       /*!< SYSCLK CLKSEL2: FRQDIV_S Position */
S#define SYSCLK_CLKSEL2_FRQDIV_S_Msk             (3ul << SYSCLK_CLKSEL2_FRQDIV_S_Pos)    /*!< SYSCLK CLKSEL2: FRQDIV_S Mask */
S
S#define SYSCLK_CLKSEL2_I2S_S_Pos                0                                       /*!< SYSCLK CLKSEL2: I2S_S Position */
S#define SYSCLK_CLKSEL2_I2S_S_Msk                (3ul << SYSCLK_CLKSEL2_I2S_S_Pos)       /*!< SYSCLK CLKSEL2: I2S_S Mask */
S
S/* SYSCLK CLKSEL3 Bit Field Definitions */
S#define SYSCLK_CLKSEL3_SC2_S_Pos                4                                       /*!< SYSCLK CLKSEL3: SC2_S Position */
S#define SYSCLK_CLKSEL3_SC2_S_Msk                (3ul << SYSCLK_CLKSEL3_SC2_S_Pos)       /*!< SYSCLK CLKSEL3: SC2_S Mask */
S
S#define SYSCLK_CLKSEL3_SC1_S_Pos                2                                       /*!< SYSCLK CLKSEL3: SC1_S Position */
S#define SYSCLK_CLKSEL3_SC1_S_Msk                (3ul << SYSCLK_CLKSEL3_SC1_S_Pos)       /*!< SYSCLK CLKSEL3: SC1_S Mask */
S
S#define SYSCLK_CLKSEL3_SC0_S_Pos                0                                       /*!< SYSCLK CLKSEL3: SC0_S Position */
S#define SYSCLK_CLKSEL3_SC0_S_Msk                (3ul << SYSCLK_CLKSEL3_SC0_S_Pos)       /*!< SYSCLK CLKSEL3: SC0_S Mask */
S
S/* SYSCLK CLKDIV Bit Field Definitions */
S#define SYSCLK_CLKDIV_ADC_N_Pos                 16                                      /*!< SYSCLK CLKDIV: ADC_N Position */
S#define SYSCLK_CLKDIV_ADC_N_Msk                 (0xFFul << SYSCLK_CLKDIV_ADC_N_Pos)     /*!< SYSCLK CLKDIV: ADC_N Mask */
S
S#define SYSCLK_CLKDIV_UART_N_Pos                8                                       /*!< SYSCLK CLKDIV: UART_N Position */
S#define SYSCLK_CLKDIV_UART_N_Msk                (0xFul << SYSCLK_CLKDIV_UART_N_Pos)     /*!< SYSCLK CLKDIV: UART_N Mask */
S
S#define SYSCLK_CLKDIV_USB_N_Pos                 4                                       /*!< SYSCLK CLKDIV: USB_N Position */
S#define SYSCLK_CLKDIV_USB_N_Msk                 (0xFul << SYSCLK_CLKDIV_USB_N_Pos)      /*!< SYSCLK CLKDIV: USB_N Mask */
S
S#define SYSCLK_CLKDIV_HCLK_N_Pos                0                                       /*!< SYSCLK CLKDIV: HCLK_N Position */
S#define SYSCLK_CLKDIV_HCLK_N_Msk                (0xFul << SYSCLK_CLKDIV_HCLK_N_Pos)     /*!< SYSCLK CLKDIV: HCLK_N Mask */
S
S/* SYSCLK CLKDIV1 Bit Field Definitions */
S#define SYSCLK_CLKDIV1_SC2_N_Pos                16                                      /*!< SYSCLK CLKDIV: SC2_N Position */
S#define SYSCLK_CLKDIV1_SC2_N_Msk                (0xFFul << SYSCLK_CLKDIV1_SC2_N_Pos)    /*!< SYSCLK CLKDIV: SC2_N Mask */
S
S#define SYSCLK_CLKDIV1_SC1_N_Pos                8                                       /*!< SYSCLK CLKDIV: SC1_N Position */
S#define SYSCLK_CLKDIV1_SC1_N_Msk                (0xFFul << SYSCLK_CLKDIV1_SC1_N_Pos)    /*!< SYSCLK CLKDIV: SC1_N Mask */
S
S#define SYSCLK_CLKDIV1_SC0_N_Pos                0                                       /*!< SYSCLK CLKDIV: SC0_N Position */
S#define SYSCLK_CLKDIV1_SC0_N_Msk                (0xFFul << SYSCLK_CLKDIV1_SC0_N_Pos)    /*!< SYSCLK CLKDIV: SC0_N Mask */
S
S/* SYSCLK PLLCON Bit Field Definitions */
S#define SYSCLK_PLLCON_PLL_SRC_Pos               19                                      /*!< SYSCLK PLLCON: PLL_SRC Position */
S#define SYSCLK_PLLCON_PLL_SRC_Msk               (1ul << SYSCLK_PLLCON_PLL_SRC_Pos)      /*!< SYSCLK PLLCON: PLL_SRC Mask */
S
S#define SYSCLK_PLLCON_OE_Pos                    18                                      /*!< SYSCLK PLLCON: PLL_SRC Position */
S#define SYSCLK_PLLCON_OE_Msk                    (1ul << SYSCLK_PLLCON_OE_Pos)           /*!< SYSCLK PLLCON: PLL_SRC Mask */
S
S#define SYSCLK_PLLCON_BP_Pos                    17                                      /*!< SYSCLK PLLCON: OE Position */
S#define SYSCLK_PLLCON_BP_Msk                    (1ul << SYSCLK_PLLCON_BP_Pos)           /*!< SYSCLK PLLCON: OE Mask */
S
S#define SYSCLK_PLLCON_PD_Pos                    16                                      /*!< SYSCLK PLLCON: PD Position */
S#define SYSCLK_PLLCON_PD_Msk                    (1ul << SYSCLK_PLLCON_PD_Pos)           /*!< SYSCLK PLLCON: PD Mask */
S
S#define SYSCLK_PLLCON_OUT_DV_Pos                14                                      /*!< SYSCLK PLLCON: OUT_DV Position */
S#define SYSCLK_PLLCON_OUT_DV_Msk                (3ul << SYSCLK_PLLCON_OUT_DV_Pos)       /*!< SYSCLK PLLCON: OUT_DV Mask */
S
S#define SYSCLK_PLLCON_IN_DV_Pos                 9                                       /*!< SYSCLK PLLCON: IN_DV Position */
S#define SYSCLK_PLLCON_IN_DV_Msk                 (0x1Ful << SYSCLK_PLLCON_IN_DV_Pos)     /*!< SYSCLK PLLCON: IN_DV Mask */
S
S#define SYSCLK_PLLCON_FB_DV_Pos                 0                                       /*!< SYSCLK PLLCON: FB_DV Position */
S#define SYSCLK_PLLCON_FB_DV_Msk                 (0x1FFul << SYSCLK_PLLCON_FB_DV_Pos)    /*!< SYSCLK PLLCON: FB_DV Mask */
S
S/* SYSCLK FRQDIV Bit Field Definitions */
S#define SYSCLK_FRQDIV_DIVIDER_EN_Pos            4                                       /*!< SYSCLK FRQDIV: DIVIDER_EN Position */
S#define SYSCLK_FRQDIV_DIVIDER_EN_Msk            (1ul << SYSCLK_FRQDIV_DIVIDER_EN_Pos)   /*!< SYSCLK FRQDIV: DIVIDER_EN Mask */
S
S#define SYSCLK_FRQDIV_FSEL_Pos                  0                                       /*!< SYSCLK FRQDIV: FRQDIV_FSEL Position */
S#define SYSCLK_FRQDIV_FSEL_Msk                  (0xFul << SYSCLK_FRQDIV_FSEL_Pos)       /*!< SYSCLK FRQDIV: FRQDIV_FSEL Mask */
S
S/*@}*/ /* end of group NUC200_SYSCLK */
S
S/*---------------------------- Global Controller -----------------------------*/
S/** @addtogroup NUC200_SYS NUC200 System Controller
S  Memory Mapped Structure for NUC200 Series System Controller
S  @{
S */
S
Stypedef struct
S{
S    __I uint32_t PDID;
S    __IO uint32_t RSTSRC;
S    __IO uint32_t IPRSTC1;
S    __IO uint32_t IPRSTC2;
S    __IO uint32_t IPRSTC3;   
S    uint32_t RESERVE0;
S    __IO uint32_t BODCR;
S    __IO uint32_t TEMPCR;
S    uint32_t RESERVE1;
S    __IO uint32_t PORCR;
S    uint32_t RESERVE2[2];
S    __IO uint32_t GPA_MFP;
S    __IO uint32_t GPB_MFP;
S    __IO uint32_t GPC_MFP;
S    __IO uint32_t GPD_MFP;
S    __IO uint32_t GPE_MFP;
S    __IO uint32_t GPF_MFP;
S    uint32_t RESERVE3[2];
S    __IO uint32_t ALT_MFP;
S    uint32_t RESERVE4;
S    __IO uint32_t ALT_MFP1;
S    uint32_t RESERVE5[9];
S    __IO uint32_t IRCTRIMCTL;
S    __IO uint32_t IRCTRIMIEN;  
S    __IO uint32_t IRCTRIMINT; 
S    uint32_t RESERVE6[29];       
S    __IO uint32_t REGWRPROT;
S} GCR_T;
S
S/* GCR RSTSRC Bit Field Definitions */
S#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                   /*!< GCR RSTSRC: RSTS_CPU Position */
S#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)    /*!< GCR RSTSRC: RSTS_CPU Mask */
S
S#define SYS_RSTSRC_RSTS_SYS_Pos                 5                                   /*!< GCR RSTSRC: RSTS_SYS Position */
S#define SYS_RSTSRC_RSTS_SYS_Msk                 (1ul << SYS_RSTSRC_RSTS_SYS_Pos)    /*!< GCR RSTSRC: RSTS_SYS Mask */
S
S#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                   /*!< GCR RSTSRC: RSTS_BOD Position */
S#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)    /*!< GCR RSTSRC: RSTS_BOD Mask */
S
S#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                   /*!< GCR RSTSRC: RSTS_LVR Position */
S#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)    /*!< GCR RSTSRC: RSTS_LVR Mask */
S
S#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                   /*!< GCR RSTSRC: RSTS_WDT Position */
S#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)    /*!< GCR RSTSRC: RSTS_WDT Mask */
S
S#define SYS_RSTSRC_RSTS_RESET_Pos               1                                   /*!< GCR RSTSRC: RSTS_RESET Position */
S#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)  /*!< GCR RSTSRC: RSTS_RESET Mask */
S
S#define SYS_RSTSRC_RSTS_POR_Pos                 0                                   /*!< GCR RSTSRC: RSTS_POR Position */
S#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)    /*!< GCR RSTSRC: RSTS_POR Mask */
S
S/* GCR IPRSTC1 Bit Field Definitions */
S#define SYS_IPRSTC1_PDMA_RST_Pos                2                                   /*!< GCR IPRSTC1: PDMA_RST Position */
S#define SYS_IPRSTC1_PDMA_RST_Msk                (1ul << SYS_IPRSTC1_PDMA_RST_Pos)   /*!< GCR IPRSTC1: PDMA_RST Mask */
S
S#define SYS_IPRSTC1_CPU_RST_Pos                 1                                   /*!< GCR IPRSTC1: CPU_RST Position */
S#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)    /*!< GCR IPRSTC1: CPU_RST Mask */
S
S#define SYS_IPRSTC1_CHIP_RST_Pos                0                                   /*!< GCR IPRSTC1: CHIP_RST Position */
S#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)   /*!< GCR IPRSTC1: CHIP_RST Mask */
S
S/* GCR IPRSTC2 Bit Field Definitions */
S#define SYS_IPRSTC2_I2S_RST_Pos                 29                                  /*!< GCR IPRSTC2: I2S_RST Position */
S#define SYS_IPRSTC2_I2S_RST_Msk                 (1ul << SYS_IPRSTC2_I2S_RST_Pos)    /*!< GCR IPRSTC2: I2S_RST Mask */
S
S#define SYS_IPRSTC2_ADC_RST_Pos                 28                                  /*!< GCR IPRSTC2: ADC_RST Position */
S#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)    /*!< GCR IPRSTC2: ADC_RST Mask */
S
S#define SYS_IPRSTC2_USBD_RST_Pos                27                                  /*!< GCR IPRSTC2: USBD_RST Position */
S#define SYS_IPRSTC2_USBD_RST_Msk                (1ul << SYS_IPRSTC2_USBD_RST_Pos)   /*!< GCR IPRSTC2: USBD_RST Mask */
S
S#define SYS_IPRSTC2_CAN1_RST_Pos                25                                  /*!< GCR IPRSTC2: CAN1_RST Position */
S#define SYS_IPRSTC2_CAN1_RST_Msk                (1ul << SYS_IPRSTC2_CAN1_RST_Pos)   /*!< GCR IPRSTC2: CAN1_RST Mask */
S
S#define SYS_IPRSTC2_CAN0_RST_Pos                24                                  /*!< GCR IPRSTC2: CAN0_RST Position */
S#define SYS_IPRSTC2_CAN0_RST_Msk                (1ul << SYS_IPRSTC2_CAN0_RST_Pos)   /*!< GCR IPRSTC2: CAN0_RST Mask */
S
S#define SYS_IPRSTC2_PS2_RST_Pos                 23                                  /*!< GCR IPRSTC2: PS2_RST Position */
S#define SYS_IPRSTC2_PS2_RST_Msk                 (1ul << SYS_IPRSTC2_PS2_RST_Pos)    /*!< GCR IPRSTC2: PS2_RST Mask */
S
S#define SYS_IPRSTC2_ACMP_RST_Pos                22                                  /*!< GCR IPRSTC2: ACMP_RST Position */
S#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)   /*!< GCR IPRSTC2: ACMP_RST Mask */
S
S#define SYS_IPRSTC2_PWM47_RST_Pos               21                                  /*!< GCR IPRSTC2: PWM47_RST Position */
S#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)  /*!< GCR IPRSTC2: PWM47_RST Mask */
S
S#define SYS_IPRSTC2_PWM03_RST_Pos               20                                  /*!< GCR IPRSTC2: PWM03_RST Position */
S#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)  /*!< GCR IPRSTC2: PWM03_RST Mask */
S
S#define SYS_IPRSTC2_UART2_RST_Pos               18                                  /*!< GCR IPRSTC2: UART2_RST Position */
S#define SYS_IPRSTC2_UART2_RST_Msk               (1ul << SYS_IPRSTC2_UART2_RST_Pos)  /*!< GCR IPRSTC2: UART2_RST Mask */
S
S#define SYS_IPRSTC2_UART1_RST_Pos               17                                  /*!< GCR IPRSTC2: UART1_RST Position */
S#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)  /*!< GCR IPRSTC2: UART1_RST Mask */
S
S#define SYS_IPRSTC2_UART0_RST_Pos               16                                  /*!< GCR IPRSTC2: UART0_RST Position */
S#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)  /*!< GCR IPRSTC2: UART0_RST Mask */
S
S#define SYS_IPRSTC2_SPI3_RST_Pos                15                                  /*!< GCR IPRSTC2: SPI3_RST Position */
S#define SYS_IPRSTC2_SPI3_RST_Msk                (1ul << SYS_IPRSTC2_SPI3_RST_Pos)   /*!< GCR IPRSTC2: SPI3_RST Mask */
S
S#define SYS_IPRSTC2_SPI2_RST_Pos                14                                  /*!< GCR IPRSTC2: SPI2_RST Position */
S#define SYS_IPRSTC2_SPI2_RST_Msk                (1ul << SYS_IPRSTC2_SPI2_RST_Pos)   /*!< GCR IPRSTC2: SPI2_RST Mask */
S
S#define SYS_IPRSTC2_SPI1_RST_Pos                13                                  /*!< GCR IPRSTC2: SPI1_RST Position */
S#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)   /*!< GCR IPRSTC2: SPI1_RST Mask */
S
S#define SYS_IPRSTC2_SPI0_RST_Pos                12                                  /*!< GCR IPRSTC2: SPI0_RST Position */
S#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)   /*!< GCR IPRSTC2: SPI0_RST Mask */
S
S#define SYS_IPRSTC2_I2C1_RST_Pos                9                                   /*!< GCR IPRSTC2: I2C1_RST Position */
S#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)   /*!< GCR IPRSTC2: I2C1_RST Mask */
S
S#define SYS_IPRSTC2_I2C0_RST_Pos                8                                   /*!< GCR IPRSTC2: I2C0_RST Position */
S#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)   /*!< GCR IPRSTC2: I2C0_RST Mask */
S
S#define SYS_IPRSTC2_TMR3_RST_Pos                5                                   /*!< GCR IPRSTC2: TMR3_RST Position */
S#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)   /*!< GCR IPRSTC2: TMR3_RST Mask */
S
S#define SYS_IPRSTC2_TMR2_RST_Pos                4                                   /*!< GCR IPRSTC2: TMR2_RST Position */
S#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)   /*!< GCR IPRSTC2: TMR2_RST Mask */
S
S#define SYS_IPRSTC2_TMR1_RST_Pos                3                                   /*!< GCR IPRSTC2: TMR1_RST Position */
S#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)   /*!< GCR IPRSTC2: TMR1_RST Mask */
S
S#define SYS_IPRSTC2_TMR0_RST_Pos                2                                   /*!< GCR IPRSTC2: TMR0_RST Position */
S#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)   /*!< GCR IPRSTC2: TMR0_RST Mask */
S
S#define SYS_IPRSTC2_GPIO_RST_Pos                1                                   /*!< GCR IPRSTC2: GPIO_RST Position */
S#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)   /*!< GCR IPRSTC2: GPIO_RST Mask */
S
S/* GCR IPRSTC3 Bit Field Definitions */
S#define SYS_IPRSTC3_SC2_RST_Pos                 2                                   /*!< GCR IPRSTC3: SC2_RST Position */
S#define SYS_IPRSTC3_SC2_RST_Msk                 (1ul << SYS_IPRSTC3_SC2_RST_Pos)    /*!< GCR IPRSTC3: SC2_RST Mask */
S
S#define SYS_IPRSTC3_SC1_RST_Pos                 1                                   /*!< GCR IPRSTC3: SC1_RST Position */
S#define SYS_IPRSTC3_SC1_RST_Msk                 (1ul << SYS_IPRSTC3_SC1_RST_Pos)    /*!< GCR IPRSTC3: SC1_RST Mask */
S
S#define SYS_IPRSTC3_SC0_RST_Pos                 0                                   /*!< GCR IPRSTC3: SC0_RST Position */
S#define SYS_IPRSTC3_SC0_RST_Msk                 (1ul << SYS_IPRSTC3_SC0_RST_Pos)    /*!< GCR IPRSTC3: SC0_RST Mask */
S
S/* GCR BODCR Bit Field Definitions */
S#define SYS_BODCR_LVR_EN_Pos                    7                                   /*!< GCR BODCR: LVR_EN Position */
S#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)       /*!< GCR BODCR: LVR_EN Mask */
S
S#define SYS_BODCR_BOD_OUT_Pos                   6                                   /*!< GCR BODCR: BOD_OUT Position */
S#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)      /*!< GCR BODCR: BOD_OUT Mask */
S
S#define SYS_BODCR_BOD_LPM_Pos                   5                                   /*!< GCR BODCR: BOD_LPM Position */
S#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)      /*!< GCR BODCR: BOD_LPM Mask */
S
S#define SYS_BODCR_BOD_INTF_Pos                  4                                   /*!< GCR BODCR: BOD_INTF Position */
S#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)     /*!< GCR BODCR: BOD_INTF Mask */
S
S#define SYS_BODCR_BOD_RSTEN_Pos                 3                                   /*!< GCR BODCR: BOD_RSTEN Position */
S#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)    /*!< GCR BODCR: BOD_RSTEN Mask */
S
S#define SYS_BODCR_BOD_VL_Pos                    1                                   /*!< GCR BODCR: BOD_VL Position */
S#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)       /*!< GCR BODCR: BOD_VL Mask */
S
S#define SYS_BODCR_BOD_EN_Pos                    0                                   /*!< GCR BODCR: BOD_EN Position */
S#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)       /*!< GCR BODCR: BOD_EN Mask */
S
S/* GCR TEMPCR Bit Field Definitions */
S#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                   /*!< GCR TEMPCR: VTEMP_EN Position */
S#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)    /*!< GCR TEMPCR: VTEMP_EN Mask */
S
S/* GCR PORCR Bit Field Definitions */
S#define SYS_PORCR_POR_DIS_CODE_Pos              0                                           /*!< GCR PORCR: POR_DIS_CODE Position */
S#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)    /*!< GCR PORCR: POR_DIS_CODE Mask */
S
S/* GCR GPAMFP Bit Field Definitions */
S#define SYS_GPA_MFP_GPA_TYPE_Pos                 16                                         /*!< GCR GPA_MFP: GPA_TYPE Position */
S#define SYS_GPA_MFP_GPA_TYPE_Msk                 (0xFFFFul << SYS_GPA_MFP_GPA_TYPE_Pos)     /*!< GCR GPA_MFP: GPA_TYPE Mask */
S
S#define SYS_GPA_MFP_GPA_MFP_Pos                  0                                          /*!< GCR GPA_MFP: GPA_MFP Position */
S#define SYS_GPA_MFP_GPA_MFP_Msk                  (0xFFFFul << SYS_GPA_MFP_GPA_MFP_Pos)      /*!< GCR GPA_MFP: GPA_MFP Mask */
S
S
S/* GCR GPBMFP Bit Field Definitions */
S#define SYS_GPB_MFP_GPB_TYPE_Pos                 16                                         /*!< GCR GPB_MFP: GPB_TYPE Position */
S#define SYS_GPB_MFP_GPB_TYPE_Msk                 (0xFFFFul << SYS_GPB_MFP_GPB_TYPE_Pos)     /*!< GCR GPB_MFP: GPB_TYPE Mask */
S
S#define SYS_GPB_MFP_GPB_MFP_Pos                  0                                          /*!< GCR GPB_MFP: GPB_MFP Position */
S#define SYS_GPB_MFP_GPB_MFP_Msk                  (0xFFFFul << SYS_GPB_MFP_GPB_MFP_Pos)      /*!< GCR GPB_MFP: GPB_MFP Mask */
S
S/* GCR GPCMFP Bit Field Definitions */
S#define SYS_GPC_MFP_GPC_TYPE_Pos                 16                                         /*!< GCR GPC_MFP: GPC_TYPE Position */
S#define SYS_GPC_MFP_GPC_TYPE_Msk                 (0xFFFFul << SYS_GPC_MFP_GPC_TYPE_Pos)     /*!< GCR GPC_MFP: GPC_TYPE Mask */
S
S#define SYS_GPC_MFP_GPC_MFP_Pos                  0                                          /*!< GCR GPC_MFP: GPC_MFP Position */
S#define SYS_GPC_MFP_GPC_MFP_Msk                  (0xFFFFul << SYS_GPC_MFP_GPC_MFP_Pos)      /*!< GCR GPC_MFP: GPC_MFP Mask */
S
S/* GCR GPDMFP Bit Field Definitions */
S#define SYS_GPD_MFP_GPD_TYPE_Pos                 16                                         /*!< GCR GPD_MFP: GPD_TYPE Position */
S#define SYS_GPD_MFP_GPD_TYPE_Msk                 (0xFFFFul << SYS_GPD_MFP_GPD_TYPE_Pos)     /*!< GCR GPD_MFP: GPD_TYPE Mask */
S
S#define SYS_GPD_MFP_GPD_MFP_Pos                  0                                          /*!< GCR GPD_MFP: GPD_MFP Position */
S#define SYS_GPD_MFP_GPD_MFP_Msk                  (0xFFFFul << SYS_GPD_MFP_GPD_MFP_Pos)      /*!< GCR GPD_MFP: GPD_MFP Mask */
S
S/* GCR GPEMFP Bit Field Definitions */
S#define SYS_GPE_MFP_GPE_TYPE_Pos                 16                                         /*!< GCR GPE_MFP: GPE_TYPE Position */
S#define SYS_GPE_MFP_GPE_TYPE_Msk                 (0xFFFFul << SYS_GPE_MFP_GPE_TYPE_Pos)     /*!< GCR GPE_MFP: GPE_TYPE Mask */
S
S#define SYS_GPE_MFP_GPE_MFP5_Pos                 5                                          /*!< GCR GPE_MFP: GPE_MFP5 Position */     
S#define SYS_GPE_MFP_GPE_MFP5_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP5_Pos)          /*!< GCR GPE_MFP: GPE_MFP5 Mask */
S
S#define SYS_GPE_MFP_GPE_MFP1_Pos                 1                                          /*!< GCR GPE_MFP: GPE_MFP1 Position */
S#define SYS_GPE_MFP_GPE_MFP1_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP1_Pos)          /*!< GCR GPE_MFP: GPE_MFP1 Mask */
S
S#define SYS_GPE_MFP_GPE_MFP0_Pos                 0                                          /*!< GCR GPE_MFP: GPE_MFP0 Position */
S#define SYS_GPE_MFP_GPE_MFP0_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP0_Pos)          /*!< GCR GPE_MFP: GPE_MFP0 Mask */
S
S/* GCR GPFMFP Bit Field Definitions */
S#define SYS_GPF_MFP_GPF_TYPE_Pos                 16                                         /*!< GCR GPF_MFP: GPF_TYPE Position */
S#define SYS_GPF_MFP_GPF_TYPE_Msk                 (0xFul << SYS_GPF_MFP_GPF_TYPE_Pos)        /*!< GCR GPF_MFP: GPF_TYPE Mask */
S
S#define SYS_GPF_MFP_GPF_MFP3_Pos                 3                                          /*!< GCR GPF_MFP: GPF_MFP3 Position */
S#define SYS_GPF_MFP_GPF_MFP3_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP3_Pos)          /*!< GCR GPF_MFP: GPF_MFP3 Mask */
S
S#define SYS_GPF_MFP_GPF_MFP2_Pos                 2                                          /*!< GCR GPF_MFP: GPF_MFP2 Position */
S#define SYS_GPF_MFP_GPF_MFP2_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP2_Pos)          /*!< GCR GPF_MFP: GPF_MFP2 Mask */
S
S#define SYS_GPF_MFP_GPF_MFP1_Pos                 1                                          /*!< GCR GPF_MFP: GPF_MFP1 Position */
S#define SYS_GPF_MFP_GPF_MFP1_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP1_Pos)          /*!< GCR GPF_MFP: GPF_MFP1 Mask */
S
S#define SYS_GPF_MFP_GPF_MFP0_Pos                 0                                          /*!< GCR GPF_MFP: GPF_MFP0 Position */
S#define SYS_GPF_MFP_GPF_MFP0_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP0_Pos)          /*!< GCR GPF_MFP: GPF_MFP0 Mask */
S
S/* GCR ALTMFP Bit Field Definitions */
S#define SYS_ALT_MFP_PB2_CPO0_Pos                30                                          /*!< GCR ALT_MFP: PB2_CPO0 Position */
S#define SYS_ALT_MFP_PB2_CPO0_Msk                (1ul << SYS_ALT_MFP_PB2_CPO0_Pos)           /*!< GCR ALT_MFP: PB2_CPO0 Mask */
S
S#define SYS_ALT_MFP_PB8_CLKO_Pos                29                                         /*!< GCR ALT_MFP: PB8_CLKO Position */
S#define SYS_ALT_MFP_PB8_CLKO_Msk                (1ul << SYS_ALT_MFP_PB8_CLKO_Pos)      /*!< GCR ALT_MFP: PB8_CLKO Mask */
S
S#define SYS_ALT_MFP_PA10_11_CAN1_Pos             28                                         /*!< GCR ALT_MFP: PA10_11_CAN1 Position */
S#define SYS_ALT_MFP_PA10_11_CAN1_Msk             (1ul << SYS_ALT_MFP_PA10_11_CAN1_Pos)      /*!< GCR ALT_MFP: PA10_11_CAN1 Mask */
S
S#define SYS_ALT_MFP_PB3_T3EX_Pos                 27                                         /*!< GCR ALT_MFP: PB3_T3EX Position */
S#define SYS_ALT_MFP_PB3_T3EX_Msk                 (1ul << SYS_ALT_MFP_PB3_T3EX_Pos)          /*!< GCR ALT_MFP: PB3_T3EX Mask */
S
S#define SYS_ALT_MFP_PB2_T2EX_Pos                 26                                         /*!< GCR ALT_MFP: PB2_T2EX Position */
S#define SYS_ALT_MFP_PB2_T2EX_Msk                 (1ul << SYS_ALT_MFP_PB2_T2EX_Pos)          /*!< GCR ALT_MFP: PB3_T3EX Mask */
S
S#define SYS_ALT_MFP_PE5_T1EX_Pos                 25                                         /*!< GCR ALT_MFP: PE5_T1EX Position */
S#define SYS_ALT_MFP_PE5_T1EX_Msk                 (1ul << SYS_ALT_MFP_PE5_T1EX_Pos)          /*!< GCR ALT_MFP: PE5_T1EX Mask */
S
S#define SYS_ALT_MFP_PB15_T0EX_Pos                24                                         /*!< GCR ALT_MFP: PB15_T0EX Position */
S#define SYS_ALT_MFP_PB15_T0EX_Msk                (1ul << SYS_ALT_MFP_PB15_T0EX_Pos)         /*!< GCR ALT_MFP: PB15_T0EX Mask */
S
S#define SYS_ALT_MFP_PB12_CLKO_Pos                10                                         /*!< GCR ALT_MFP: PB12_CLKO Position */
S#define SYS_ALT_MFP_PB12_CLKO_Msk                (1ul << SYS_ALT_MFP_PB12_CLKO_Pos)         /*!< GCR ALT_MFP: PB12_CLKO Mask */
S
S#define SYS_ALT_MFP_PA15_I2SMCLK_Pos             9                                          /*!< GCR ALT_MFP: PA15_I2SMCLK Position */
S#define SYS_ALT_MFP_PA15_I2SMCLK_Msk             (1ul << SYS_ALT_MFP_PA15_I2SMCLK_Pos)      /*!< GCR ALT_MFP: PA15_I2SMCLK Mask */
S
S#define SYS_ALT_MFP_PC3_I2SDO_Pos                8                                          /*!< GCR ALT_MFP: PC3_I2SDO Position */
S#define SYS_ALT_MFP_PC3_I2SDO_Msk                (1ul << SYS_ALT_MFP_PC3_I2SDO_Pos)         /*!< GCR ALT_MFP: PC3_I2SDO Mask */
S
S#define SYS_ALT_MFP_PC2_I2SDI_Pos                7                                          /*!< GCR ALT_MFP: PC2_I2SDI Position */
S#define SYS_ALT_MFP_PC2_I2SDI_Msk                (1ul << SYS_ALT_MFP_PC2_I2SDI_Pos)         /*!< GCR ALT_MFP: PC2_I2SDI Mask */
S
S#define SYS_ALT_MFP_PC1_I2SBCLK_Pos              6                                          /*!< GCR ALT_MFP: PC1_I2SBCLK Position */
S#define SYS_ALT_MFP_PC1_I2SBCLK_Msk              (1ul << SYS_ALT_MFP_PC1_I2SBCLK_Pos)       /*!< GCR ALT_MFP: PC1_I2SBCLK Mask */
S
S#define SYS_ALT_MFP_PC0_I2SLRCLK_Pos             5                                          /*!< GCR ALT_MFP: PC0_I2SLRCLK Position */
S#define SYS_ALT_MFP_PC0_I2SLRCLK_Msk             (1ul << SYS_ALT_MFP_PC0_I2SLRCLK_Pos)      /*!< GCR ALT_MFP: PC0_I2SLRCLK Mask */
S
S#define SYS_ALT_MFP_PB11_PWM4_Pos                4                                          /*!< GCR ALT_MFP: PB11_PWM4 Position */
S#define SYS_ALT_MFP_PB11_PWM4_Msk                (1ul << SYS_ALT_MFP_PB11_PWM4_Pos)         /*!< GCR ALT_MFP: PB11_PWM4 Mask */
S
S#define SYS_ALT_MFP_PB14_S31_Pos                 3                                          /*!< GCR ALT_MFP: PB14_S31 Position */
S#define SYS_ALT_MFP_PB14_S31_Msk                 (1ul << SYS_ALT_MFP_PB14_S31_Pos)          /*!< GCR ALT_MFP: PB14_S31 Mask */
S
S#define SYS_ALT_MFP_PA7_S21_Pos                  2                                          /*!< GCR ALT_MFP: PA7_S21 Position */
S#define SYS_ALT_MFP_PA7_S21_Msk                  (1ul << SYS_ALT_MFP_PA7_S21_Pos)           /*!< GCR ALT_MFP: PA7_S21 Mask */
S
S#define SYS_ALT_MFP_PB9_S11_Pos                  1                                          /*!< GCR ALT_MFP: PB9_S11 Position */
S#define SYS_ALT_MFP_PB9_S11_Msk                  (1ul << SYS_ALT_MFP_PB9_S11_Pos)           /*!< GCR ALT_MFP: PB9_S11 Mask */
S
S#define SYS_ALT_MFP_PB10_S01_Pos                 0                                          /*!< GCR ALT_MFP: PB10_S01 Position */
S#define SYS_ALT_MFP_PB10_S01_Msk                 (1ul << SYS_ALT_MFP_PB10_S01_Pos)          /*!< GCR ALT_MFP: PB10_S01 Mask */
S
S/* GCR ALTMFP1 Bit Field Definitions */
S#define SYS_ALT_MFP1_PB3_SC2CD_Pos              14                                          /*!< GCR ALT_MFP1: PB3_SC2CD Position */
S#define SYS_ALT_MFP1_PB3_SC2CD_Msk              (1ul << SYS_ALT_MFP1_PB3_SC2CD_Pos)         /*!< GCR ALT_MFP1: PB3_SC2CD Mask */
S
S#define SYS_ALT_MFP1_PA14_SC2RST_Pos            13                                          /*!< GCR ALT_MFP1: PA14_SC2RST Position */
S#define SYS_ALT_MFP1_PA14_SC2RST_Msk            (1ul << SYS_ALT_MFP1_PA14_SC2RST_Pos)       /*!< GCR ALT_MFP1: PA14_SC2RST Mask */
S
S#define SYS_ALT_MFP1_PA15_SC2PWR_Pos            12                                          /*!< GCR ALT_MFP1: PA15_SC2PWR Position */
S#define SYS_ALT_MFP1_PA15_SC2PWR_Msk            (1ul << SYS_ALT_MFP1_PA15_SC2PWR_Pos)       /*!< GCR ALT_MFP1: PA15_SC2PWR Mask */
S
S#define SYS_ALT_MFP1_PA12_SC2DAT_Pos             11                                          /*!< GCR ALT_MFP1: PA12_SC2DAT Position */
S#define SYS_ALT_MFP1_PA12_SC2DAT_Msk             (1ul << SYS_ALT_MFP1_PA12_SC2DAT_Pos)        /*!< GCR ALT_MFP1: PA12_SC2DAT Mask */
S
S#define SYS_ALT_MFP1_PA13_SC2CLK_Pos             10                                          /*!< GCR ALT_MFP1: PA13_SC2CLK Position */
S#define SYS_ALT_MFP1_PA13_SC2CLK_Msk             (1ul << SYS_ALT_MFP1_PA13_SC2CLK_Pos)        /*!< GCR ALT_MFP1: PA13_SC2CLK Mask */
S
S#define SYS_ALT_MFP1_PC7_SC1CD_Pos             9                                          /*!< GCR ALT_MFP1: PC7_SC1CD Position */
S#define SYS_ALT_MFP1_PC7_SC1CD_Msk             (1ul << SYS_ALT_MFP1_PC7_SC1CD_Pos)        /*!< GCR ALT_MFP1: PC7_SC1CD Mask */
S
S#define SYS_ALT_MFP1_PA5_SC1RST_Pos             8                                           /*!< GCR ALT_MFP1: PA5_SC1RST Position */
S#define SYS_ALT_MFP1_PA5_SC1RST_Msk             (1ul << SYS_ALT_MFP1_PA5_SC1RST_Pos)        /*!< GCR ALT_MFP1: PA5_SC1RST Mask */
S
S#define SYS_ALT_MFP1_PA4_SC1PWR_Pos             7                                           /*!< GCR ALT_MFP1: PA4_SC1PWR Position */
S#define SYS_ALT_MFP1_PA4_SC1PWR_Msk             (1ul << SYS_ALT_MFP1_PA4_SC1PWR_Pos)        /*!< GCR ALT_MFP1: PA4_SC1PWR Mask */
S
S#define SYS_ALT_MFP1_PA7_SC1DAT_Pos             6                                           /*!< GCR ALT_MFP1: PA7_SC1DAT Position */
S#define SYS_ALT_MFP1_PA7_SC1DAT_Msk             (1ul << SYS_ALT_MFP1_PA7_SC1DAT_Pos)        /*!< GCR ALT_MFP1: PA7_SC1DAT Mask */
S
S#define SYS_ALT_MFP1_PA6_SC1CLK_Pos             5                                           /*!< GCR ALT_MFP1: PA6_SC1CLK Position */
S#define SYS_ALT_MFP1_PA6_SC1CLK_Msk             (1ul << SYS_ALT_MFP1_PA6_SC1CLK_Pos)        /*!< GCR ALT_MFP1: PA6_SC1CLK Mask */
S
S#define SYS_ALT_MFP1_PC6_SC0CD_Pos              4                                           /*!< GCR ALT_MFP1: PC6_SC0CD Position */
S#define SYS_ALT_MFP1_PC6_SC0CD_Msk              (1ul << SYS_ALT_MFP1_PC6_SC0CD_Pos)         /*!< GCR ALT_MFP1: PC6_SC0CD Mask */
S
S#define SYS_ALT_MFP1_PA1_SC0RST_Pos             3                                           /*!< GCR ALT_MFP1: PA1_SC0RST Position */
S#define SYS_ALT_MFP1_PA1_SC0RST_Msk             (1ul << SYS_ALT_MFP1_PA1_SC0RST_Pos)        /*!< GCR ALT_MFP1: PA1_SC0RST Mask */
S
S#define SYS_ALT_MFP1_PA0_SC0PWR_Pos             2                                           /*!< GCR ALT_MFP1: PA0_SC0PWR Position */
S#define SYS_ALT_MFP1_PA0_SC0PWR_Msk             (1ul << SYS_ALT_MFP1_PA0_SC0PWR_Pos)        /*!< GCR ALT_MFP1: PA0_SC0PWR Mask */
S
S#define SYS_ALT_MFP1_PA3_SC0DAT_Pos             1                                           /*!< GCR ALT_MFP1: PA3_SC0DAT Position */
S#define SYS_ALT_MFP1_PA3_SC0DAT_Msk             (1ul << SYS_ALT_MFP1_PA3_SC0DAT_Pos)        /*!< GCR ALT_MFP1: PA3_SC0DAT Mask */
S
S#define SYS_ALT_MFP1_PA2_SC0CLK_Pos             0                                           /*!< GCR ALT_MFP1: PA2_SC0CLK Position */
S#define SYS_ALT_MFP1_PA2_SC0CLK_Msk             (1ul << SYS_ALT_MFP1_PA2_SC0CLK_Pos)        /*!< GCR ALT_MFP1: PA2_SC0CLK Mask */
S
S/* GCR IRCTRIMCTL Bit Field Definitions */
S#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos       8                                           /*!< GCR IRCTRIMCTL: CLKERR_STOP_EN Position */
S#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Msk       (1ul << SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos)  /*!< GCR IRCTRIMCTL: CLKERR_STOP_EN Mask */
S
S#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos       6                                           /*!< GCR IRCTRIMCTL: TRIM_RETRY_CNT Position */
S#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Msk       (3ul << SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos)  /*!< GCR IRCTRIMCTL: TRIM_RETRY_CNT Mask */
S
S#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos            4                                           /*!< GCR IRCTRIMCTL: TRIM_LOOP Position */
S#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk            (3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos)       /*!< GCR IRCTRIMCTL: TRIM_LOOP Mask */
S
S#define SYS_IRCTRIMCTL_TRIM_SEL_Pos             0                                           /*!< GCR IRCTRIMCTL: TRIM_SEL Position */
S#define SYS_IRCTRIMCTL_TRIM_SEL_Msk             (3ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)        /*!< GCR IRCTRIMCTL: TRIM_SEL Mask */
S
S/* GCR IRCTRIMIEN Bit Field Definitions */
S#define SYS_IRCTRIMIEN_CLKERR_IEN_Pos           2                                           /*!< GCR IRCTRIMIEN: CLKERR_IEN Position */
S#define SYS_IRCTRIMIEN_CLKERR_IEN_Msk           (1ul << SYS_IRCTRIMIEN_CLKERR_IEN_Pos)      /*!< GCR IRCTRIMIEN: CLKERR_IEN Mask */
S
S#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos        1                                           /*!< GCR IRCTRIMIEN: TRIM_FAIL_IEN Position */
S#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk        (1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)   /*!< GCR IRCTRIMIEN: TRIM_FAIL_IEN Mask */
S
S/* GCR IRCTRIMINT Bit Field Definitions */
S#define SYS_IRCTRIMINT_CLKERR_INT_Pos           2                                           /*!< GCR IRCTRIMINT: CLKERR_INT Position */
S#define SYS_IRCTRIMINT_CLKERR_INT_Msk           (1ul << SYS_IRCTRIMINT_CLKERR_INT_Pos)      /*!< GCR IRCTRIMINT: CLKERR_INT Mask */
S
S#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos        1                                           /*!< GCR IRCTRIMINT: TRIM_FAIL_INT Position */
S#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk        (1ul << SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos)   /*!< GCR IRCTRIMINT: TRIM_FAIL_INT Mask */
S
S#define SYS_IRCTRIMINT_FREQ_LOCK_Pos            0                                           /*!< GCR IRCTRIMINT: FREQ_LOCK Position */
S#define SYS_IRCTRIMINT_FREQ_LOCK_Msk            (1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)       /*!< GCR IRCTRIMINT: FREQ_LOCK Mask */
S
S/* GCR REGWRPROT Bit Field Definitions */
S#define SYS_REGWRPROT_REGWRPROT_Pos             0                                           /*!< GCR REGWRPROT: REGWRPROT Position */
S#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos)     /*!< GCR REGWRPROT: REGWRPROT Mask */
S
S
Stypedef struct
S{
S    __I uint32_t IRQSRC[32];
S    __IO uint32_t NMISEL;
S    __IO uint32_t MCUIRQ;
S} GCR_INT_T;
S
S/* INT IRQSRC Bit Field Definitions */
S#define INT_IRQSRC_INT_SRC_Pos                  0                                   /*!< INT IRQSRC: INT_SRC Position */ 
S#define INT_IRQSRC_INT_SRC_Msk                  (0xFul << INT_IRQSRC_INT_SRC_Pos)
S
S/* INT NMI_SEL Bit Field Definitions */
S#define INT_NMI_SEL_NMI_EN_Pos                  8                                   /*!< INT NMI_SEL: NMI_EN Position */      
S#define INT_NMI_SEL_NMI_EN_Msk                  (1ul << INT_NMI_SEL_NMI_EN_Pos)     /*!< INT NMI_SEL: NMI_EN Mask */
S
S#define INT_NMI_SEL_NMI_SEL_Pos                 0                                   /*!< INT NMI_SEL: NMI_SEL Position */
S#define INT_NMI_SEL_NMI_SEL_Msk                 (0x1Ful << INT_NMI_SEL_NMI_SEL_Pos) /*!< INT NMI_SEL: NMI_SEL Mask */
S/*@}*/ /* end of group NUC200_SYS */
S
S/*-------------------------- FLASH Memory Controller -------------------------*/
S/** @addtogroup NUC200_FMC NUC200 FMC
S  Memory Mapped Structure for NUC200 Series Flash Memory Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * ISPCON
S     * ===================================================================================================
S     * Offset: 0x00  ISP Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPEN     |ISP Enable
S     * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
S     * |        |          |1 = Enable ISP function
S     * |        |          |0 = Disable ISP function
S     * |[1]     |BS        |Boot Select 
S     * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM, 
S     * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where 
S     * |        |          |MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-
S     * |        |          |on reset; It keeps the same value at other reset.
S     * |        |          |1 = boot from LDROM
S     * |        |          |0 = boot from APROM
S     * |[4]     |CFGUEN    |Config Update Enable
S     * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program 
S     * |        |          |code is running in APROM or LDROM.
S     * |        |          |1 = Config update enable 
S     * |        |          |0 = Config update disable
S     * |[5]     |LDUEN     |LDROM Update Enable
S     * |        |          |LDROM update enable bit. 
S     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
S     * |        |          |0 = LDROM cannot be updated
S     * |[6]     |ISPFF     |ISP Fail Flag
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |(1) APROM writes to itself.
S     * |        |          |(2) LDROM writes to itself. 
S     * |        |          |(3) Destination address is illegal, such as over an available range.
S     * |        |          |Write 1 to clear.
S     * |[7]     |SWRST     |Software Reset
S     * |        |          |Writing 1 to this bit to start software reset. 
S     * |        |          |It is cleared by hardware after reset is finished.
S     * |[10:8]  |PT        |Flash Program Time
S     * |        |          |000 = 40 us
S     * |        |          |001 = 45 us
S     * |        |          |010 = 50 us
S     * |        |          |011 = 55 us
S     * |        |          |100 = 20 us
S     * |        |          |101 = 25 us
S     * |        |          |110 = 30 us
S     * |        |          |111 = 35 us
S     * |[14:12] |ET        |Flash Erase Time
S     * |        |          |000 = 20 ms (default)
S     * |        |          |001 = 25 ms 
S     * |        |          |010 = 30 ms 
S     * |        |          |011 = 35 ms 
S     * |        |          |100 = 3  ms 
S     * |        |          |101 = 5  ms 
S     * |        |          |110 = 10 ms 
S     * |        |          |111 = 15 ms 
S     */    
S    __IO uint32_t ISPCON;
S
S    /**
S     * ISPADR
S     * ===================================================================================================
S     * Offset: 0x04  ISP Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPADR    |ISP Address 
S     * |        |          |NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program 
S     * |        |          |only. ISPARD[1:0] must be kept 2'b00 for ISP operation. 
S     */    
S    __IO uint32_t ISPADR;
S
S    /**
S     * ISPDAT
S     * ===================================================================================================
S     * Offset: 0x08  ISP Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT    |ISP Data 
S     * |        |          |Write data to this register before ISP program operation
S     * |        |          |Read data from this register after ISP read operation
S     */    
S    __IO uint32_t ISPDAT;
S
S    /**
S     * ISPCMD
S     * ===================================================================================================
S     * Offset: 0x0C  ISP Command Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command 
S     * |        |          |ISP command table is shown below:
S     * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
S     * |        |          |Read          ,    0,    0, 0000
S     * |        |          |Program       ,    1,    0, 0001
S     * |        |          |Page Erase    ,    1,    0, 0010
S     */    
S    __IO uint32_t ISPCMD;
S
S    /**
S     * ISPTRG
S     * ===================================================================================================
S     * Offset: 0x10  IISP Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPGO     |ISP start trigger
S     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP 
S     * |        |          |operation is finish. 
S     * |        |          |1 = ISP is on going 
S     * |        |          |0 = ISP done
S     */    
S    __IO uint32_t ISPTRG;
S
S    /**
S     * DFBADR
S     * ===================================================================================================
S     * Offset: 0x14  Data Flash Base Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |DFBA      |Data Flash Base Address
S     * |        |          |This register indicates data flash start address. 
S     * |        |          | 
S     * |        |          |It is a read only register. 
S     * |        |          | 
S     * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at 
S     * |        |          |0x01F000 by hardware internally.
S     */    
S    __I  uint32_t DFBADR;
S
S    /**
S     * FATCON
S     * ===================================================================================================
S     * Offset: 0x18  Flash Access Time Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FPSEN     |Flash Power Save Enable
S     * |        |          |If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
S     * |        |          |1 = Enable flash power saving
S     * |        |          |0 = Disable flash power saving
S     * |[3:1]   |FATS      |Flash Access Time Window Select
S     * |        |          |These bits are used to decide flash sense amplifier active duration.
S     * |        |          |000 = 40 ns
S     * |        |          |001 = 50 ns
S     * |        |          |010 = 60 ns
S     * |        |          |011 = 70 ns
S     * |        |          |100 = 80 ns
S     * |        |          |101 = 90 ns
S     * |        |          |110 = 100 ns
S     * |        |          |111 = Reserved
S     * |[4]     |L_SPEED   |Flash Low Speed Mode Enable
S     * |        |          |1 = Flash access always no wait state (zero wait state)
S     * |        |          |0 = Insert wait state while Flash access discontinued address. 
S     * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong 
S     * |        |          |code and cause fail result.
S     */    
S    __IO uint32_t FATCON;
S    
S    __I  uint32_t  RESERVED[9];
S
S    __IO uint32_t ISPSTA;
S
S} FMC_T;
S
S/* FMC ISPCON Bit Field Definitions */
S#define FMC_ISPCON_ET_Pos                       12                                      /*!< FMC ISPCON: ET Position */
S#define FMC_ISPCON_ET_Msk                       (7ul << FMC_ISPCON_ET_Pos)              /*!< FMC ISPCON: ET Mask     */
S
S#define FMC_ISPCON_PT_Pos                       8                                       /*!< FMC ISPCON: PT Position */
S#define FMC_ISPCON_PT_Msk                       (7ul << FMC_ISPCON_PT_Pos)              /*!< FMC ISPCON: PT Mask     */
S
S#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC ISPCON: ISPFF Position */
S#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC ISPCON: ISPFF Mask */
S
S#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC ISPCON: LDUEN Position */
S#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC ISPCON: LDUEN Mask */
S
S#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC ISPCON: CFGUEN Position */
S#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC ISPCON: CFGUEN Mask */
S
S#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC ISPCON: APUEN Position */
S#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC ISPCON: APUEN Mask */
S
S#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC ISPCON: BS Position */
S#define FMC_ISPCON_BS_Msk                       (0x1ul << FMC_ISPCON_BS_Pos)            /*!< FMC ISPCON: BS Mask */
S                                                                                        
S#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC ISPCON: ISPEN Position */
S#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC ISPCON: ISPEN Mask */
S
S/* FMC ISPADR Bit Field Definitions */
S#define FMC_ISPADR_ISPADR_Pos                   0                                       /*!< FMC ISPADR: ISPADR Position */
S#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos) /*!< FMC ISPADR: ISPADR Mask     */
S
S/* FMC ISPADR Bit Field Definitions */
S#define FMC_ISPDAT_ISPDAT_Pos                   0                                       /*!< FMC ISPDAT: ISPDAT Position */
S#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos) /*!< FMC ISPDAT: ISPDAT Mask     */
S
S/* FMC ISPCMD Bit Field Definitions */
S#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC ISPCMD: FOEN Position */
S#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC ISPCMD: FOEN Mask */
S
S#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC ISPCMD: FCEN Position */
S#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC ISPCMD: FCEN Mask */
S
S#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC ISPCMD: FCTRL Position */
S#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC ISPCMD: FCTRL Mask */
S
S/* FMC ISPTRG Bit Field Definitions */
S#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC ISPTRG: ISPGO Position */
S#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC ISPTRG: ISPGO Mask */
S
S/* FMC DFBADR Bit Field Definitions */
S#define FMC_DFBADR_DFBA_Pos                     0                                       /*!< FMC DFBADR: DFBA Position */
S#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)   /*!< FMC DFBADR: DFBA Mask     */
S
S/* FMC FATCON Bit Field Definitions */
S#define FMC_FATCON_MFOM_Pos                     6                                       /*!< FMC FATCON: MFOM Position */
S#define FMC_FATCON_MFOM_Msk                     (1ul << FMC_FATCON_MFOM_Pos)            /*!< FMC FATCON: MFOM Mask */
S
S#define FMC_FATCON_LFOM_Pos                     4                                       /*!< FMC FATCON: LFOM Position */
S#define FMC_FATCON_LFOM_Msk                     (1ul << FMC_FATCON_LFOM_Pos)            /*!< FMC FATCON: LFOM Mask */
S
S#define FMC_FATCON_FATS_Pos                     1                                       /*!< FMC FATCON: FATS Position */
S#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)            /*!< FMC FATCON: FATS Mask */
S
S#define FMC_FATCON_FPSEN_Pos                    0                                       /*!< FMC FATCON: FPSEN Position */
S#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)           /*!< FMC FATCON: FPSEN Mask */
S
S
S#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC ISPSTA: ISPGO Position */
S#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC ISPSTA: ISPGO Mask */
S
S#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC ISPSTA: CBS Position */
S#define FMC_ISPSTA_CBS_Msk                      (0x3ul << FMC_ISPSTA_CBS_Pos)           /*!< FMC ISPSTA: CBS Mask */
S
S#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC ISPSTA: ISPFF Position */
S#define FMC_ISPSTA_ISPFF_Msk                    (0x3ul << FMC_ISPSTA_ISPFF_Pos)         /*!< FMC ISPSTA: ISPFF Mask */
S
S#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC ISPSTA: VECMAP Position */
S#define FMC_ISPSTA_VECMAP_Msk                   (0xFFFul << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC ISPSTA: VECMAP Mask */
S
S
S/*@}*/ /* end of group NUC200_FMC */
S
S
S/*------------------------------ PS2 Controller ------------------------------*/
S/** @addtogroup NUC200_PS2 NUC200 PS2
S  Memory Mapped Structure for NUC200 Series PS2 Serial Interface Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * PS2CON
S     * ===================================================================================================
S     * Offset: 0x00  PS2 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field        |Descriptions
S     * | :----: | :----:      | :---- |
S     * |[0]     |PS2EN        |Enable PS2 Device
S		 * |        |             |Enable PS2 device controller.
S     * |        |             |1 = Enable
S     * |        |             |0 = Disable
S     * |[1]     |TXINTEN      |Enable Transmit Interrupt
S     * |        |             |1 = Enable data transmit complete interrupt.
S     * |        |             |0 = Disable data transmit complete interrupt.
S     * |[2]     |RXINTEN      |Enable Receive Interrupt
S     * |        |             |1 = Enable data receive complete interrupt.
S     * |        |             |0 = Disable data receive complete interrupt.
S     * |[6:3]   |TXFIFO_DEPTH |Transmit data FIFO Depth
S     * |        |             |There is 16 bytes buffer for data trnsmit. S/W can define the FIFO depth from 1 to 16 bytes depends
S     * |        |             |on appliction.  
S     * |        |             | 0 =  1 byte
S     * |        |             | 1 =  2 bytes             
S     * |        |             |...
S     * |        |             |14 = 15 btyes
S     * |        |             |15 = 16 bytes             
S     * |[7]     |ACK          |Acknowledge Enable
S     * |        |             |1 = if parity error or stop bit is not received correctly, acknowledge bit will not be sent to host
S     * |        |             |    at 12th clock.
S     * |        |             |0 = Always send acknowledge to host at 12th clock for host to device communication
S     * |[8]     |CLRFIFO      |Clear TX FIFO
S     * |        |             |Write 1 to this bit to terminate device to host transmission. The TXEMPTY bit in PS2STATUS bit will
S     * |        |             |be set to 1 and pointer BYTEINDEX is reset to 0 regardless there is residue data in buffer or not. 
S     * |        |             |The buffer content is not been cleared.
S     * |        |             |1 = Clear FIFO.
S     * |        |             |0 = Not active.
S     * |[9]     |OVERRIDE     |Software Override PS2 CLK/DATA Pin State
S     * |        |             |1 = PS2CLK and PS2DATA pins are controlled by S/W.
S     * |        |             |0 = PS2CLK and PS2DATA pins are controlled by internal state machine.
S     * |[10]    |FPS2CLK      |Force PS2CLK Line
S     * |        |             |It forces PS2CLK line high or low regardless of the internal state of the device controller if
S     * |        |             |OVERRIDE is set to high.
S     * |        |             |1 = Force PS2CLK line high.
S     * |        |             |0 = Force PS2CLK line low.
S     * |[11]    |FPS2DAT      |Force PS2DATA Line 
S     * |        |             |It forces PS2DATA high or low regardless of the internal state of the device controller if OVERRIDE
S     * |        |             |is set to high.
S     * |        |             |1 = Force PS2DATA high.
S     * |        |             |0 = Force PS2DATA low.                                                                         
S     */  	
S		__IO uint32_t PS2CON;
S		
S    /**
S     * PS2TXDATA0
S     * ===================================================================================================
S     * Offset: 0x04  PS2 TX DATA Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |PS2TXDATAx|Transmit data
S     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
S     * |        |          |enable PS2EN before writing data to TX buffer.
S     */ 						
S		__IO uint32_t PS2TXDATA0;
S		
S    /**
S     * PS2TXDATA1
S     * ===================================================================================================
S     * Offset: 0x08  PS2 TX DATA Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |PS2TXDATAx|Transmit data
S     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
S     * |        |          |enable PS2EN before writing data to TX buffer.
S     */ 		
S		__IO uint32_t PS2TXDATA1;
S		
S    /**
S     * PS2TXDATA2
S     * ===================================================================================================
S     * Offset: 0x0C  PS2 TX DATA Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |PS2TXDATAx|Transmit data
S     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
S     * |        |          |enable PS2EN before writing data to TX buffer.
S     */ 			
S		__IO uint32_t PS2TXDATA2;
S		
S    /**
S     * PS2TXDATA3
S     * ===================================================================================================
S     * Offset: 0x10  PS2 TX DATA Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |PS2TXDATAx|Transmit data
S     * |        |          |Write data to this register starts device to host communication if bus is in IDLE state. S/W must 
S     * |        |          |enable PS2EN before writing data to TX buffer.
S     */ 		
S		__IO uint32_t PS2TXDATA3;
S		
S    /**
S     * PS2RXDATA
S     * ===================================================================================================
S     * Offset: 0x14  PS2 Receive Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |GC        |Received Data
S     * |        |          |For host to device communication, after acknowledge bit is sent, the received data is copied from
S     * |        |          |receive shift register to PS2RXDATA register. CPU must read this register before next byte 
S     * |        |          |reception complete, otherwise the data will be overwritten and RXOVF bit in PS2STATUS[6] will be
S     * |        |          |set to 1.
S     */  		
S		__IO uint32_t PS2RXDATA;
S		
S     /**
S     * PS2STATUS
S     * ===================================================================================================
S     * Offset: 0x18  PS2 Status Register 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PS2CLK    |CLK Pin State
S     * |        |          |This bit reflects the status of the PS2CLK line after synchronizing.
S     * |[1]     |PS2DATA   |DATA Pin State
S     * |        |          |This bit reflects the status of the PS2DATA line after synchronizing and sampling.
S     * |[2]     |FRAMERR   |FrameError
S     * |        |          |For host to device communication, if STOP bit (logic 1) is not received it is a frame error. If
S     * |        |          |frame error occurs, DATA line may keep at low state after 12th clock. At this moment, S/W 
S     * |        |          |overrides PS2CLK to send clock till PS2DATA release to high state. After that, device sends a 
S     * |        |          |"Resend" command to host.
S     * |        |          |1 = Frame error occur.
S     * |        |          |0 = No Frame error.
S     * |        |          |Write 1 to clear this bit.
S     * |[3]     |RXPARITY  |Received Parity
S     * |        |          |This bit reflects the parity bit for the last received data byte (odd parity).
S     * |        |          |Read only bit.
S     * |[4]     |RXBUSY    |Receive Busy
S     * |        |          |This bit indicates that the PS2 device is currently receiving data.
S     * |        |          |1 = Currently receiving data.
S     * |        |          |0 = Idle.
S     * |        |          |Read only bit.
S     * |[5]     |TXBUSY    |Transmit Busy
S     * |        |          |This bit indicates that the PS2 device is currently sending data.
S     * |        |          |1 = Currently sending data.
S     * |        |          |0 = Idle.
S     * |        |          |Read only bit.
S     * |[6]     |RXOVF     |RX Buffer Overwrite
S     * |        |          |1 = Data in PS2RXDATA register is overwritten by new received data. 
S     * |        |          |0 = No overwrite.
S     * |        |          |Write 1 to clear this bit.                                                                      
S     * |[7]     |TXEMPTY   |TX FIFO Empty
S     * |        |          |When S/W writes any data to PS2TXDATA0~3 the TXEMPTY bit is cleared to 0 immediately if PS2EN is 
S     * |        |          |enabled. When transmitted data byte number is equal to FIFODEPTH then TXEMPTY bit is set to 1.
S     * |        |          |1 = FIFO is empty.
S     * |        |          |0 = There is data to be transmitted.                         
S     * |[11:8]  |BYTEIDX   |Byte Index
S     * |        |          |It indicates which data byte in transmit data shift register. When all data in FIFO is 
S     * |        |          |transmitted and it will be cleared to 0.
S     * |        |          |It is a read only bit.
S     * |        |          |
S     * |        |          |BYTEIDX, DATA Transmit , BYTEIDX, DATA Transmit
S     * |        |          |0000   , TXDATA0[ 7: 0], 1000   , TXDATA2[ 7: 0],
S     * |        |          |0001   , TXDATA0[15: 8], 1001   , TXDATA2[15: 8],
S     * |        |          |0010   , TXDATA0[23:16], 1010   , TXDATA2[23:16],
S     * |        |          |0011   , TXDATA0[31:24], 1011   , TXDATA2[31:24],
S     * |        |          |0100   , TXDATA1[ 7: 0], 1100   , TXDATA3[ 7: 0],
S     * |        |          |0101   , TXDATA1[15: 8], 1101   , TXDATA3[15: 8],
S     * |        |          |0110   , TXDATA1[23:16], 1110   , TXDATA3[23:16],                           
S     * |        |          |0111   , TXDATA1[31:24], 1111   , TXDATA3[31:24],                   
S     */   		
S		__IO uint32_t PS2STATUS;
S		
S     /**
S     * PS2INTID
S     * ===================================================================================================
S     * Offset: 0x1C  PS2 Interrupt Identification Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RXINT     |Receive Interrupt
S	 * |        |          |This bit is set to 1 when acknowledge bit is sent for Host to device communication. Interrupt      
S	 * |        |          |occurs if RXINTEN bit is set to 1.
S     * |        |          |1 = Receive interrupt occurs.
S     * |        |          |0 = No interrupt.
S     * |        |          |Write 1 to clear this bit to 0.     
S     * |[1]     |TXINT     |Transmit Interrupt 
S     * |        |          |This bit is set to 1 after STOP bit is transmitted. Interrupt occur if TXINTEN bit is set to 1.
S     * |        |          |1 = Transmit interrupt occurs.
S     * |        |          |0 = No interrupt.
S     * |        |          |Write 1 to clear this bit to 0.        
S     */   		
S		__IO uint32_t PS2INTID;
S}PS2_T;
S
S
S/* PS2 PS2CON Bit Field Definitions */
S#define PS2_PS2CON_PS2EN_Pos                       0										/*!< PS2 PS2CON: PS2EN Position */
S#define PS2_PS2CON_PS2EN_Msk                       (1ul << PS2_PS2CON_PS2EN_Pos)  			/*!< PS2 PS2CON: PS2EN Mask */
S
S#define PS2_PS2CON_TXINTEN_Pos                     1										/*!< PS2 PS2CON: TXINTEN Position */
S#define PS2_PS2CON_TXINTEN_Msk                     (1ul << PS2_PS2CON_TXINTEN_Pos)		    /*!< PS2 PS2CON: TXINTEN Mask */ 
S
S#define PS2_PS2CON_RXINTEN_Pos                     2										/*!< PS2 PS2CON: RXINTEN Position */
S#define PS2_PS2CON_RXINTEN_Msk                     (1ul << PS2_PS2CON_RXINTEN_Pos)  	    /*!< PS2 PS2CON: RXINTEN Mask */
S
S#define PS2_PS2CON_TXFIFO_DEPTH_Pos                3									    /*!< PS2 PS2CON: TXFIFO_DEPTH Position */
S#define PS2_PS2CON_TXFIFO_DEPTH_Msk                (0xFul << PS2_PS2CON_TXFIFO_DEPTH_Pos)	/*!< PS2 PS2CON: TXFIFO_DEPTH Mask */
S
S#define PS2_PS2CON_ACK_Pos                         7									    /*!< PS2 PS2CON: ACK Position */
S#define PS2_PS2CON_ACK_Msk                         (1ul << PS2_PS2CON_ACK_Pos)				/*!< PS2 PS2CON: ACK Mask */ 
S
S#define PS2_PS2CON_CLRFIFO_Pos                     8										/*!< PS2 PS2CON: CLRFIFO Position */
S#define PS2_PS2CON_CLRFIFO_Msk                     (1ul << PS2_PS2CON_CLRFIFO_Pos)  		/*!< PS2 PS2CON: CLRFIFO Mask */
S
S#define PS2_PS2CON_OVERRIDE_Pos                    9										/*!< PS2 PS2CON: OVERRIDE Position */
S#define PS2_PS2CON_OVERRIDE_Msk                    (1ul << PS2_PS2CON_OVERRIDE_Pos)  		/*!< PS2 PS2CON: OVERRIDE Mask */
S
S#define PS2_PS2CON_FPS2CLK_Pos                     10										/*!< PS2 PS2CON: FPS2CLK Position */
S#define PS2_PS2CON_FPS2CLK_Msk                     (1ul << PS2_PS2CON_FPS2CLK_Pos) 			/*!< PS2 PS2CON: FPS2CLK Mask */
S
S#define PS2_PS2CON_FPS2DAT_Pos                     11									    /*!< PS2 PS2CON: FPS2DAT Position */
S#define PS2_PS2CON_FPS2DAT_Msk                     (1ul << PS2_PS2CON_FPS2DAT_Pos) 			/*!< PS2 PS2CON: FPS2DAT Mask */
S
S/* PS/2 PS2RXDATA Bit Field Definitions */
S#define PS2_PS2RXDATA_RXDATA_Pos                   0										/*!< PS2 PS2RXDATA: RXDATA Position */
S#define PS2_PS2RXDATA_RXDATA_Msk                   (0xFFul << PS2_PS2RXDATA_RXDATA_Pos)		/*!< PS2 PS2RXDATA: RXDATA Mask */
S
S/* PS/2 PS2STATUS Bit Field Definitions */
S#define PS2_PS2STATUS_PS2CLK_Pos                   0									    /*!< PS2 PS2STATUS: PS2CLK Position */
S#define PS2_PS2STATUS_PS2CLK_Msk                   (1ul << PS2_PS2STATUS_PS2CLK_Pos) 		/*!< PS2 PS2STATUS: PS2CLK Mask */
S
S#define PS2_PS2STATUS_PS2DATA_Pos                  1										/*!< PS2 PS2STATUS: PS2DATA Position */
S#define PS2_PS2STATUS_PS2DATA_Msk                  (1ul << PS2_PS2STATUS_PS2DATA_Pos) 		/*!< PS2 PS2STATUS: PS2DATA Mask */
S
S#define PS2_PS2STATUS_FRAMERR_Pos                  2										/*!< PS2 PS2STATUS: FRAMERR Position */
S#define PS2_PS2STATUS_FRAMERR_Msk                  (1ul << PS2_PS2STATUS_FRAMERR_Pos)		/*!< PS2 PS2STATUS: FRAMERR Mask */ 
S
S#define PS2_PS2STATUS_RXPARITY_Pos                 3										/*!< PS2 PS2STATUS: RXPARITY Position */
S#define PS2_PS2STATUS_RXPARITY_Msk                 (1ul << PS2_PS2STATUS_RXPARITY_Pos) 		/*!< PS2 PS2STATUS: RXPARITY Mask */
S
S#define PS2_PS2STATUS_RXBUSY_Pos                   4										/*!< PS2 PS2STATUS: RXBUSY Position */
S#define PS2_PS2STATUS_RXBUSY_Msk                   (1ul << PS2_PS2STATUS_RXBUSY_Pos)		/*!< PS2 PS2STATUS: RXBUSY Mask */
S
S#define PS2_PS2STATUS_TXBUSY_Pos                   5										/*!< PS2 PS2STATUS: TXBUSY Position */
S#define PS2_PS2STATUS_TXBUSY_Msk                   (1ul << PS2_PS2STATUS_TXBUSY_Pos)		/*!< PS2 PS2STATUS: TXBUSY Mask */
S
S#define PS2_PS2STATUS_RXOVF_Pos                    6										/*!< PS2 PS2STATUS: RXOVF Position */
S#define PS2_PS2STATUS_RXOVF_Msk                    (1ul << PS2_PS2STATUS_RXOVF_Pos)			/*!< PS2 PS2STATUS: RXOVF Mask */
S
S#define PS2_PS2STATUS_TXEMPTY_Pos                  7										/*!< PS2 PS2STATUS: TXEMPTY Position */
S#define PS2_PS2STATUS_TXEMPTY_Msk                  (1ul << PS2_PS2STATUS_TXEMPTY_Pos)		/*!< PS2 PS2STATUS: TXEMPTY Mask */
S
S#define PS2_PS2STATUS_BYTEIDX_Pos                  8										/*!< PS2 PS2STATUS: BYTEIDX Position */
S#define PS2_PS2STATUS_BYTEIDX_Msk                  (0xFul << PS2_PS2STATUS_BYTEIDX_Pos)		/*!< PS2 PS2STATUS: BYTEIDX Mask */
S
S/* PS/2 PS2INTID Bit Field Definitions */
S#define PS2_PS2INTID_RXINT_Pos                     0										/*!< PS2 PS2INTID : RXINT Position */
S#define PS2_PS2INTID_RXINT_Msk                     (1ul << PS2_PS2INTID_RXINT_Pos) 			/*!< PS2 PS2INTID : RXINT Mask */
S                     
S#define PS2_PS2INTID_TXINT_Pos                     1										/*!< PS2 PS2INTID : TXINT Position */
S#define PS2_PS2INTID_TXINT_Msk                     (1ul << PS2_PS2INTID_TXINT_Pos) 			/*!< PS2 PS2INTID : TXINT Mask */
S/*@}*/ /* end of group NUC200_PS2 */
S
S/*----------------------------- CAN Controller ------------------------------*/
S/** @addtogroup NUC200_CAN NUC200 CAN
S  Register Structure for NUC200 Series CAN Device Controller 
S  @{
S */
S
Stypedef struct
S{
S    __IO uint32_t CREQ;
S    __IO uint32_t CMASK;
S    __IO uint32_t MASK1;
S    __IO uint32_t MASK2;
S    __IO uint32_t ARB1;
S    __IO uint32_t ARB2;	
S    __IO uint32_t MCON;			
S    __IO uint32_t DAT_A1;			
S    __IO uint32_t DAT_A2;		
S    __IO uint32_t DAT_B1;
S    __IO uint32_t DAT_B2;		
S    __I uint32_t RESERVE0[13];        
S                                    
S} CAN_IF_T;
S
Stypedef struct
S{
S    __IO uint32_t   CON;		 	
S    __IO uint32_t   STATUS;	
S    __IO uint32_t   ERR;     		
S    __IO uint32_t   BTIME;
S    __IO uint32_t   IIDR;
S    __IO uint32_t   TEST;
S    __IO uint32_t   BRPE;
S    __I uint32_t   	RESERVE0[1];     
S    CAN_IF_T        IF[2];             
S 	__I uint32_t   	RESERVE1[8];
S    __IO uint32_t   TXREQ1;
S    __IO uint32_t   TXREQ2;
S    __I uint32_t   	RESERVE2[6];        
S    __IO uint32_t   NDAT1;
S    __IO uint32_t   NDAT2;
S    __I uint32_t   	RESERVE3[6];
S    __IO uint32_t   IPND1;
S    __IO uint32_t   IPND2;
S    __I uint32_t   	RESERVE4[6];
S    __IO uint32_t   MVLD1;
S    __IO uint32_t   MVLD2;
S    __IO uint32_t   WU_EN;            
S    __IO uint32_t   WU_STATUS;
S} CAN_T;
S
S
S/* CAN CON Bit Field Definitions */
S#define CAN_CON_TEST_Pos           7                                    /*!< CAN CON: TEST Position */  
S#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)            /*!< CAN CON: TEST Mask     */  
S
S#define CAN_CON_CCE_Pos            6                                    /*!< CAN CON: CCE Position  */  
S#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)             /*!< CAN CON: CCE Mask      */  
S
S#define CAN_CON_DAR_Pos            5                                    /*!< CAN CON: DAR Position  */  
S#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)             /*!< CAN CON: DAR Mask      */  
S
S#define CAN_CON_EIE_Pos            3                                    /*!< CAN CON: EIE Position  */  
S#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)             /*!< CAN CON: EIE Mask      */  
S
S#define CAN_CON_SIE_Pos            2                                    /*!< CAN CON: SIE Position  */  
S#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)             /*!< CAN CON: SIE Mask      */  
S
S#define CAN_CON_IE_Pos             1                                    /*!< CAN CON: IE Position   */  
S#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)              /*!< CAN CON: IE Mask       */  
S
S#define CAN_CON_INIT_Pos           0                                    /*!< CAN CON: INIT Position */  
S#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)            /*!< CAN CON: INIT Mask     */  
S
S/* CAN STATUS Bit Field Definitions */
S#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN STATUS: BOFF Position  */
S#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)         /*!< CAN STATUS: BOFF Mask      */
S
S#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN STATUS: EWARN Position */
S#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)        /*!< CAN STATUS: EWARN Mask     */
S
S#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN STATUS: EPASS Position */
S#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)        /*!< CAN STATUS: EPASS Mask     */
S
S#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN STATUS: RXOK Position  */
S#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN STATUS: RXOK Mask      */
S
S#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN STATUS: TXOK Position  */
S#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN STATUS: TXOK Mask      */
S
S#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN STATUS: LEC Position   */
S#define CAN_STATUS_LEC_Msk         (0x3ul << CAN_STATUS_LEC_Pos)        /*!< CAN STATUS: LEC Mask       */
S
S/* CAN ERR Bit Field Definitions */
S#define CAN_ERR_RP_Pos             15                                   /*!< CAN ERR: RP Position       */
S#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)              /*!< CAN ERR: RP Mask           */
S
S#define CAN_ERR_REC_Pos            8                                    /*!< CAN ERR: REC Position      */
S#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN ERR: REC Mask          */
S
S#define CAN_ERR_TEC_Pos            0                                    /*!< CAN ERR: TEC Position      */
S#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN ERR: TEC Mask          */
S
S/* CAN BTIME Bit Field Definitions */   
S#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN BTIME: TSEG2 Position  */
S#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN BTIME: TSEG2 Mask      */
S
S#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN BTIME: TSEG1 Position  */
S#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN BTIME: TSEG1 Mask      */
S
S#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN BTIME: SJW Position    */
S#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN BTIME: SJW Mask        */
S
S#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN BTIME: BRP Position    */
S#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN BTIME: BRP Mask        */
S
S/* CAN IIDR Bit Field Definitions */
S#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN IIDR: INTID Position   */
S#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN IIDR: INTID Mask       */
S
S/* CAN TEST Bit Field Definitions */
S#define CAN_TEST_RX_Pos            7                                    /*!< CAN TEST: RX Position      */
S#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)             /*!< CAN TEST: RX Mask          */
S
S#define CAN_TEST_TX_Pos            5                                    /*!< CAN TEST: TX Position      */
S#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN TEST: TX Mask          */
S
S#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN TEST: LBACK Position   */
S#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)          /*!< CAN TEST: LBACK Mask       */
S             
S#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN TEST: Silent Position  */
S#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)         /*!< CAN TEST: Silent Mask      */
S
S#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN TEST: Basic Position   */
S#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)          /*!< CAN TEST: Basic Mask       */
S
S/* CAN BPRE Bit Field Definitions */
S#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN BRPE: BRPE Position    */
S#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN BRPE: BRPE Mask        */
S
S/* CAN IFn_CREQ Bit Field Definitions */
S#define CAN_IF_CREQ_BUSY_Pos       15                                   /*!< CAN IFnCREQ: BUSY Position */
S#define CAN_IF_CREQ_BUSY_Msk       (1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN IFnCREQ: BUSY Mask     */
S
S#define CAN_IF_CREQ_MSGNUM_Pos     0                                    /*!< CAN IFnCREQ: MSGNUM Position */
S#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)   /*!< CAN IFnCREQ: MSGNUM Mask     */
S
S/* CAN IFn_CMASK Bit Field Definitions */
S#define CAN_IF_CMASK_WRRD_Pos      7                                    /*!< CAN IFnCMASK: WRRD Position */
S#define CAN_IF_CMASK_WRRD_Msk      (1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN IFnCMASK: WRRD Mask     */
S
S#define CAN_IF_CMASK_MASK_Pos      6                                    /*!< CAN IFnCMASK: MASK Position */
S#define CAN_IF_CMASK_MASK_Msk      (1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN IFnCMASK: MASK Mask     */
S
S#define CAN_IF_CMASK_ARB_Pos       5                                    /*!< CAN IFnCMASK: ARB Position  */
S#define CAN_IF_CMASK_ARB_Msk       (1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN IFnCMASK: ARB Mask      */
S
S#define CAN_IF_CMASK_CONTROL_Pos   4                                    /*!< CAN IFnCMASK: CONTROL Position */
S#define CAN_IF_CMASK_CONTROL_Msk   (1ul << CAN_IF_CMASK_CONTROL_Pos)    /*!< CAN IFnCMASK: CONTROL Mask */
S
S#define CAN_IF_CMASK_CLRINTPND_Pos 3                                    /*!< CAN IFnCMASK: CLRINTPND Position */
S#define CAN_IF_CMASK_CLRINTPND_Msk (1ul << CAN_IF_CMASK_CLRINTPND_Pos)  /*!< CAN IFnCMASK: CLRINTPND Mask */
S  
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN IFnCMASK: TXRQSTNEWDAT Position */
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)    /*!< CAN IFnCMASK: TXRQSTNEWDAT Mask     */
S
S#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN IFnCMASK: DATAA Position */
S#define CAN_IF_CMASK_DATAA_Msk     (1ul << CAN_IF_CMASK_DATAA_Pos)      /*!< CAN IFnCMASK: DATAA Mask     */
S
S#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN IFnCMASK: DATAB Position */
S#define CAN_IF_CMASK_DATAB_Msk     (1ul << CAN_IF_CMASK_DATAB_Pos)      /*!< CAN IFnCMASK: DATAB Mask     */
S
S/* CAN IFn_MASK1 Bit Field Definitions */
S#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN IFnMASK1: MSK Position   */
S#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN IFnMASK1: MSK Mask       */
S
S/* CAN IFn_MASK2 Bit Field Definitions */
S#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN IFnMASK2: MXTD Position */
S#define CAN_IF_MASK2_MXTD_Msk      (1ul << CAN_IF_MASK2_MXTD_Pos)       /*!< CAN IFnMASK2: MXTD Mask     */
S
S#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN IFnMASK2: MDIR Position */
S#define CAN_IF_MASK2_MDIR_Msk      (1ul << CAN_IF_MASK2_MDIR_Pos)       /*!< CAN IFnMASK2: MDIR Mask     */
S
S#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN IFnMASK2: MSK Position */
S#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN IFnMASK2: MSK Mask     */
S
S/* CAN IFn_ARB1 Bit Field Definitions */
S#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN IFnARB1: ID Position   */
S#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN IFnARB1: ID Mask       */
S
S/* CAN IFn_ARB2 Bit Field Definitions */        
S#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN IFnARB2: MSGVAL Position */
S#define CAN_IF_ARB2_MSGVAL_Msk     (1ul << CAN_IF_ARB2_MSGVAL_Pos)      /*!< CAN IFnARB2: MSGVAL Mask     */
S
S#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN IFnARB2: XTD Position    */
S#define CAN_IF_ARB2_XTD_Msk        (1ul << CAN_IF_ARB2_XTD_Pos)         /*!< CAN IFnARB2: XTD Mask        */
S
S#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN IFnARB2: DIR Position    */
S#define CAN_IF_ARB2_DIR_Msk        (1ul << CAN_IF_ARB2_DIR_Pos)         /*!< CAN IFnARB2: DIR Mask        */
S
S#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN IFnARB2: ID Position     */
S#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN IFnARB2: ID Mask         */
S
S/* CAN IFn_MCON Bit Field Definitions */
S#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN IFnMCON: NEWDAT Position */ 
S#define CAN_IF_MCON_NEWDAT_Msk     (1ul << CAN_IF_MCON_NEWDAT_Pos)      /*!< CAN IFnMCON: NEWDAT Mask     */ 
S
S#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN IFnMCON: MSGLST Position */ 
S#define CAN_IF_MCON_MSGLST_Msk     (1ul << CAN_IF_MCON_MSGLST_Pos)      /*!< CAN IFnMCON: MSGLST Mask     */ 
S
S#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN IFnMCON: INTPND Position */ 
S#define CAN_IF_MCON_INTPND_Msk     (1ul << CAN_IF_MCON_INTPND_Pos)      /*!< CAN IFnMCON: INTPND Mask     */ 
S
S#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN IFnMCON: UMASK Position  */ 
S#define CAN_IF_MCON_UMASK_Msk      (1ul << CAN_IF_MCON_UMASK_Pos)       /*!< CAN IFnMCON: UMASK Mask      */ 
S
S#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN IFnMCON: TXIE Position   */ 
S#define CAN_IF_MCON_TXIE_Msk       (1ul << CAN_IF_MCON_TXIE_Pos)        /*!< CAN IFnMCON: TXIE Mask       */ 
S
S#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN IFnMCON: RXIE Position   */ 
S#define CAN_IF_MCON_RXIE_Msk       (1ul << CAN_IF_MCON_RXIE_Pos)        /*!< CAN IFnMCON: RXIE Mask       */ 
S
S#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN IFnMCON: RMTEN Position  */ 
S#define CAN_IF_MCON_RMTEN_Msk      (1ul << CAN_IF_MCON_RMTEN_Pos)       /*!< CAN IFnMCON: RMTEN Mask      */ 
S
S#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN IFnMCON: TXRQST Position */ 
S#define CAN_IF_MCON_TXRQST_Msk     (1ul << CAN_IF_MCON_TXRQST_Pos)      /*!< CAN IFnMCON: TXRQST Mask     */ 
S
S#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN IFnMCON: EOB Position    */ 
S#define CAN_IF_MCON_EOB_Msk        (1ul << CAN_IF_MCON_EOB_Pos)         /*!< CAN IFnMCON: EOB Mask        */ 
S
S#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN IFnMCON: DLC Position    */ 
S#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN IFnMCON: DLC Mask        */ 
S
S/* CAN IFn_DATA_A1 Bit Field Definitions */
S#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN IFnDATAA1: DATA1 Position */ 
S#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN IFnDATAA1: DATA1 Mask     */ 
S
S#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN IFnDATAA1: DATA0 Position */ 
S#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN IFnDATAA1: DATA0 Mask     */ 
S
S/* CAN IFn_DATA_A2 Bit Field Definitions */ 
S#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN IFnDATAA1: DATA3 Position */ 
S#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN IFnDATAA1: DATA3 Mask     */ 
S
S#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN IFnDATAA1: DATA2 Position */ 
S#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN IFnDATAA1: DATA2 Mask     */ 
S
S/* CAN IFn_DATA_B1 Bit Field Definitions */
S#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN IFnDATAB1: DATA5 Position */ 
S#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN IFnDATAB1: DATA5 Mask */ 
S
S#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN IFnDATAB1: DATA4 Position */ 
S#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN IFnDATAB1: DATA4 Mask */ 
S
S/* CAN IFn_DATA_B2 Bit Field Definitions */
S#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN IFnDATAB2: DATA7 Position */ 
S#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN IFnDATAB2: DATA7 Mask     */ 
S
S#define CAN_IF_DAT_B2_DATA6_Pos    8                                    /*!< CAN IFnDATAB2: DATA6 Position */ 
S#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN IFnDATAB2: DATA6 Mask     */ 
S
S/* CAN IFn_TXRQST1 Bit Field Definitions */
S#define CAN_IF_TXRQST1_TXRQST_Pos  0                                        /*!< CAN IFnTXRQST1: TXRQST Position */ 
S#define CAN_IF_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST1_TXRQST_Pos)  /*!< CAN IFnTXRQST1: TXRQST Mask     */ 
S
S/* CAN IFn_TXRQST2 Bit Field Definitions */
S#define CAN_IF_TXRQST2_TXRQST_Pos  0                                        /*!< CAN IFnTXRQST2: TXRQST Position  */ 
S#define CAN_IF_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST2_TXRQST_Pos)  /*!< CAN IFnTXRQST2: TXRQST Mask      */ 
S
S/* CAN IFn_NDAT1 Bit Field Definitions */
S#define CAN_IF_NDAT1_NEWDATA_Pos   0                                        /*!< CAN IFnNDAT1: NEWDATA Position */ 
S#define CAN_IF_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT1_NEWDATA_Pos)   /*!< CAN IFnNDAT1: NEWDATA Mask     */ 
S
S/* CAN IFn_NDAT2 Bit Field Definitions */
S#define CAN_IF_NDAT2_NEWDATA_Pos   0                                        /*!< CAN IFnNDAT2: NEWDATA Position */ 
S#define CAN_IF_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT2_NEWDATA_Pos)   /*!< CAN IFnNDAT2: NEWDATA Mask     */ 
S
S/* CAN IFn_IPND1 Bit Field Definitions */
S#define CAN_IF_IPND1_INTPND_Pos   0                                         /*!< CAN IFnIPND1: INTPND Position */ 
S#define CAN_IF_IPND1_INTPND_Msk   (0xFFFFul << CAN_IF_IPND1_INTPND_Pos)     /*!< CAN IFnIPND1: INTPND Mask     */ 
S
S/* CAN IFn_IPND2 Bit Field Definitions */
S#define CAN_IF_IPND2_INTPND_Pos   0                                         /*!< CAN IFnIPND2: INTPND Position */ 
S#define CAN_IF_IPND2_INTPND_Msk   (0xFFFFul << CAN_IF_IPND2_INTPND_Pos)     /*!< CAN IFnIPND2: INTPND Mask     */
S
S/* CAN IFn_MVLD1 Bit Field Definitions */
S#define CAN_IF_MVLD1_MSGVAL_Pos   0                                         /*!< CAN IFnMVLD1: MSGVAL Position */
S#define CAN_IF_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD1_MSGVAL_Pos)     /*!< CAN IFnMVLD1: MSGVAL Mask     */
S
S/* CAN IFn_MVLD2 Bit Field Definitions */
S#define CAN_IF_MVLD2_MSGVAL_Pos   0                                         /*!< CAN IFnMVLD2: MSGVAL Position */        
S#define CAN_IF_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD2_MSGVAL_Pos)     /*!< CAN IFnMVLD2: MSGVAL Mask     */
S
S/* CAN WUEN Bit Field Definitions */
S#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN WUEN: WAKUP_EN Position */
S#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)             /*!< CAN WUEN: WAKUP_EN Mask     */
S
S/* CAN WUSTATUS Bit Field Definitions */
S#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                    /*!< CAN WUSTATUS: WAKUP_STS Position */
S#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN WUSTATUS: WAKUP_STS Mask     */
S/*@}*/ /* end of group NUC200_CAN */                                  
S
S/*--------------------------- USB Device Controller --------------------------*/
S/** @addtogroup NUC200_USBD NUC200 USBD
S  Memory Mapped Structure for NUC200 Series USB Device Controller
S  @{
S */
S
Stypedef struct
S{
S        __IO uint32_t BUFSEG;   /*!< Endpoint Buffer Segmentation Register   */
S        
S        __IO uint32_t MXPLD;    /*!< Endpoint Maximal Payload Register   */
S        
S        __IO uint32_t CFG;      /*!< Endpoint Configuration Register   */
S        
S        __IO uint32_t CFGP;     /*!< Endpoint Set Stall and Clear In/Out Ready Control Register */
S    
S} USBD_EP_T;
S
Stypedef struct
S{
S        __IO uint32_t INTEN;      /*!< Offset: 0x00  USB Interrupt Enable Register   */
S        
S        __IO uint32_t INTSTS;     /*!< Offset: 0x04  USB Interrupt Event Status Register   */
S        
S        __IO uint32_t FADDR;      /*!< Offset: 0x08  USB Device Function Address Register   */
S        
S        __I  uint32_t EPSTS;      /*!< Offset: 0x0C  USB Endpoint Status Register   */
S        
S        __IO uint32_t ATTR;       /*!< Offset: 0x10  USB Bus Status and Attribution Register   */
S        
S        __I  uint32_t FLDET;      /*!< Offset: 0x14  USB Floating Detected Register   */
S        
S        __IO uint32_t STBUFSEG;   /*!< Offset: 0x18  Setup Token Buffer Segmentation Register   */
S    
S        __I  uint32_t RESERVE0;
S    
S        USBD_EP_T EP[6];          /*!< Offset: 0x20  Endpoint Related Configuration Registers   */
S    
S        __I  uint32_t RESERVE1[4];
S    
S        __IO uint32_t DRVSE0;     /*!< Offset: 0x90  USB Driver SE0 Control Register   */
S        
S} USBD_T;
S
S/* USBD INTEN Bit Field Definitions */
S#define USBD_INTEN_INNAK_EN_Pos    15                                    /*!< USB INTEN: INNAK_EN Position */
S#define USBD_INTEN_INNAK_EN_Msk    (1ul << USBD_INTEN_INNAK_EN_Pos)      /*!< USB INTEN: INNAK_EN Mask */
S
S#define USBD_INTEN_WAKEUP_EN_Pos   8                                     /*!< USB INTEN: WAKEUP_EN Position */
S#define USBD_INTEN_WAKEUP_EN_Msk   (1ul << USBD_INTEN_WAKEUP_EN_Pos)     /*!< USB INTEN: WAKEUP_EN Mask */
S
S#define USBD_INTEN_WAKEUP_IE_Pos   3                                     /*!< USB INTEN: WAKEUP_IE Position */
S#define USBD_INTEN_WAKEUP_IE_Msk   (1ul << USBD_INTEN_WAKEUP_IE_Pos)     /*!< USB INTEN: WAKEUP_IE Mask */
S
S#define USBD_INTEN_FLDET_IE_Pos    2                                     /*!< USB INTEN: FLDET_IE Position */
S#define USBD_INTEN_FLDET_IE_Msk    (1ul << USBD_INTEN_FLDET_IE_Pos)      /*!< USB INTEN: FLDET_IE Mask */
S
S#define USBD_INTEN_USB_IE_Pos      1                                     /*!< USB INTEN: USB_IE Position */
S#define USBD_INTEN_USB_IE_Msk      (1ul << USBD_INTEN_USB_IE_Pos)        /*!< USB INTEN: USB_IE Mask */
S
S#define USBD_INTEN_BUS_IE_Pos      0                                     /*!< USB INTEN: BUS_IE Position */
S#define USBD_INTEN_BUS_IE_Msk      (1ul << USBD_INTEN_BUS_IE_Pos)        /*!< USB INTEN: BUS_IE Mask */
S
S/* USBD INTSTS Bit Field Definitions */
S#define USBD_INTSTS_SETUP_Pos        31                                  /*!< USB INTSTS: SETUP Position */
S#define USBD_INTSTS_SETUP_Msk        (1ul << USBD_INTSTS_SETUP_Pos)      /*!< USB INTSTS: SETUP Mask */
S
S#define USBD_INTSTS_EPEVT_Pos        16                                  /*!< USB INTSTS: EPEVT Position */
S#define USBD_INTSTS_EPEVT_Msk        (0x3Ful << USBD_INTSTS_EPEVT_Pos)   /*!< USB INTSTS: EPEVT Mask */
S
S#define USBD_INTSTS_WAKEUP_STS_Pos   3                                   /*!< USB INTSTS: WAKEUP_STS Position */
S#define USBD_INTSTS_WAKEUP_STS_Msk   (1ul << USBD_INTSTS_WAKEUP_STS_Pos) /*!< USB INTSTS: WAKEUP_STS Mask */
S
S#define USBD_INTSTS_FLDET_STS_Pos    2                                   /*!< USB INTSTS: FLDET_STS Position */
S#define USBD_INTSTS_FLDET_STS_Msk    (1ul << USBD_INTSTS_FLDET_STS_Pos)  /*!< USB INTSTS: FLDET_STS Mask */
S
S#define USBD_INTSTS_USB_STS_Pos      1                                   /*!< USB INTSTS: USB_STS Position */
S#define USBD_INTSTS_USB_STS_Msk      (1ul << USBD_INTSTS_USB_STS_Pos)    /*!< USB INTSTS: USB_STS Mask */
S
S#define USBD_INTSTS_BUS_STS_Pos      0                                   /*!< USB INTSTS: BUS_STS Position */
S#define USBD_INTSTS_BUS_STS_Msk      (1ul << USBD_INTSTS_BUS_STS_Pos)    /*!< USB INTSTS: BUS_STS Mask */
S
S/* USBD FADDR Bit Field Definitions */
S#define USBD_FADDR_FADDR_Pos     0                                       /*!< USB FADDR: FADDR Position */
S#define USBD_FADDR_FADDR_Msk     (0x7Ful << USBD_FADDR_FADDR_Pos)        /*!< USB FADDR: FADDR Mask */
S
S/* USBD EPSTS Bit Field Definitions */
S#define USBD_EPSTS_EPSTS5_Pos    23                                      /*!< USB EPSTS: EPSTS5 Position */
S#define USBD_EPSTS_EPSTS5_Msk    (7ul << USBD_EPSTS_EPSTS5_Pos)          /*!< USB EPSTS: EPSTS5 Mask */
S
S#define USBD_EPSTS_EPSTS4_Pos    20                                      /*!< USB EPSTS: EPSTS4 Position */
S#define USBD_EPSTS_EPSTS4_Msk    (7ul << USBD_EPSTS_EPSTS4_Pos)          /*!< USB EPSTS: EPSTS5 Mask */
S
S#define USBD_EPSTS_EPSTS3_Pos    17                                      /*!< USB EPSTS: EPSTS3 Position */
S#define USBD_EPSTS_EPSTS3_Msk    (7ul << USBD_EPSTS_EPSTS3_Pos)          /*!< USB EPSTS: EPSTS3 Mask */
S
S#define USBD_EPSTS_EPSTS2_Pos    14                                      /*!< USB EPSTS: EPSTS2 Position */
S#define USBD_EPSTS_EPSTS2_Msk    (7ul << USBD_EPSTS_EPSTS2_Pos)          /*!< USB EPSTS: EPSTS2 Mask */
S
S#define USBD_EPSTS_EPSTS1_Pos    11                                      /*!< USB EPSTS: EPSTS1 Position */
S#define USBD_EPSTS_EPSTS1_Msk    (7ul << USBD_EPSTS_EPSTS1_Pos)          /*!< USB EPSTS: EPSTS1 Mask */
S
S#define USBD_EPSTS_EPSTS0_Pos    8                                       /*!< USB EPSTS: EPSTS0 Position */
S#define USBD_EPSTS_EPSTS0_Msk    (7ul << USBD_EPSTS_EPSTS0_Pos)          /*!< USB EPSTS: EPSTS0 Mask */
S
S#define USBD_EPSTS_OVERRUN_Pos   7                                       /*!< USB EPSTS: OVERRUN Position */
S#define USBD_EPSTS_OVERRUN_Msk   (1ul << USBD_EPSTS_OVERRUN_Pos)         /*!< USB EPSTS: OVERRUN Mask */
S
S/* USBD ATTR Bit Field Definitions */
S#define USBD_ATTR_PWRDN_Pos      9                                       /*!< USB ATTR: PWRDN Position */
S#define USBD_ATTR_PWRDN_Msk      (1ul << USBD_ATTR_PWRDN_Pos)            /*!< USB ATTR: PWRDN Mask */
S
S#define USBD_ATTR_DPPU_EN_Pos    8                                       /*!< USB ATTR: DPPU_EN Position */
S#define USBD_ATTR_DPPU_EN_Msk    (1ul << USBD_ATTR_DPPU_EN_Pos)          /*!< USB ATTR: DPPU_EN Mask */
S
S#define USBD_ATTR_USB_EN_Pos     7                                       /*!< USB ATTR: USB_EN Position */
S#define USBD_ATTR_USB_EN_Msk     (1ul << USBD_ATTR_USB_EN_Pos)           /*!< USB ATTR: USB_EN Mask */
S
S#define USBD_ATTR_RWAKEUP_Pos    5                                       /*!< USB ATTR: RWAKEUP Position */
S#define USBD_ATTR_RWAKEUP_Msk    (1ul << USBD_ATTR_RWAKEUP_Pos)          /*!< USB ATTR: RWAKEUP Mask */
S
S#define USBD_ATTR_PHY_EN_Pos     4                                       /*!< USB ATTR: PHY_EN Position */
S#define USBD_ATTR_PHY_EN_Msk     (1ul << USBD_ATTR_PHY_EN_Pos)           /*!< USB ATTR: PHY_EN Mask */
S
S#define USBD_ATTR_TIMEOUT_Pos    3                                       /*!< USB ATTR: TIMEOUT Position */
S#define USBD_ATTR_TIMEOUT_Msk    (1ul << USBD_ATTR_TIMEOUT_Pos)          /*!< USB ATTR: TIMEOUT Mask */
S
S#define USBD_ATTR_RESUME_Pos     2                                       /*!< USB ATTR: RESUME Position */
S#define USBD_ATTR_RESUME_Msk     (1ul << USBD_ATTR_RESUME_Pos)           /*!< USB ATTR: RESUME Mask */
S
S#define USBD_ATTR_SUSPEND_Pos    1                                       /*!< USB ATTR: SUSPEND Position */
S#define USBD_ATTR_SUSPEND_Msk    (1ul << USBD_ATTR_SUSPEND_Pos)          /*!< USB ATTR: SUSPEND Mask */
S
S#define USBD_ATTR_USBRST_Pos     0                                       /*!< USB ATTR: USBRST Position */
S#define USBD_ATTR_USBRST_Msk     (1ul << USBD_ATTR_USBRST_Pos)           /*!< USB ATTR: USBRST Mask */
S
S/* USBD FLDET Bit Field Definitions */
S#define USBD_FLDET_FLDET_Pos     0                                       /*!< USB FLDET: FLDET Position */
S#define USBD_FLDET_FLDET_Msk     (1ul << USBD_FLDET_FLDET_Pos)           /*!< USB FLDET: FLDET Mask */
S
S/* USBD STBUFSEG Bit Field Definitions */
S#define USBD_STBUFSEG_STBUFSEG_Pos   3                                        /*!< USB STBUFSEG: STBUFSEG Position */
S#define USBD_STBUFSEG_STBUFSEG_Msk   (0x3Ful << USBD_STBUFSEG_STBUFSEG_Pos)   /*!< USB STBUFSEG: STBUFSEG Mask */
S
S/* USBD BUFSEG Bit Field Definitions */
S#define USBD_BUFSEG_BUFSEG_Pos   3                                       /*!< USB BUFSEG: BUFSEG Position */
S#define USBD_BUFSEG_BUFSEG_Msk   (0x3Ful << USBD_BUFSEG_BUFSEG_Pos)      /*!< USB BUFSEG: BUFSEG Mask */
S
S/* USBD MXPLD Bit Field Definitions */
S#define USBD_MXPLD_MXPLD_Pos    0                                        /*!< USB MXPLD: MXPLD Position */
S#define USBD_MXPLD_MXPLD_Msk    (0x1FFul << USBD_MXPLD_MXPLD_Pos)        /*!< USB MXPLD: MXPLD Mask */
S
S/* USBD CFG Bit Field Definitions */
S#define USBD_CFG_CSTALL_Pos     9                                        /*!< USB CFG: CSTALL Position */
S#define USBD_CFG_CSTALL_Msk     (1ul << USBD_CFG_CSTALL_Pos)             /*!< USB CFG: CSTALL Mask */
S
S#define USBD_CFG_DSQ_SYNC_Pos   7                                        /*!< USB CFG: DSQ_SYNC Position */
S#define USBD_CFG_DSQ_SYNC_Msk   (1ul << USBD_CFG_DSQ_SYNC_Pos)           /*!< USB CFG: DSQ_SYNC Mask */
S
S#define USBD_CFG_STATE_Pos      5                                        /*!< USB CFG: STATE Position */
S#define USBD_CFG_STATE_Msk      (3ul << USBD_CFG_STATE_Pos)              /*!< USB CFG: STATE Mask */
S
S#define USBD_CFG_ISOCH_Pos      4                                        /*!< USB CFG: ISOCH Position */
S#define USBD_CFG_ISOCH_Msk      (1ul << USBD_CFG_ISOCH_Pos)              /*!< USB CFG: ISOCH Mask */
S
S#define USBD_CFG_EP_NUM_Pos     0                                        /*!< USB CFG: EP_NUM Position */
S#define USBD_CFG_EP_NUM_Msk     (0xFul << USBD_CFG_EP_NUM_Pos)           /*!< USB CFG: EP_NUM Mask */
S
S/* USBD CFGP Bit Field Definitions */
S#define USBD_CFGP_SSTALL_Pos    1                                        /*!< USB CFGP: SSTALL Position */
S#define USBD_CFGP_SSTALL_Msk    (1ul << USBD_CFGP_SSTALL_Pos)            /*!< USB CFGP: SSTALL Mask */
S
S#define USBD_CFGP_CLRRDY_Pos    0                                        /*!< USB CFGP: CLRRDY Position */
S#define USBD_CFGP_CLRRDY_Msk    (1ul << USBD_CFGP_CLRRDY_Pos)            /*!< USB CFGP: CLRRDY Mask */
S
S/* USBD DRVSE0 Bit Field Definitions */
S#define USBD_DRVSE0_DRVSE0_Pos   0                                       /*!< USB DRVSE0: DRVSE0 Position */
S#define USBD_DRVSE0_DRVSE0_Msk   (1ul << USBD_DRVSE0_DRVSE0_Pos)         /*!< USB DRVSE0: DRVSE0 Mask */
S
S/*@}*/ /* end of group NUC200_USBD */
S
S
S/*------------------------------ DMA Controller -----------------------------*/
S/** @addtogroup NUC200_PWM NUC200 PWM
S  Memory Mapped Structure for NUC200 Series DMA Controller 
S  @{
S */
Stypedef struct
S{
S    __IO uint32_t CSR;
S    __IO uint32_t SAR;
S    __IO uint32_t DAR;
S    __IO uint32_t BCR;
S    __I  uint32_t POINT;
S    __I  uint32_t CSAR;
S    __I  uint32_t CDAR;
S    __I  uint32_t CBCR;
S    __IO uint32_t IER;
S    __IO uint32_t ISR;
S    __I  uint32_t RESERVE[22];
S    __I  uint32_t SBUF;
S} PDMA_T;
S
Stypedef struct
S{
S    __IO uint32_t GCRCSR;
S    __IO uint32_t PDSSR0;
S    __IO uint32_t PDSSR1;
S    __IO uint32_t GCRISR;
S    __IO uint32_t PDSSR2;
S} PDMA_GCR_T;
S
S
S/* PDMA CSR Bit Field Definitions */
S#define PDMA_CSR_TRIG_EN_Pos                        23                              /*!< PDMA CSR: TRIG_EN Position */
S#define PDMA_CSR_TRIG_EN_Msk                        (1ul << PDMA_CSR_TRIG_EN_Pos)   /*!< PDMA CSR: TRIG_EN Mask */
S
S#define PDMA_CSR_APB_TWS_Pos                        19                              /*!< PDMA CSR: APB_TWS Position */
S#define PDMA_CSR_APB_TWS_Msk                        (3ul << PDMA_CSR_APB_TWS_Pos)   /*!< PDMA CSR: APB_TWS Mask */
S
S#define PDMA_CSR_DAD_SEL_Pos                        6                               /*!< PDMA CSR: DAD_SEL Position */
S#define PDMA_CSR_DAD_SEL_Msk                        (3ul << PDMA_CSR_DAD_SEL_Pos)   /*!< PDMA CSR: DAD_SEL Mask */
S
S#define PDMA_CSR_SAD_SEL_Pos                        4                               /*!< PDMA CSR: SAD_SEL Position */
S#define PDMA_CSR_SAD_SEL_Msk                        (3ul << PDMA_CSR_SAD_SEL_Pos)   /*!< PDMA CSR: SAD_SEL Mask */
S
S#define PDMA_CSR_MODE_SEL_Pos                       2                               /*!< PDMA CSR: MODE_SEL Position */
S#define PDMA_CSR_MODE_SEL_Msk                       (3ul << PDMA_CSR_MODE_SEL_Pos)  /*!< PDMA CSR: MODE_SEL Mask */
S
S#define PDMA_CSR_SW_RST_Pos                         1                               /*!< PDMA CSR: SW_RST Position */
S#define PDMA_CSR_SW_RST_Msk                         (1ul << PDMA_CSR_SW_RST_Pos)    /*!< PDMA CSR: SW_RST Mask */
S
S#define PDMA_CSR_PDMACEN_Pos                        0                               /*!< PDMA CSR: PDMACEN Position */
S#define PDMA_CSR_PDMACEN_Msk                        (1ul << PDMA_CSR_PDMACEN_Pos)   /*!< PDMA CSR: PDMACEN Mask */
S
S/* PDMA BCR Bit Field Definitions */
S#define PDMA_BCR_BCR_Pos                            0                               /*!< PDMA BCR: BCR Position */
S#define PDMA_BCR_BCR_Msk                            (0xFFFFul << PDMA_BCR_BCR_Pos)  /*!< PDMA BCR: BCR Mask */
S
S/* PDMA POINT Bit Field Definitions */
S#define PDMA_POINT_POINT_Pos                        0                               /*!< PDMA POINT: POINT Position */
S#define PDMA_POINT_POINT_Msk                        (0xFul << PDMA_POINT_POINT_Pos) /*!< PDMA POINT: POINT Mask */
S
S/* PDMA CBCR Bit Field Definitions */
S#define PDMA_CBCR_CBCR_Pos                          0                                   /*!< PDMA CBCR: CBCR Position */
S#define PDMA_CBCR_CBCR_Msk                          (0xFFFFul << PDMA_CBCR_CBCR_Pos)    /*!< PDMA CBCR: CBCR Mask */
S
S
S/* PDMA IER Bit Field Definitions */
S#define PDMA_IER_BLKD_IE_Pos                        1                               /*!< PDMA IER: BLKD_IE Position */
S#define PDMA_IER_BLKD_IE_Msk                        (1ul << PDMA_IER_BLKD_IE_Pos)   /*!< PDMA IER: BLKD_IE Mask */
S
S#define PDMA_IER_TABORT_IE_Pos                      0                               /*!< PDMA IER: TABORT_IE Position */
S#define PDMA_IER_TABORT_IE_Msk                      (1ul << PDMA_IER_TABORT_IE_Pos) /*!< PDMA IER: TABORT_IE Mask */
S
S/* PDMA ISR Bit Field Definitions */
S#define PDMA_ISR_BLKD_IF_Pos                        1                               /*!< PDMA ISR: BLKD_IF Position */
S#define PDMA_ISR_BLKD_IF_Msk                        (1ul << PDMA_ISR_BLKD_IF_Pos)   /*!< PDMA ISR: BLKD_IF Mask */
S
S#define PDMA_ISR_TABORT_IF_Pos                      0                               /*!< PDMA ISR: TABORT_IF Position */
S#define PDMA_ISR_TABORT_IF_Msk                      (1ul << PDMA_ISR_TABORT_IF_Pos) /*!< PDMA ISR: TABORT_IF Mask */
S
S/* PDMA GCRCSR Bit Field Definitions */
S#define PDMA_GCRCSR_CRC_CLK_EN_Pos                  24                                  /*!< PDMA GCRCSR: CRC_CLK_EN Position */
S#define PDMA_GCRCSR_CRC_CLK_EN_Msk                  (1ul << PDMA_GCRCSR_CRC_CLK_EN_Pos) /*!< PDMA GCRCSR: CRC_CLK_EN Mask */
S
S#define PDMA_GCRCSR_CLK8_EN_Pos                     16                                  /*!< PDMA GCRCSR: CLK8_EN Position */
S#define PDMA_GCRCSR_CLK8_EN_Msk                     (1ul << PDMA_GCRCSR_CLK8_EN_Pos)    /*!< PDMA GCRCSR: CLK8_EN Mask */
S
S#define PDMA_GCRCSR_CLK7_EN_Pos                     15                                  /*!< PDMA GCRCSR: CLK7_EN Position */
S#define PDMA_GCRCSR_CLK7_EN_Msk                     (1ul << PDMA_GCRCSR_CLK7_EN_Pos)    /*!< PDMA GCRCSR: CLK7_EN Mask */
S
S#define PDMA_GCRCSR_CLK6_EN_Pos                     14                                  /*!< PDMA GCRCSR: CLK6_EN Position */
S#define PDMA_GCRCSR_CLK6_EN_Msk                     (1ul << PDMA_GCRCSR_CLK6_EN_Pos)    /*!< PDMA GCRCSR: CLK6_EN Mask */
S
S#define PDMA_GCRCSR_CLK5_EN_Pos                     13                                  /*!< PDMA GCRCSR: CLK5_EN Position */
S#define PDMA_GCRCSR_CLK5_EN_Msk                     (1ul << PDMA_GCRCSR_CLK5_EN_Pos)    /*!< PDMA GCRCSR: CLK5_EN Mask */
S
S#define PDMA_GCRCSR_CLK4_EN_Pos                     12                                  /*!< PDMA GCRCSR: CLK4_EN Position */
S#define PDMA_GCRCSR_CLK4_EN_Msk                     (1ul << PDMA_GCRCSR_CLK4_EN_Pos)    /*!< PDMA GCRCSR: CLK4_EN Mask */
S
S#define PDMA_GCRCSR_CLK3_EN_Pos                     11                                  /*!< PDMA GCRCSR: CLK3_EN Position */
S#define PDMA_GCRCSR_CLK3_EN_Msk                     (1ul << PDMA_GCRCSR_CLK3_EN_Pos)    /*!< PDMA GCRCSR: CLK3_EN Mask */
S
S#define PDMA_GCRCSR_CLK2_EN_Pos                     10                                  /*!< PDMA GCRCSR: CLK2_EN Position */
S#define PDMA_GCRCSR_CLK2_EN_Msk                     (1ul << PDMA_GCRCSR_CLK2_EN_Pos)    /*!< PDMA GCRCSR: CLK2_EN Mask */
S
S#define PDMA_GCRCSR_CLK1_EN_Pos                     9                                   /*!< PDMA GCRCSR: CLK1_EN Position */
S#define PDMA_GCRCSR_CLK1_EN_Msk                     (1ul << PDMA_GCRCSR_CLK1_EN_Pos)    /*!< PDMA GCRCSR: CLK1_EN Mask */
S
S#define PDMA_GCRCSR_CLK0_EN_Pos                     8                                   /*!< PDMA GCRCSR: CLK0_EN Position */
S#define PDMA_GCRCSR_CLK0_EN_Msk                     (1ul << PDMA_GCRCSR_CLK0_EN_Pos)    /*!< PDMA GCRCSR: CLK0_EN Mask */
S
S/* PDMA PDSSR0 Bit Field Definitions */
S#define PDMA_PDSSR0_SPI3_TXSEL_Pos                  28                                      /*!< PDMA PDSSR0: SPI3_TXSEL Position */
S#define PDMA_PDSSR0_SPI3_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI3_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI3_RXSEL_Pos                  24                                      /*!< PDMA PDSSR0: SPI3_RXSEL Position */
S#define PDMA_PDSSR0_SPI3_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI3_RXSEL Mask */
S
S#define PDMA_PDSSR0_SPI2_TXSEL_Pos                  20                                      /*!< PDMA PDSSR0: SPI2_TXSEL Position */
S#define PDMA_PDSSR0_SPI2_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI2_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI2_RXSEL_Pos                  16                                      /*!< PDMA PDSSR0: SPI2_RXSEL Position */
S#define PDMA_PDSSR0_SPI2_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI2_RXSEL Mask */
S
S#define PDMA_PDSSR0_SPI1_TXSEL_Pos                  12                                      /*!< PDMA PDSSR0: SPI1_TXSEL Position */
S#define PDMA_PDSSR0_SPI1_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI1_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI1_RXSEL_Pos                  8                                       /*!< PDMA PDSSR0: SPI1_RXSEL Position */
S#define PDMA_PDSSR0_SPI1_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI1_RXSEL Mask */
S
S#define PDMA_PDSSR0_SPI0_TXSEL_Pos                  4                                       /*!< PDMA PDSSR0: SPI0_TXSEL Position */
S#define PDMA_PDSSR0_SPI0_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_TXSEL_Pos)   /*!< PDMA PDSSR0: SPI0_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI0_RXSEL_Pos                  0                                       /*!< PDMA PDSSR0: SPI0_RXSEL Position */
S#define PDMA_PDSSR0_SPI0_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_RXSEL_Pos)   /*!< PDMA PDSSR0: SPI0_RXSEL Mask */
S
S/* PDMA PDSSR1 Bit Field Definitions */
S#define PDMA_PDSSR1_ADC_RXSEL_Pos                   24                                      /*!< PDMA PDSSR1: ADC_RXSEL Position */
S#define PDMA_PDSSR1_ADC_RXSEL_Msk                   (0xFul << PDMA_PDSSR1_ADC_RXSEL_Pos)    /*!< PDMA PDSSR1: ADC_RXSEL Mask */
S
S#define PDMA_PDSSR1_UART1_TXSEL_Pos                 12                                      /*!< PDMA PDSSR1: UART1_TXSEL Position */
S#define PDMA_PDSSR1_UART1_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_TXSEL_Pos)  /*!< PDMA PDSSR1: UART1_TXSEL Mask */
S
S#define PDMA_PDSSR1_UART1_RXSEL_Pos                 8                                       /*!< PDMA PDSSR1: UART1_RXSEL Position */
S#define PDMA_PDSSR1_UART1_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_RXSEL_Pos)  /*!< PDMA PDSSR1: UART1_RXSEL Mask */
S
S#define PDMA_PDSSR1_UART0_TXSEL_Pos                 4                                       /*!< PDMA PDSSR1: UART0_TXSEL Position */
S#define PDMA_PDSSR1_UART0_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_TXSEL_Pos)  /*!< PDMA PDSSR1: UART0_TXSEL Mask */
S
S#define PDMA_PDSSR1_UART0_RXSEL_Pos                 0                                       /*!< PDMA PDSSR1: UART0_RXSEL Position */
S#define PDMA_PDSSR1_UART0_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_RXSEL_Pos)  /*!< PDMA PDSSR1: UART0_RXSEL Mask */
S
S/* PDMA GCRISR Bit Field Definitions */
S#define PDMA_GCRISR_INTR_Pos                        31                              /*!< PDMA GCRISR: INTR Position */
S#define PDMA_GCRISR_INTR_Msk                        (1ul << PDMA_GCRISR_INTR_Pos)   /*!< PDMA GCRISR: INTR Mask */
S
S#define PDMA_GCRISR_INTRCRC_Pos                     16                               /*!< PDMA GCRISR: INTRCRC Position */
S#define PDMA_GCRISR_INTRCRC_Msk                     (1ul << PDMA_GCRISR_INTRCRC_Pos) /*!< PDMA GCRISR: INTRCRC Mask */
S
S#define PDMA_GCRISR_INTR8_Pos                       8                               /*!< PDMA GCRISR: INTR8 Position */
S#define PDMA_GCRISR_INTR8_Msk                       (1ul << PDMA_GCRISR_INTR8_Pos)  /*!< PDMA GCRISR: INTR8 Mask */
S
S#define PDMA_GCRISR_INTR7_Pos                       7                               /*!< PDMA GCRISR: INTR7 Position */
S#define PDMA_GCRISR_INTR7_Msk                       (1ul << PDMA_GCRISR_INTR7_Pos)  /*!< PDMA GCRISR: INTR7 Mask */
S
S#define PDMA_GCRISR_INTR6_Pos                       6                               /*!< PDMA GCRISR: INTR6 Position */
S#define PDMA_GCRISR_INTR6_Msk                       (1ul << PDMA_GCRISR_INTR6_Pos)  /*!< PDMA GCRISR: INTR6 Mask */
S
S#define PDMA_GCRISR_INTR5_Pos                       5                               /*!< PDMA GCRISR: INTR5 Position */
S#define PDMA_GCRISR_INTR5_Msk                       (1ul << PDMA_GCRISR_INTR5_Pos)  /*!< PDMA GCRISR: INTR5 Mask */ 
S
S#define PDMA_GCRISR_INTR4_Pos                       4                               /*!< PDMA GCRISR: INTR4 Position */
S#define PDMA_GCRISR_INTR4_Msk                       (1ul << PDMA_GCRISR_INTR4_Pos)  /*!< PDMA GCRISR: INTR4 Mask */
S
S#define PDMA_GCRISR_INTR3_Pos                       3                               /*!< PDMA GCRISR: INTR3 Position */
S#define PDMA_GCRISR_INTR3_Msk                       (1ul << PDMA_GCRISR_INTR3_Pos)  /*!< PDMA GCRISR: INTR3 Mask */
S
S#define PDMA_GCRISR_INTR2_Pos                       2                               /*!< PDMA GCRISR: INTR2 Position */
S#define PDMA_GCRISR_INTR2_Msk                       (1ul << PDMA_GCRISR_INTR2_Pos)  /*!< PDMA GCRISR: INTR2 Mask */
S
S#define PDMA_GCRISR_INTR1_Pos                       1                               /*!< PDMA GCRISR: INTR1 Position */
S#define PDMA_GCRISR_INTR1_Msk                       (1ul << PDMA_GCRISR_INTR1_Pos)  /*!< PDMA GCRISR: INTR1 Mask */
S
S#define PDMA_GCRISR_INTR0_Pos                       0                               /*!< PDMA GCRISR: INTR0 Position */
S#define PDMA_GCRISR_INTR0_Msk                       (1ul << PDMA_GCRISR_INTR0_Pos)  /*!< PDMA GCRISR: INTR0 Mask */
S
S/* PDMA PDSSR2 Bit Field Definitions */
S#define PDMA_PDSSR2_I2S_TXSEL_Pos                   4                                       /*!< PDMA PDSSR2: I2S_TXSEL Position */
S#define PDMA_PDSSR2_I2S_TXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_TXSEL_Pos)    /*!< PDMA PDSSR2: I2S_TXSEL Mask */
S
S#define PDMA_PDSSR2_I2S_RXSEL_Pos                   0                                       /*!< PDMA PDSSR2: I2S_RXSEL Position */
S#define PDMA_PDSSR2_I2S_RXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_RXSEL_Pos)    /*!< PDMA PDSSR2: I2S_RXSEL Mask */
S/*@}*/ /* end of group NUC200_DMA */
S
S
S/*----------------------------- Cyclic Redundancy Check (CRC) Controller -----------------------------*/
S/** @addtogroup NUC200_CRC NUC200 CRC
S  Memory Mapped Structure for NUC200 Series Cyclic Redundancy Check
S  @{
S */
Stypedef struct
S{
S    /**
S     * CRC_CTL
S     * ===================================================================================================
S     * Offset: 0x00  CRC Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  CTL;
S
S    /**
S     * CRC_DMASAR 
S     * ===================================================================================================
S     * Offset: 0x04  CRC DMA Transfer Source Address Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DMASAR;
S
S    __I  uint32_t  RESERVED0;
S
S    /**
S     * CRC_DMABCR 
S     * ===================================================================================================
S     * Offset: 0x0C  CRC DMA Transfer Byte Count Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DMABCR ;
S
S    __I  uint32_t  RESERVED1;
S
S    /**
S     * CRC_DMACSAR
S     * ===================================================================================================
S     * Offset: 0x14  CRC DMA Current Source Address Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  DMACSAR;
S
S    __I  uint32_t  RESERVED2;
S
S    /**
S     * CRC_DMACBCR
S     * ===================================================================================================
S     * Offset: 0x1C  CRC DMA Current Byte Count Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  DMACBCR;
S
S    /**
S     * CRC_DMAIER 
S     * ===================================================================================================
S     * Offset: 0x20  CRC DMA Interrupt Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DMAIER ;
S
S    /**
S     * CRC_DMAISR 
S     * ===================================================================================================
S     * Offset: 0x24  CRC DMA Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  DMAISR;
S
S    __I  uint32_t  RESERVED3[22];
S
S    /**
S     * CRC_WDATA 
S     * ===================================================================================================
S     * Offset: 0x80  CRC Write Data Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  WDATA;
S
S    /**
S     * CRC_SEED 
S     * ===================================================================================================
S     * Offset: 0x84  CRC Seed Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t  SEED;
S
S    /**
S     * CRC_CHECKSUM
S     * ===================================================================================================
S     * Offset: 0x88  CRC Checksum Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I  uint32_t  CHECKSUM;
S} CRC_T;
S
S/* CRC CTL Bit Field Definitions */
S#define CRC_CTL_CRC_MODE_Pos            30                                      /*!< CRC CRC_CTL : CRC_MODE Position */
S#define CRC_CTL_CRC_MODE_Msk            (0x3ul << CRC_CTL_CRC_MODE_Pos)         /*!< CRC CRC_CTL : CRC_MODE Mask */
S
S#define CRC_CTL_CPU_WDLEN_Pos           28                                      /*!< CRC CRC_CTL : CPU_WDLEN Position */
S#define CRC_CTL_CPU_WDLEN_Msk           (0x3ul << CRC_CTL_CPU_WDLEN_Pos)        /*!< CRC CRC_CTL : CPU_WDLEN Mask */
S
S#define CRC_CTL_CHECKSUM_COM_Pos        27                                      /*!< CRC CRC_CTL : CHECKSUM_COM Position */
S#define CRC_CTL_CHECKSUM_COM_Msk        (1ul << CRC_CTL_CHECKSUM_COM_Pos)       /*!< CRC CRC_CTL : CHECKSUM_COM Mask */
S
S#define CRC_CTL_WDATA_COM_Pos           26                                      /*!< CRC CRC_CTL : WDATA_COM Position */
S#define CRC_CTL_WDATA_COM_Msk           (1ul << CRC_CTL_WDATA_COM_Pos)          /*!< CRC CRC_CTL : WDATA_COM Mask */
S
S#define CRC_CTL_CHECKSUM_RVS_Pos        25                                      /*!< CRC CRC_CTL : CHECKSUM_RVS Position */
S#define CRC_CTL_CHECKSUM_RVS_Msk        (1ul << CRC_CTL_CHECKSUM_RVS_Pos)       /*!< CRC CRC_CTL : CHECKSUM_RVS Mask */
S
S#define CRC_CTL_WDATA_RVS_Pos           24                                      /*!< CRC CRC_CTL : WDATA_RVS Position */
S#define CRC_CTL_WDATA_RVS_Msk           (1ul << CRC_CTL_WDATA_RVS_Pos)          /*!< CRC CRC_CTL : WDATA_RVS Mask */
S
S#define CRC_CTL_TRIG_EN_Pos             23                                      /*!< CRC CRC_CTL : TRIG_EN Position */
S#define CRC_CTL_TRIG_EN_Msk             (1ul << CRC_CTL_TRIG_EN_Pos)            /*!< CRC CRC_CTL : TRIG_EN Mask */
S    
S#define CRC_CTL_CRC_RST_Pos             1                                       /*!< CRC CRC_CTL : CRC_RST Position */
S#define CRC_CTL_CRC_RST_Msk             (1ul << CRC_CTL_CRC_RST_Pos)            /*!< CRC CRC_CTL : CRC_RST Mask */
S
S#define CRC_CTL_CRCCEN_Pos              0                                       /*!< CRC CRC_CTL : CRCCEN Position */
S#define CRC_CTL_CRCCEN_Msk              (1ul << CRC_CTL_CRCCEN_Pos)             /*!< CRC CRC_CTL : CRCCEN Mask */
S
S/* CRC DMASAR Bit Field Definitions */
S#define CRC_DMASAR_CRC_DMASAR_Pos       0                                               /*!< CRC CRC_DMASAR : CRC_DMASAR Position */
S#define CRC_DMASAR_CRC_DMASAR_Msk       (0xFFFFFFFFul << CRC_DMASAR_CRC_DMASAR_Pos)     /*!< CRC CRC_DMASAR : CRC_DMASAR Mask */
S
S/* CRC DMABCR Bit Field Definitions */
S#define CRC_DMABCR_CRC_DMABCR_Pos       0                                               /*!< CRC CRC_DMABCR : CRC_DMABCR Position */
S#define CRC_DMABCR_CRC_DMABCR_Msk       (0xFFFFul << CRC_DMABCR_CRC_DMABCR_Pos)         /*!< CRC CRC_DMABCR : CRC_DMABCR Mask */
S
S/* CRC DMACSAR Bit Field Definitions */
S#define CRC_DMACSAR_CRC_DMACSAR_Pos     0                                               /*!< CRC CRC_DMACSAR : CRC_DMACSAR Position */
S#define CRC_DMACSAR_CRC_DMACSAR_Msk     (0xFFFFFFFFul << CRC_DMACSAR_CRC_DMACSAR_Pos)   /*!< CRC CRC_DMACSAR : CRC_DMACSAR Mask */
S
S/* CRC DMACBCR Bit Field Definitions */
S#define CRC_DMACBCR_CRC_DMACBCR_Pos     0                                               /*!< CRC CRC_DMACBCR : DMACBCR Position */
S#define CRC_DMACBCR_CRC_DMACBCR_Msk     (0xFFFFul << CRC_DMACBCR_CRC_DMACBCR_Pos)       /*!< CRC CRC_DMACBCR : DMACBCR Mask */
S
S/* CRC DMAIER Bit Field Definitions */
S#define CRC_DMAIER_CRC_BLKD_IE_Pos      1                                               /*!< CRC CRC_DMAIER : CRC_BLKD_IE Position */
S#define CRC_DMAIER_CRC_BLKD_IE_Msk      (1ul << CRC_DMAIER_CRC_BLKD_IE_Pos)             /*!< CRC CRC_DMAIER : CRC_BLKD_IE Mask */
S
S#define CRC_DMAIER_CRC_TABORT_IE_Pos    0                                               /*!< CRC CRC_DMAIER : CRC_TABORT_IE Position */
S#define CRC_DMAIER_CRC_TABORT_IE_Msk    (1ul << CRC_DMAIER_CRC_TABORT_IE_Pos)           /*!< CRC CRC_DMAIER : CRC_TABORT_IE Mask */
S
S/* CRC DMAISR Bit Field Definitions */
S#define CRC_DMAISR_CRC_BLKD_IF_Pos      1                                               /*!< CRC CRC_DMAISR : CRC_BLKD_IF Position */
S#define CRC_DMAISR_CRC_BLKD_IF_Msk      (1ul << CRC_DMAISR_CRC_BLKD_IF_Pos)             /*!< CRC CRC_DMAISR : CRC_BLKD_IF Mask */
S
S#define CRC_DMAISR_CRC_TABORT_IF_Pos    0                                               /*!< CRC CRC_DMAISR : CRC_TABORT_IF Position */
S#define CRC_DMAISR_CRC_TABORT_IF_Msk    (1ul << CRC_DMAISR_CRC_TABORT_IF_Pos)           /*!< CRC CRC_DMAISR : CRC_TABORT_IF Mask */
S
S/* CRC WDATA Bit Field Definitions */
S#define CRC_WDATA_CRC_WDATA_Pos         0                                               /*!< CRC CRC_WDATA : CRC_WDATA Position */
S#define CRC_WDATA_CRC_WDATA_Msk         (0xFFFFFFFFul << CRC_WDATA_CRC_WDATA_Pos)       /*!< CRC CRC_WDATA : CRC_WDATA Mask */
S
S/* CRC SEED Bit Field Definitions */
S#define CRC_SEED_CRC_SEED_Pos           0                                               /*!< CRC CRC_SEED : CRC_SEED Position */
S#define CRC_SEED_CRC_SEED_Msk           (0xFFFFFFFFul << CRC_SEED_CRC_SEED_Pos)         /*!< CRC CRC_SEED : CRC_SEED Mask */
S
S/* CRC CHECKSUM Bit Field Definitions */
S#define CRC_CHECKSUM_CRC_CHECKSUM_Pos   0                                               /*!< CRC CRC_CHECKSUM : CRC_CHECKSUM Position */
S#define CRC_CHECKSUM_CRC_CHECKSUM_Msk   (0xFFFFFFFFul << CRC_CHECKSUM_CRC_CHECKSUM_Pos) /*!< CRC CRC_CHECKSUM : CRC_CHECKSUM Mask */
S/*@}*/ /* end of group NUC200_CRC */
S
S/*----------------------------- PWM Controller -------------------------------*/
S
S/** @addtogroup NUC200_PWM NUC200 PWM
S  Memory Mapped Structure for NUC200 Series PWM Generator and Capture Timer
S  @{
S */
Stypedef struct
S{
S    /**
S     * PPR
S     * ===================================================================================================
S     * Offset: 0x00  PWM Pre-Scale Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |CP01      |Clock pre-scalar 0(PWM counter 0 & 1 for group A and PWM counter 4 & 5 for group B)
S     * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
S     * |        |          |If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM 
S     * |        |          |counter will be stopped also.
S     * |[15:8]  |CP23      |Clock pre-scalar 2(PWM counter 2 & 3 for group A and PWM counter 6 & 7 for group B)
S     * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
S     * |        |          |If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM 
S     * |        |          |counter will be stopped also.
S     * |[23:16] |DZI01     |Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair 
S     * |        |          |for PWM group A, PWM4 and PWM5 pair for PWM group B)
S     * |        |          |These 8 bits determine dead zone length.
S     * |        |          |The unit time of dead zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK
S     * |        |          |where xy, could be 01 or 45, depends on selected PWM channel.
S     * |[31:24] |DZI23     |Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair 
S     * |        |          |for PWM group A, PWM6 and PWM7 pair for PWM group B)
S     * |        |          |These 8 bits determine dead zone length.
S     * |        |          |The unit time of dead zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK
S     * |        |          |where xy, could be 23 or 67, depends on selected PWM channel.
S     */    
S    __IO uint32_t PPR;
S
S    /**
S     * CSR
S     * ===================================================================================================
S     * Offset: 0x04  PWM Clock Source Divider Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |(Table is the same as CSR3)
S     * |[6:4]   |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |(Table is the same as CSR3)
S     * |[10:8]  |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |(Table is the same as CSR3)
S     * |[14:12] |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
S     * |        |          |Select clock input for timer.
S     * |        |          |CSRx[2:0] = Input clock divider
S     * |        |          |100 = 1
S     * |        |          |011 = 16
S     * |        |          |010 = 8
S     * |        |          |001 = 4
S     * |        |          |000 = 2
S     */    
S    __IO uint32_t CSR;
S
S    /**
S     * PCR
S     * ===================================================================================================
S     * Offset: 0x08  PWM Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CH0EN     |PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[2]     |CH0INV    |PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[3]     |CH0MOD    |PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.
S     * |[4]     |DZEN01    |Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A, 
S     * |        |          |PWM4 and PWM5 pair for PWM group B)
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a 
S     * |        |          |complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a 
S     * |        |          |complementary pair for PWM group B.
S     * |[5]     |DZEN23    |Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A, 
S     * |        |          |PWM6 and PWM7 pair for PWM group B)
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable
S     * |        |          |Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a 
S     * |        |          |complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a 
S     * |        |          |complementary pair for PWM group B.
S     * |[8]     |CH1EN     |PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[10]    |CH1INV    |PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[11]    |CH1MOD    |PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.
S     * |[16]    |CH2EN     |PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[18]    |CH2INV    |PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[19]    |CH2MOD    |PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.
S     * |[24]    |CH3EN     |PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for 
S     * |        |          |group B)
S     * |        |          |1 = Enable corresponding PWM-Timer Start Run
S     * |        |          |0 = Stop corresponding PWM-Timer Running
S     * |[26]    |CH3INV    |PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for 
S     * |        |          |group B)
S     * |        |          |1 = Inverter ON
S     * |        |          |0 = Inverter OFF
S     * |[27]    |CH3MOD    |PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7 
S     * |        |          |for group B)
S     * |        |          |1 = Auto-reload Mode
S     * |        |          |0 = One-Shot Mode
S     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.
S     */    
S    __IO uint32_t PCR;
S
S    /**
S     * CNR0
S     * ===================================================================================================
S     * Offset: 0x0C  PWM Counter 0/Timer 0 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR0;
S
S    /**
S     * CMR0
S     * ===================================================================================================
S     * Offset: 0x10  PWM Comparator 0 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR0;
S
S    /**
S     * PDR0
S     * ===================================================================================================
S     * Offset: 0x14  PWM Data 0 Register(current counter 0 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR0;
S
S    /**
S     * CNR1
S     * ===================================================================================================
S     * Offset: 0x18  PWM Counter 1/Timer 1 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR1;
S
S    /**
S     * CMR1
S     * ===================================================================================================
S     * Offset: 0x1C  PWM Comparator 1 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR1;
S
S    /**
S     * PDR1
S     * ===================================================================================================
S     * Offset: 0x20  PWM Data 1 Register(current counter 1 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR1;
S
S    /**
S     * CNR2
S     * ===================================================================================================
S     * Offset: 0x24  PWM Counter 2/Timer 2 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR2;
S
S    /**
S     * CMR2
S     * ===================================================================================================
S     * Offset: 0x28  PWM Comparator 2 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR2;
S
S    /**
S     * PDR2
S     * ===================================================================================================
S     * Offset: 0x2C  PWM Data 2 Register(current counter 2 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR2;
S
S    /**
S     * CNR3
S     * ===================================================================================================
S     * Offset: 0x30  PWM Counter 3/Timer 3 Loaded Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNR       | 
S     * |        |          |PWM Counter/Timer Loaded Value 
S     * |        |          |CNR determines the PWM period. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CNR3;
S
S    /**
S     * CMR3
S     * ===================================================================================================
S     * Offset: 0x34  PWM Comparator 3 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMR       | 
S     * |        |          |PWM Comparator Register 
S     * |        |          |CNR determines the PWM duty. 
S     * |        |          | 
S     * |        |          |PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 
S     * |        |          |45 or 67, depends on selected PWM channel. 
S     * |        |          | 
S     * |        |          |Duty ratio = (CMR+1)/(CNR+1). 
S     * |        |          | 
S     * |        |          |CMR >= CNR: PWM output is always high. 
S     * |        |          | 
S     * |        |          |CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit. 
S     * |        |          | 
S     * |        |          |CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit 
S     * |        |          | 
S     * |        |          |(Unit = one PWM clock cycle) 
S     * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S     */    
S    __IO uint32_t CMR3;
S
S    /**
S     * PDR3
S     * ===================================================================================================
S     * Offset: 0x38  PWM Data 3 Register(current counter 3 value)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PDR       | 
S     * |        |          |PWM Data Register 
S     * |        |          |User can monitor PDR to know the current value in 16-bit down counter.
S     */    
S    __I  uint32_t PDR3;
S
S    /**
S     * PBCR
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t PBCR;
S
S    /**
S     * PIER
S     * ===================================================================================================
S     * Offset: 0x40  PWM Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PWMIE0    |PWM channel 0 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     * |[1]     |PWMIE1    |PWM channel 1 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     * |[2]     |PWMIE2    |PWM channel 2 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     * |[3]     |PWMIE3    |PWM channel 3 Interrupt Enable
S     * |        |          |1 = Enable
S     * |        |          |0 = Disable 
S     */    
S    __IO uint32_t PIER;
S
S    /**
S     * PIIR
S     * ===================================================================================================
S     * Offset: 0x44  PWM Interrupt Indication Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PWMIF0    |PWM channel 0 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM0 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     * |[1]     |PWMIF1    |PWM channel 1 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM1 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     * |[2]     |PWMIF2    |PWM channel 2 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM2 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     * |[3]     |PWMIF3    |PWM channel 3 Interrupt Status
S     * |        |          |Flag is set by hardware when PWM3 down counter reaches zero, software can clear this 
S     * |        |          |bit by writing a one to it.
S     */    
S    __IO uint32_t PIIR;
S
S    /**
S     * RESERVE1
S     * ===================================================================================================
S     * 
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __I uint32_t    RESERVE1[2];
S
S    /**
S     * CCR0
S     * ===================================================================================================
S     * Offset: 0x50  Capture 0/1 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INV0      | 
S     * |        |          |PWM Group Channel 0 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[1]     |CRL_IE0   |PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 0 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[2]     |CFL_IE0   |PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 0 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[3]     |CAPCH0EN  |Capture Channel 0 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 0.
S     * |        |          |0 = Disable capture function on PWM group channel 0
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 0 Interrupt.
S     * |[4]     |CAPIF0    | 
S     * |        |          |Capture0 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs 
S     * |        |          |at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[6]     |CRLRI0    | 
S     * |        |          |CRLR0 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[7]     |CFLRI0    | 
S     * |        |          |CFLR0 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[16]    |INV1      | 
S     * |        |          |PWM Group Channel 1 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[17]    |CRL_IE1   |PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 1 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[18]    |CFL_IE1   |PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 1 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[19]    |CAPCH1EN  |Capture Channel 1 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 1.
S     * |        |          |0 = Disable capture function on PWM group channel 1
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 1 Interrupt.
S     * |[20]    |CAPIF1    | 
S     * |        |          |Capture1 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs 
S     * |        |          |at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[22]    |CRLRI1    | 
S     * |        |          |CRLR1 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[23]    |CFLRI1    | 
S     * |        |          |CFLR1 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     */    
S    __IO uint32_t CCR0;
S
S    /**
S     * CCR2
S     * ===================================================================================================
S     * Offset: 0x54  Capture 2/3 Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |INV2      | 
S     * |        |          |PWM Group Channel 2 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[1]     |CRL_IE2   |PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 2 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[2]     |CFL_IE2   |PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 2 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[3]     |CAPCH2EN  |Capture Channel 2 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 2.
S     * |        |          |0 = Disable capture function on PWM group channel 2
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 2 Interrupt.
S     * |[4]     |CAPIF2    | 
S     * |        |          |Capture2 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs 
S     * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[6]     |CRLRI2    | 
S     * |        |          |CRLR2 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[7]     |CFLRI2    | 
S     * |        |          |CFLR2 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[16]    |INV3      | 
S     * |        |          |PWM Group Channel 3 Inverter ON/OFF 
S     * |        |          | 
S     * |        |          |1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer 
S     * |        |          |0 = Inverter OFF
S     * |[17]    |CRL_IE3   |PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable rising latch interrupt
S     * |        |          |0 = Disable rising latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 3 has rising transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[18]    |CFL_IE3   |PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
S     * |        |          |1 = Enable falling latch interrupt
S     * |        |          |0 = Disable falling latch interrupt
S     * |        |          |When Enable, if Capture detects PWM group channel 3 has falling transition, Capture 
S     * |        |          |issues an Interrupt.
S     * |[19]    |CAPCH3EN  |Capture Channel 3 transition Enable/Disable
S     * |        |          |1 = Enable capture function on PWM group channel 3.
S     * |        |          |0 = Disable capture function on PWM group channel 3
S     * |        |          |When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising 
S     * |        |          |latch) and CFLR (Falling latch).
S     * |        |          |When Disable, Capture does not update CRLR and CFLR, and disable PWM group 
S     * |        |          |channel 3 Interrupt.
S     * |[20]    |CAPIF3    | 
S     * |        |          |Capture3 Interrupt Indication Flag 
S     * |        |          | 
S     * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs 
S     * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause 
S     * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1). 
S     * |        |          |This flag is clear by software with a write 1 to itself.
S     * |[22]    |CRLRI3    | 
S     * |        |          |CRLR3 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     * |[23]    |CFLRI3    | 
S     * |        |          |CFLR3 Latched Indicator Bit 
S     * |        |          | 
S     * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of 
S     * |        |          |PWM down-counter and this bit is set by hardware. 
S     * |        |          | 
S     * |        |          |Clear this bit by writing a one to it.
S     */    
S    __IO uint32_t CCR2;
S
S    /**
S     * CRLR0
S     * ===================================================================================================
S     * Offset: 0x58  Capture 0 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR0;
S
S    /**
S     * CFLR0
S     * ===================================================================================================
S     * Offset: 0x5C  Capture 0 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR0;
S
S    /**
S     * CRLR1
S     * ===================================================================================================
S     * Offset: 0x60  Capture 1 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR1;
S
S    /**
S     * CFLR1
S     * ===================================================================================================
S     * Offset: 0x64  Capture 1 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 01/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR1;
S
S    /**
S     * CRLR2
S     * ===================================================================================================
S     * Offset: 0x68  Capture 2 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR2;
S
S    /**
S     * CFLR2
S     * ===================================================================================================
S     * Offset: 0x6C  Capture 2 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR2;
S
S    /**
S     * CRLR3
S     * ===================================================================================================
S     * Offset: 0x70  Capture 3 Rising Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CRLR      |Capture Rising Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S     */    
S    __IO uint32_t CRLR3;
S
S    /**
S     * CFLR3
S     * ===================================================================================================
S     * Offset: 0x74  Capture 3 Falling Latch Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CFLR      |Capture Falling Latch Register
S     * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S     */    
S    __IO uint32_t CFLR3;
S
S    /**
S     * CAPENR
S     * ===================================================================================================
S     * Offset: 0x78  Capture Input Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |CAPENR    |Capture Input Enable Register
S     * |        |          |There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or 
S     * |        |          |OFF. 
S     * |        |          |0 = OFF (PWMx multi-function pin input does not affect input capture function.)
S     * |        |          |1 = (PWMx multi-function pin input will affect its input capture function.)
S     * |        |          |CAPENR
S     * |        |          |Bit 3210 for PWM group A
S     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [0] 
S     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [1] 
S     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [2]
S     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [3]
S     * |        |          |Bit 3210 for PWM group B
S     * |        |          |Bit xxx1 -> Capture channel 0 is from P2 [4] 
S     * |        |          |Bit xx1x -> Capture channel 1 is from P2 [5] 
S     * |        |          |Bit x1xx -> Capture channel 2 is from P2 [6]
S     * |        |          |Bit 1xxx -> Capture channel 3 is from P2 [7]
S     */    
S    __IO uint32_t CAPENR;
S
S    /**
S     * POE
S     * ===================================================================================================
S     * Offset: 0x7C  PWM Output Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PWM0      |PWM Channel 0 Output Enable Register
S     * |        |          |1 = Enable PWM channel 0 output to pin.
S     * |        |          |0 = Disable PWM channel 0 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     * |[1]     |PWM1      |PWM Channel 1 Output Enable Register
S     * |        |          |1 = Enable PWM channel 1 output to pin.
S     * |        |          |0 = Disable PWM channel 1 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     * |[2]     |PWM2      |PWM Channel 2 Output Enable Register
S     * |        |          |1 = Enable PWM channel 2 output to pin.
S     * |        |          |0 = Disable PWM channel 2 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     * |[3]     |PWM3      |PWM Channel 3 Output Enable Register
S     * |        |          |1 = Enable PWM channel 3 output to pin.
S     * |        |          |0 = Disable PWM channel 3 output to pin.
S     * |        |          |Note: The corresponding GPIO pin also must be switched to PWM function.
S     */    
S    __IO uint32_t POE;
S
S    /**
S     * TCON
S     * ===================================================================================================
S     * Offset: 0x80  PWM Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TCON;
S
S    /**
S     * TSTATUS
S     * ===================================================================================================
S     * Offset: 0x84  PWM Trigger Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */    
S    __IO uint32_t TSTATUS;
S
S    /**
S     * SYNCBUSY0
S     * ===================================================================================================
S     * Offset: 0x88  PWM0 Synchronous Busy Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */     
S    __IO uint32_t  SYNCBUSY0;
S
S    /**
S     * SYNCBUSY0
S     * ===================================================================================================
S     * Offset: 0x8C  PWM1 Synchronous Busy Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */     
S    __IO uint32_t  SYNCBUSY1;
S    
S    /**
S     * SYNCBUSY0
S     * ===================================================================================================
S     * Offset: 0x90  PWM2 Synchronous Busy Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */     
S    __IO uint32_t  SYNCBUSY2;
S    
S    /**
S     * SYNCBUSY0
S     * ===================================================================================================
S     * Offset: 0x94  PWM3 Synchronous Busy Status Register
S     * ---------------------------------------------------------------------------------------------------
S     */     
S    __IO uint32_t  SYNCBUSY3;
S                    
S} PWM_T;
S
S/* PWM PPR Bit Field Definitions */
S#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM PPR: DZI23 Position */
S#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM PPR: DZI23 Mask */
S
S#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM PPR: DZI01 Position */
S#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM PPR: DZI01 Mask */
S
S#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM PPR: CP23 Position */
S#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM PPR: CP23 Mask */
S
S#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM PPR: CP01 Position */
S#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM PPR: CP01 Mask */
S
S/* PWM CSR Bit Field Definitions */
S#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM CSR: CSR3 Position */
S#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM CSR: CSR3 Mask */
S
S#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM CSR: CSR2 Position */
S#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM CSR: CSR2 Mask */
S
S#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM CSR: CSR1 Position */
S#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM CSR: CSR1 Mask */
S
S#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM CSR: CSR0 Position */
S#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM CSR: CSR0 Mask */
S
S/* PWM PCR Bit Field Definitions */
S#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM PCR: PWM23TYPE Position */
S#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM PCR: PWM23TYPE Mask */
S
S#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM PCR: PWM01TYPE Position */
S#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM PCR: PWM01TYPE Mask */
S
S#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM PCR: CH3MOD Position */
S#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM PCR: CH3MOD Mask */
S
S#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM PCR: CH3INV Position */
S#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM PCR: CH3INV Mask */
S
S#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM PCR: CH3PINV Position */
S#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM PCR: CH3PINV Mask */
S
S#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM PCR: CH3EN Position */
S#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM PCR: CH3EN Mask */
S
S#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM PCR: CH2MOD Position */
S#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM PCR: CH2MOD Mask */
S
S#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM PCR: CH2INV Position */
S#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM PCR: CH2INV Mask */
S
S#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM PCR: CH2PINV Position */
S#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM PCR: CH2PINV Mask */
S
S#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM PCR: CH2EN Position */
S#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM PCR: CH2EN Mask */
S
S#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM PCR: CH1MOD Position */
S#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM PCR: CH1MOD Mask */
S
S#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM PCR: CH1INV Position */
S#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM PCR: CH1INV Mask */
S
S#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM PCR: CH1PINV Position */
S#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM PCR: CH1PINV Mask */
S
S#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM PCR: CH1EN Position */
S#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM PCR: CH1EN Mask */
S
S#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM PCR: DZEN23 Position */
S#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM PCR: DZEN23 Mask */
S
S#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM PCR: DZEN01 Position */
S#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM PCR: DZEN01 Mask */
S
S#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM PCR: CH0MOD Position */
S#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM PCR: CH0MOD Mask */
S
S#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM PCR: CH0INV Position */
S#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM PCR: CH0INV Mask */
S
S#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM PCR: CH0PINV Position */
S#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM PCR: CH0PINV Mask */
S
S#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM PCR: CH0EN Position */
S#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM PCR: CH0EN Mask */
S
S/* PWM CNR Bit Field Definitions */
S#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM CNR: CNR Position */
S#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM CNR: CNR Mask */
S
S/* PWM CMR Bit Field Definitions */
S#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM CMR: CMR Position */
S#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM CMR: CMR Mask */
S
S/* PWM PDR Bit Field Definitions */
S#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM PDR: PDR Position */
S#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM PDR: PDR Mask */
S
S/* PWM PBCR Bit Field Definitions */
S#define PWM_PBCR_BCn_Pos                         0                                  /*!< PWM PBCR: BCn Position */
S#define PWM_PBCR_BCn_Msk                         (1ul << PWM_PBCR_BCn_Pos)          /*!< PWM PBCR: BCn Mask */
S
S/* PWM PIER Bit Field Definitions */
S
S#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM PIER: INT23TYPE Position */
S#define PWM_PIER_INT23TYPE_Msk                     (1ul << PWM_PIER_INT23TYPE_Pos)  /*!< PWM PIER: INT23TYPE Mask */
S
S#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM PIER: INT01TYPE Position */
S#define PWM_PIER_INT01TYPE_Msk                     (1ul << PWM_PIER_INT01TYPE_Pos)  /*!< PWM PIER: INT01TYPE Mask */
S
S#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM PIER: PWMDIE3 Position */
S#define PWM_PIER_PWMDIE3_Msk                     (1ul << PWM_PIER_PWMDIE3_Pos)      /*!< PWM PIER: PWMDIE3 Mask */
S
S#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM PIER: PWMDIE2 Position */
S#define PWM_PIER_PWMDIE2_Msk                     (1ul << PWM_PIER_PWMDIE2_Pos)      /*!< PWM PIER: PWMDIE2 Mask */
S
S#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM PIER: PWMDIE1 Position */
S#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM PIER: PWMDIE1 Mask */
S
S#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM PIER: PWMDIE0 Position */
S#define PWM_PIER_PWMDIE0_Msk                     (1ul << PWM_PIER_PWMDIE0_Pos)      /*!< PWM PIER: PWMDIE0 Mask */
S
S#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM PIER: PWMIE3 Position */
S#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM PIER: PWMIE3 Mask */
S
S#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM PIER: PWMIE2 Position */
S#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM PIER: PWMIE2 Mask */
S
S#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM PIER: PWMIE1 Position */
S#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM PIER: PWMIE1 Mask */
S
S#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM PIER: PWMIE0 Position */
S#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM PIER: PWMIE0 Mask */
S
S/* PWM PIIR Bit Field Definitions */
S#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM PIIR: PWMDIF3 Position */
S#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM PIIR: PWMDIF3 Mask */
S
S#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM PIIR: PWMDIF2 Position */
S#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM PIIR: PWMDIF2 Mask */
S
S#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM PIIR: PWMDIF1 Position */
S#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM PIIR: PWMDIF1 Mask */
S
S#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM PIIR: PWMDIF0 Position */
S#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM PIIR: PWMDIF0 Mask */
S
S#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM PIIR: PWMIF3 Position */
S#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM PIIR: PWMIF3 Mask */
S
S#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM PIIR: PWMIF2 Position */
S#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM PIIR: PWMIF2 Mask */
S
S#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM PIIR: PWMIF1 Position */
S#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM PIIR: PWMIF1 Mask */
S
S#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM PIIR: PWMIF0 Position */
S#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM PIIR: PWMIF0 Mask */
S
S/* PWM CCR0 Bit Field Definitions */
S#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM CCR0: CFLRI1 Position */
S#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM CCR0: CFLRI1 Mask */
S
S#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM CCR0: CRLRI1 Position */
S#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM CCR0: CRLRI1 Mask */
S
S#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM CCR0: CAPIF1 Position */
S#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM CCR0: CAPIF1 Mask */
S
S#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM CCR0: CAPCH1EN Position */
S#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM CCR0: CAPCH1EN Mask */
S
S#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM CCR0: CFL_IE1 Position */
S#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM CCR0: CFL_IE1 Mask */
S
S#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM CCR0: CRL_IE1 Position */
S#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM CCR0: CRL_IE1 Mask */
S
S#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM CCR0: INV1 Position */
S#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM CCR0: INV1 Mask */
S
S#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM CCR0: CFLRI0 Position */
S#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM CCR0: CFLRI0 Mask */
S
S#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM CCR0: CRLRI0 Position */
S#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM CCR0: CRLRI0 Mask */
S
S#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM CCR0: CAPIF0 Position */
S#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM CCR0: CAPIF0 Mask */
S
S#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM CCR0: CAPCH0EN Position */
S#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM CCR0: CAPCH0EN Mask */
S
S#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM CCR0: CFL_IE0 Position */
S#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM CCR0: CFL_IE0 Mask */
S
S#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM CCR0: CRL_IE0 Position */
S#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM CCR0: CRL_IE0 Mask */
S
S#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM CCR0: INV0 Position */
S#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM CCR0: INV0 Mask */
S
S/* PWM CCR2 Bit Field Definitions */
S#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM CCR2: CFLRI3 Position */
S#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM CCR2: CFLRI3 Mask */
S
S#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM CCR2: CRLRI3 Position */
S#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM CCR2: CRLRI3 Mask */
S
S#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM CCR2: CAPIF3 Position */
S#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM CCR2: CAPIF3 Mask */
S
S#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM CCR2: CAPCH3EN Position */
S#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM CCR2: CAPCH3EN Mask */
S
S#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM CCR2: CFL_IE3 Position */
S#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM CCR2: CFL_IE3 Mask */
S
S#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM CCR2: CRL_IE3 Position */
S#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM CCR2: CRL_IE3 Mask */
S
S#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM CCR2: INV3 Position */
S#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM CCR2: INV3 Mask */
S
S#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM CCR2: CFLRI2 Position */
S#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM CCR2: CFLRI2 Mask */
S
S#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM CCR2: CRLRI2 Position */
S#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM CCR2: CRLRI2 Mask */
S
S#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM CCR2: CAPIF2 Position */
S#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM CCR2: CAPIF2 Mask */
S
S#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM CCR2: CAPCH2EN Position */
S#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM CCR2: CAPCH2EN Mask */
S
S#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM CCR2: CFL_IE2 Position */
S#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM CCR2: CFL_IE2 Mask */
S
S#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM CCR2: CRL_IE2 Position */
S#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM CCR2: CRL_IE2 Mask */
S
S#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM CCR2: INV2 Position */
S#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM CCR2: INV2 Mask */
S
S/* PWM CRLR Bit Field Definitions */
S#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM CRLR: CRLR Position */
S#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM CRLR: CRLR Mask */
S
S/* PWM CFLR Bit Field Definitions */
S#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM CFLR: CFLR Position */
S#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM CFLR: CFLR Mask */
S
S/* PWM CAPENR Bit Field Definitions */
S#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM CAPENR: CINEN3 Position */
S#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM CAPENR: CINEN3 Mask */   
S
S#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM CAPENR: CINEN2 Position */
S#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM CAPENR: CINEN2 Mask */  
S
S#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM CAPENR: CINEN1 Position */
S#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM CAPENR: CINEN1 Mask */  
S
S#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM CAPENR: CINEN0 Position */
S#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM CAPENR: CINEN0 Mask */ 
S
S/* PWM POE Bit Field Definitions */
S#define PWM_POE_POE3_Pos                        3                                   /*!< PWM POE: POE3 Position */
S#define PWM_POE_POE3_Msk                        (1ul << PWM_POE_POE3_Pos)           /*!< PWM POE: POE3 Mask */   
S
S#define PWM_POE_POE2_Pos                        2                                   /*!< PWM POE: POE2 Position */
S#define PWM_POE_POE2_Msk                        (1ul << PWM_POE_POE2_Pos)           /*!< PWM POE: POE2 Mask */  
S
S#define PWM_POE_POE1_Pos                        1                                   /*!< PWM POE: POE1 Position */
S#define PWM_POE_POE1_Msk                        (1ul << PWM_POE_POE1_Pos)           /*!< PWM POE: POE1 Mask */  
S
S#define PWM_POE_POE0_Pos                        0                                   /*!< PWM POE: POE0 Position */
S#define PWM_POE_POE0_Msk                        (1ul << PWM_POE_POE0_Pos)           /*!< PWM POE: POE0 Mask */  
S
S/* PWM TCON Bit Field Definitions */
S
S#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM TCON: PWM3TEN Position */
S#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM TCON: PWM3TEN Mask */ 
S
S#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM TCON: PWM2TEN Position */
S#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM TCON: PWM2TEN Mask */ 
S
S#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM TCON: PWM1TEN Position */
S#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM TCON: PWM1TEN Mask */ 
S
S#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM TCON: PWM0TEN Position */
S#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM TCON: PWM0TEN Mask */ 
S
S/* PWM TSTATUS Bit Field Definitions */
S
S#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM TSTATUS: PWM3TF Position */
S#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM TSTATUS: PWM3TF Mask */ 
S
S#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM TSTATUS: PWM2TF Position */
S#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM TSTATUS: PWM2TF Mask */ 
S
S#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM TSTATUS: PWM1TF Position */
S#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM TSTATUS: PWM1TF Mask */ 
S
S#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM TSTATUS: PWM0TF Position */
S#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM TSTATUS: PWM0TF Mask */ 
S
S/* PWM SYNCBUSY0 Bit Field Definitions */
S#define PWM_SYNCBUSY0_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY0: S_BUSY Position */
S#define PWM_SYNCBUSY0_S_BUSY_Msk                (1ul << PWM_SYNCBUSY0_S_BUSY_Pos)   /*!< PWM SYNCBUSY0: S_BUSY Mask */ 
S
S/* PWM SYNCBUSY1 Bit Field Definitions */
S#define PWM_SYNCBUSY1_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY1: S_BUSY Position */
S#define PWM_SYNCBUSY1_S_BUSY_Msk                (1ul << PWM_SYNCBUSY1_S_BUSY_Pos)   /*!< PWM SYNCBUSY1: S_BUSY Mask */ 
S
S/* PWM SYNCBUSY2 Bit Field Definitions */
S#define PWM_SYNCBUSY2_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY2: S_BUSY Position */
S#define PWM_SYNCBUSY2_S_BUSY_Msk                (1ul << PWM_SYNCBUSY2_S_BUSY_Pos)   /*!< PWM SYNCBUSY2: S_BUSY Mask */ 
S
S/* PWM SYNCBUSY3 Bit Field Definitions */
S#define PWM_SYNCBUSY3_S_BUSY_Pos                0                                   /*!< PWM SYNCBUSY3: S_BUSY Position */
S#define PWM_SYNCBUSY3_S_BUSY_Msk                (1ul << PWM_SYNCBUSY3_S_BUSY_Pos)   /*!< PWM SYNCBUSY3: S_BUSY Mask */ 
S/*@}*/ /* end of group NUC200_PWM */
S
S
S/*----------------------------- I2S Controller -------------------------------*/
S/** @addtogroup NUC200_I2S NUC200 I2S
S  Memory Mapped Structure for NUC200 Series I2S Interface Controller
S  @{
S */
Stypedef struct
S{
S    __IO uint32_t CON;                /*!< Offset: 0x00  I2S Control Register               */
S    __IO uint32_t CLKDIV;             /*!< Offset: 0x04  I2S Clock Divider Register         */
S    __IO uint32_t IE;                 /*!< Offset: 0x08  I2S Interrupt Enable Register      */
S    __I  uint32_t STATUS;             /*!< Offset: 0x0C  I2S Status Register                */
S    __O  uint32_t TXFIFO;             /*!< Offset: 0x10  I2S Transmit FIFO Register         */
S    __I  uint32_t RXFIFO;             /*!< Offset: 0x14  I2S Receive FIFO Register          */
S} I2S_T;
S
S
S/* I2S I2SCON Bit Field Definitions */
S#define I2S_CON_RXLCH_Pos                    23                                   /*!< I2S I2SCON: RXLCH Position         */
S#define I2S_CON_RXLCH_Msk                    (1ul << I2S_CON_RXLCH_Pos)           /*!< I2S I2SCON: RXLCH Mask             */
S
S#define I2S_CON_RXDMA_Pos                    21                                   /*!< I2S I2SCON: RXDMA Position         */
S#define I2S_CON_RXDMA_Msk                    (1ul << I2S_CON_RXDMA_Pos)           /*!< I2S I2SCON: RXDMA Mask             */
S
S#define I2S_CON_TXDMA_Pos                    20                                   /*!< I2S I2SCON: TXDMA Position         */
S#define I2S_CON_TXDMA_Msk                    (1ul << I2S_CON_TXDMA_Pos)           /*!< I2S I2SCON: TXDMA Mask             */
S
S#define I2S_CON_CLR_RXFIFO_Pos               19                                   /*!< I2S I2SCON: CLR_RXFIFO Position    */
S#define I2S_CON_CLR_RXFIFO_Msk               (1ul << I2S_CON_CLR_RXFIFO_Pos)      /*!< I2S I2SCON: CLR_RXFIFO Mask        */
S
S#define I2S_CON_CLR_TXFIFO_Pos               18                                   /*!< I2S I2SCON: CLR_TXFIFO Position    */
S#define I2S_CON_CLR_TXFIFO_Msk               (1ul << I2S_CON_CLR_TXFIFO_Pos)      /*!< I2S I2SCON: CLR_TXFIFO Mask        */
S
S#define I2S_CON_LCHZCEN_Pos                  17                                   /*!< I2S I2SCON: LCHZCEN Position       */
S#define I2S_CON_LCHZCEN_Msk                  (1ul << I2S_CON_LCHZCEN_Pos)         /*!< I2S I2SCON: LCHZCEN Mask           */
S
S#define I2S_CON_RCHZCEN_Pos                  16                                   /*!< I2S I2SCON: RCHZCEN Position       */
S#define I2S_CON_RCHZCEN_Msk                  (1ul << I2S_CON_RCHZCEN_Pos)         /*!< I2S I2SCON: RCHZCEN Mask           */
S
S#define I2S_CON_MCLKEN_Pos                   15                                   /*!< I2S I2SCON: MCLKEN Position        */
S#define I2S_CON_MCLKEN_Msk                   (1ul << I2S_CON_MCLKEN_Pos)          /*!< I2S I2SCON: MCLKEN Mask            */
S
S#define I2S_CON_RXTH_Pos                     12                                   /*!< I2S I2SCON: RXTH Position          */
S#define I2S_CON_RXTH_Msk                     (7ul << I2S_CON_RXTH_Pos)            /*!< I2S I2SCON: RXTH Mask              */
S
S#define I2S_CON_TXTH_Pos                     9                                    /*!< I2S I2SCON: TXTH Position          */
S#define I2S_CON_TXTH_Msk                     (7ul << I2S_CON_TXTH_Pos)            /*!< I2S I2SCON: TXTH Mask              */
S
S#define I2S_CON_SLAVE_Pos                    8                                    /*!< I2S I2SCON: SLAVE Position         */
S#define I2S_CON_SLAVE_Msk                    (1ul << I2S_CON_SLAVE_Pos)           /*!< I2S I2SCON: SLAVE Mask             */
S
S#define I2S_CON_FORMAT_Pos                   7                                    /*!< I2S I2SCON: FORMAT Position        */
S#define I2S_CON_FORMAT_Msk                   (1ul << I2S_CON_FORMAT_Pos)          /*!< I2S I2SCON: FORMAT Mask            */
S
S#define I2S_CON_MONO_Pos                     6                                    /*!< I2S I2SCON: MONO Position          */
S#define I2S_CON_MONO_Msk                     (1ul << I2S_CON_MONO_Pos)            /*!< I2S I2SCON: MONO Mask              */
S
S#define I2S_CON_WORDWIDTH_Pos                4                                    /*!< I2S I2SCON: WORDWIDTH Position     */
S#define I2S_CON_WORDWIDTH_Msk                (3ul << I2S_CON_WORDWIDTH_Pos)       /*!< I2S I2SCON: WORDWIDTH Mask         */
S
S#define I2S_CON_MUTE_Pos                     3                                    /*!< I2S I2SCON: MUTE Position          */
S#define I2S_CON_MUTE_Msk                     (1ul << I2S_CON_MUTE_Pos)            /*!< I2S I2SCON: MUTE Mask              */
S
S#define I2S_CON_RXEN_Pos                     2                                    /*!< I2S I2SCON: RXEN Position          */
S#define I2S_CON_RXEN_Msk                     (1ul << I2S_CON_RXEN_Pos)            /*!< I2S I2SCON: RXEN Mask              */
S
S#define I2S_CON_TXEN_Pos                     1                                    /*!< I2S I2SCON: TXEN Position          */
S#define I2S_CON_TXEN_Msk                     (1ul << I2S_CON_TXEN_Pos)            /*!< I2S I2SCON: TXEN Mask              */
S
S#define I2S_CON_I2SEN_Pos                    0                                    /*!< I2S I2SCON: I2SEN Position         */
S#define I2S_CON_I2SEN_Msk                    (1ul << I2S_CON_I2SEN_Pos)           /*!< I2S I2SCON: I2SEN Mask             */
S
S/* I2S I2SCLKDIV Bit Field Definitions */
S#define I2S_CLKDIV_BCLK_DIV_Pos              8                                       /*!< I2S I2SCLKDIV: BCLK_DIV Position   */
S#define I2S_CLKDIV_BCLK_DIV_Msk              (0xFFul << I2S_CLKDIV_BCLK_DIV_Pos)  /*!< I2S I2SCLKDIV: BCLK_DIV Mask       */
S
S#define I2S_CLKDIV_MCLK_DIV_Pos              0                                       /*!< I2S I2SCLKDIV: MCLK_DIV Position   */
S#define I2S_CLKDIV_MCLK_DIV_Msk              (7ul << I2S_CLKDIV_MCLK_DIV_Pos)     /*!< I2S I2SCLKDIV: MCLK_DIV Mask       */
S
S/* I2S I2SIE Bit Field Definitions */
S#define I2S_IE_LZCIE_Pos                     12                                      /*!< I2S I2SIE: LZCIE Position          */
S#define I2S_IE_LZCIE_Msk                     (1ul << I2S_IE_LZCIE_Pos)            /*!< I2S I2SIE: LZCIE Mask              */
S
S#define I2S_IE_RZCIE_Pos                     11                                   /*!< I2S I2SIE: RZCIE Position          */
S#define I2S_IE_RZCIE_Msk                     (1ul << I2S_IE_RZCIE_Pos)            /*!< I2S I2SIE: RZCIE Mask              */
S
S#define I2S_IE_TXTHIE_Pos                    10                                   /*!< I2S I2SIE: TXTHIE Position         */
S#define I2S_IE_TXTHIE_Msk                    (1ul << I2S_IE_TXTHIE_Pos)           /*!< I2S I2SIE: TXTHIE Mask             */
S                                     
S#define I2S_IE_TXOVFIE_Pos                   9                                    /*!< I2S I2SIE: TXOVFIE Position        */
S#define I2S_IE_TXOVFIE_Msk                   (1ul << I2S_IE_TXOVFIE_Pos)          /*!< I2S I2SIE: TXOVFIE Mask            */
S
S#define I2S_IE_TXUDFIE_Pos                   8                                    /*!< I2S I2SIE: TXUDFIE Position        */
S#define I2S_IE_TXUDFIE_Msk                   (1ul << I2S_IE_TXUDFIE_Pos)          /*!< I2S I2SIE: TXUDFIE Mask            */
S
S#define I2S_IE_RXTHIE_Pos                    2                                    /*!< I2S I2SIE: RXTHIE Position         */
S#define I2S_IE_RXTHIE_Msk                    (1ul << I2S_IE_RXTHIE_Pos)           /*!< I2S I2SIE: RXTHIE Mask             */
S                                     
S#define I2S_IE_RXOVFIE_Pos                   1                                    /*!< I2S I2SIE: RXOVFIE Position        */
S#define I2S_IE_RXOVFIE_Msk                   (1ul << I2S_IE_RXOVFIE_Pos)          /*!< I2S I2SIE: RXOVFIE Mask            */
S
S#define I2S_IE_RXUDFIE_Pos                   0                                    /*!< I2S I2SIE: RXUDFIE Position        */
S#define I2S_IE_RXUDFIE_Msk                   (1ul << I2S_IE_RXUDFIE_Pos)          /*!< I2S I2SIE: RXUDFIE Mask            */
S
S
S/* I2S I2SSTATUS Bit Field Definitions */
S#define I2S_STATUS_TX_LEVEL_Pos              28                                      /*!< I2S I2SSTATUS: TX_LEVEL Position   */
S#define I2S_STATUS_TX_LEVEL_Msk              (0xFul << I2S_STATUS_TX_LEVEL_Pos)   /*!< I2S I2SSTATUS: TX_LEVEL Mask       */
S
S#define I2S_STATUS_RX_LEVEL_Pos              24                                   /*!< I2S I2SSTATUS: RX_LEVEL Position   */
S#define I2S_STATUS_RX_LEVEL_Msk              (0xFul << I2S_STATUS_RX_LEVEL_Pos)   /*!< I2S I2SSTATUS: RX_LEVEL Mask       */
S
S#define I2S_STATUS_LZCF_Pos                  23                                      /*!< I2S I2SSTATUS: LZCF Position       */
S#define I2S_STATUS_LZCF_Msk                  (1ul << I2S_STATUS_LZCF_Pos)         /*!< I2S I2SSTATUS: LZCF Mask           */
S
S#define I2S_STATUS_RZCF_Pos                  22                                   /*!< I2S I2SSTATUS: RZCF Position       */
S#define I2S_STATUS_RZCF_Msk                  (1ul << I2S_STATUS_RZCF_Pos)         /*!< I2S I2SSTATUS: RZCF Mask           */
S
S#define I2S_STATUS_TXBUSY_Pos                21                                   /*!< I2S I2SSTATUS: TXBUSY Position     */
S#define I2S_STATUS_TXBUSY_Msk                (1ul << I2S_STATUS_TXBUSY_Pos)       /*!< I2S I2SSTATUS: TXBUSY Mask         */
S
S#define I2S_STATUS_TXEMPTY_Pos               20                                   /*!< I2S I2SSTATUS: TXEMPTY Position    */
S#define I2S_STATUS_TXEMPTY_Msk               (1ul << I2S_STATUS_TXEMPTY_Pos)      /*!< I2S I2SSTATUS: TXEMPTY Mask        */
S
S#define I2S_STATUS_TXFULL_Pos                19                                   /*!< I2S I2SSTATUS: TXFULL Position     */
S#define I2S_STATUS_TXFULL_Msk                (1ul << I2S_STATUS_TXFULL_Pos)       /*!< I2S I2SSTATUS: TXFULL Mask         */
S
S#define I2S_STATUS_TXTHF_Pos                 18                                   /*!< I2S I2SSTATUS: TXTHF Position      */
S#define I2S_STATUS_TXTHF_Msk                 (1ul << I2S_STATUS_TXTHF_Pos)        /*!< I2S I2SSTATUS: TXTHF Mask          */
S
S#define I2S_STATUS_TXOVF_Pos                 17                                   /*!< I2S I2SSTATUS: TXOVF Position      */
S#define I2S_STATUS_TXOVF_Msk                 (1ul << I2S_STATUS_TXOVF_Pos)        /*!< I2S I2SSTATUS: TXOVF Mask          */
S
S#define I2S_STATUS_TXUDF_Pos                 16                                   /*!< I2S I2SSTATUS: TXUDF Position      */
S#define I2S_STATUS_TXUDF_Msk                 (1ul << I2S_STATUS_TXUDF_Pos)        /*!< I2S I2SSTATUS: TXUDF Mask          */
S
S#define I2S_STATUS_RXEMPTY_Pos               12                                   /*!< I2S I2SSTATUS: RXEMPTY Position    */
S#define I2S_STATUS_RXEMPTY_Msk               (1ul << I2S_STATUS_RXEMPTY_Pos)      /*!< I2S I2SSTATUS: RXEMPTY Mask        */
S
S#define I2S_STATUS_RXFULL_Pos                11                                   /*!< I2S I2SSTATUS: RXFULL Position     */
S#define I2S_STATUS_RXFULL_Msk                (1ul << I2S_STATUS_RXFULL_Pos)       /*!< I2S I2SSTATUS: RXFULL Mask         */
S
S#define I2S_STATUS_RXTHF_Pos                 10                                   /*!< I2S I2SSTATUS: RXTHF Position      */
S#define I2S_STATUS_RXTHF_Msk                 (1ul << I2S_STATUS_RXTHF_Pos)        /*!< I2S I2SSTATUS: RXTHF Mask          */
S
S#define I2S_STATUS_RXOVF_Pos                 9                                    /*!< I2S I2SSTATUS: RXOVF Position      */
S#define I2S_STATUS_RXOVF_Msk                 (1ul << I2S_STATUS_RXOVF_Pos)        /*!< I2S I2SSTATUS: RXOVF Mask          */
S
S#define I2S_STATUS_RXUDF_Pos                 8                                    /*!< I2S I2SSTATUS: RXUDF Position      */
S#define I2S_STATUS_RXUDF_Msk                 (1ul << I2S_STATUS_RXUDF_Pos)        /*!< I2S I2SSTATUS: RXUDF Mask          */
S
S#define I2S_STATUS_RIGHT_Pos                 3                                    /*!< I2S I2SSTATUS: RIGHT Position      */
S#define I2S_STATUS_RIGHT_Msk                 (1ul << I2S_STATUS_RIGHT_Pos)        /*!< I2S I2SSTATUS: RIGHT Mask          */
S
S#define I2S_STATUS_I2STXINT_Pos              2                                    /*!< I2S I2SSTATUS: I2STXINT Position   */
S#define I2S_STATUS_I2STXINT_Msk              (1ul << I2S_STATUS_I2STXINT_Pos)     /*!< I2S I2SSTATUS: I2STXINT Mask       */
S
S#define I2S_STATUS_I2SRXINT_Pos              1                                    /*!< I2S I2SSTATUS: I2SRXINT Position   */
S#define I2S_STATUS_I2SRXINT_Msk              (1ul << I2S_STATUS_I2SRXINT_Pos)     /*!< I2S I2SSTATUS: I2SRXINT Mask       */
S
S#define I2S_STATUS_I2SINT_Pos                0                                    /*!< I2S I2SSTATUS: I2SINT Position     */
S#define I2S_STATUS_I2SINT_Msk                (1ul << I2S_STATUS_I2SINT_Pos)       /*!< I2S I2SSTATUS: I2SINT Mask         */
S
S/*@}*/ /* end of group NUC200_I2S */
S
S
S
S/*----------------------------- Smart Card Host Interface -------------------------------*/
S
S/** @addtogroup NUC200_SMARTCARD NUC200 SMARTCARD
S  Memory Mapped Structure for NUC200 Series Smart Card Host Interface
S  @{
S */
Stypedef struct
S{  
S    union {
S        __I  uint32_t  RBR;     /*!< Offset: 0x00  SC Receiving Buffer Register */
S        __O  uint32_t  THR;     /*!< Offset: 0x00  SC Transmit Holding Register */
S    };
S  
S    __IO uint32_t  CTL;         /*!< Offset: 0x04  SC Control Register */
S    __IO uint32_t  ALTCTL;      /*!< Offset: 0x08  SC Alternate Control State Register */
S    __IO uint32_t  EGTR;        /*!< Offset: 0x0C  SC Extend Guard Time Register */        
S    __IO uint32_t  RFTMR;       /*!< Offset: 0x10  SC Receiver buffer Time Out Register */
S    __IO uint32_t  ETUCR;       /*!< Offset: 0x14  SC ETU Control Register */
S    __IO uint32_t  IER;         /*!< Offset: 0x18  SC Interrupt Enable Register */
S    __IO uint32_t  ISR;         /*!< Offset: 0x1C  SC Interrupt Status Register (Read Only) */
S    __IO uint32_t  TRSR;        /*!< Offset: 0x20  SC Transfer Status Register (Read Only) */
S    __IO uint32_t  PINCSR;      /*!< Offset: 0x24  SC Pin Control State Register  */
S    __IO uint32_t  TMR0;        /*!< Offset: 0x28  SC Internal Timer Control Register 0 */
S    __IO uint32_t  TMR1;        /*!< Offset: 0x2C  SC Internal Timer Control Register 1 */
S    __IO uint32_t  TMR2;        /*!< Offset: 0x30  SC Internal Timer Control Register 2 */
S    uint32_t       RESERVE0[1]; /*!< Offset: 0x34  SC Reserve */
S    __I  uint32_t  TDRA;        /*!< Offset: 0x38  SC Timer Current Data Register A */
S    __I  uint32_t  TDRB;        /*!< Offset: 0x3C  SC Timer Current Data Register B */
S} SC_T;
S
S/* SC RBR Bit Field Definitions */
S#define SC_RBR_RBR_Pos                      0                                /*!< SC RBR: RBR Position */
S#define SC_RBR_RBR_Msk                      (0xFFul << SC_RBR_RBR_Pos)       /*!< SC RBR: RBR Mask */
S
S/* SC THR Bit Field Definitions */
S#define SC_THR_THR_Pos                      0                                /*!< SC THR: THR Position */
S#define SC_THR_THR_Msk                      (0xFFul << SC_THR_THR_Pos)       /*!< SC THR: THR Mask */
S
S/* SC CTL Bit Field Definitions */
S#define SC_CTL_CD_DEB_SEL_Pos               24                               /*!< SC CTL: CD_DEB_SEL Position */
S#define SC_CTL_CD_DEB_SEL_Msk               (3ul << SC_CTL_CD_DEB_SEL_Pos)   /*!< SC CTL: CD_DEB_SEL Mask */
S
S#define SC_CTL_TX_ERETRY_EN_Pos             23                               /*!< SC CTL: TX_ERETRY_EN Position */
S#define SC_CTL_TX_ERETRY_EN_Msk             (1ul << SC_CTL_TX_ERETRY_EN_Pos) /*!< SC CTL: TX_ERETRY_EN Mask */
S
S#define SC_CTL_TX_ERETRY_Pos                20                               /*!< SC CTL: TX_ERETRY Position */
S#define SC_CTL_TX_ERETRY_Msk                (7ul << SC_CTL_TX_ERETRY_Pos)    /*!< SC CTL: TX_ERETRY Mask */
S
S#define SC_CTL_RX_ERETRY_EN_Pos             19                               /*!< SC CTL: RX_ERETRY_EN Position */
S#define SC_CTL_RX_ERETRY_EN_Msk             (1ul << SC_CTL_RX_ERETRY_EN_Pos) /*!< SC CTL: RX_ERETRY_EN Mask */
S
S#define SC_CTL_RX_ERETRY_Pos                16                               /*!< SC CTL: RX_ERETRY Position */
S#define SC_CTL_RX_ERETRY_Msk                (7ul << SC_CTL_RX_ERETRY_Pos)    /*!< SC CTL: RX_ERETRY Mask */
S
S#define SC_CTL_SLEN_Pos                     15                               /*!< SC CTL: SLEN Position */
S#define SC_CTL_SLEN_Msk                     (1ul << SC_CTL_SLEN_Pos)         /*!< SC CTL: SLEN Mask */
S
S#define SC_CTL_TMR_SEL_Pos                  13                               /*!< SC CTL: TMR_SEL Position */
S#define SC_CTL_TMR_SEL_Msk                  (3ul << SC_CTL_TMR_SEL_Pos)      /*!< SC CTL: TMR_SEL Mask */
S
S#define SC_CTL_BGT_Pos                      8                                /*!< SC CTL: BGT Position */
S#define SC_CTL_BGT_Msk                      (0x1Ful << SC_CTL_BGT_Pos)       /*!< SC CTL: BGT Mask */
S
S#define SC_CTL_RX_FTRI_LEV_Pos              6                                /*!< SC CTL: RX_FTRI_LEV Position */
S#define SC_CTL_RX_FTRI_LEV_Msk              (3ul << SC_CTL_RX_FTRI_LEV_Pos)  /*!< SC CTL: RX_FTRI_LEV Mask */
S
S#define SC_CTL_CON_SEL_Pos                  4                                /*!< SC CTL: CON_SEL Position */
S#define SC_CTL_CON_SEL_Msk                  (3ul << SC_CTL_CON_SEL_Pos)      /*!< SC CTL: CON_SEL Mask */
S
S#define SC_CTL_AUTO_CON_EN_Pos              3                                /*!< SC CTL: AUTO_CON_EN Position */
S#define SC_CTL_AUTO_CON_EN_Msk              (1ul << SC_CTL_AUTO_CON_EN_Pos)  /*!< SC CTL: AUTO_CON_EN Mask */
S
S#define SC_CTL_DIS_TX_Pos                   2                                /*!< SC CTL: DIS_TX Position */
S#define SC_CTL_DIS_TX_Msk                   (1ul << SC_CTL_DIS_TX_Pos)       /*!< SC CTL: DIS_TX Mask */
S
S#define SC_CTL_DIS_RX_Pos                   1                                /*!< SC CTL: DIS_RX Position */
S#define SC_CTL_DIS_RX_Msk                   (1ul << SC_CTL_DIS_RX_Pos)       /*!< SC CTL: DIS_RX Mask */
S
S#define SC_CTL_SC_CEN_Pos                   0                                /*!< SC CTL: SC_CEN Position */
S#define SC_CTL_SC_CEN_Msk                   (1ul << SC_CTL_SC_CEN_Pos)       /*!< SC CTL: SC_CEN Mask */
S
S/* SC ALTCTL Bit Field Definitions */
S#define SC_ALTCTL_TMR2_ATV_Pos              15                               /*!< SC ALTCTL: TMR2_ATV Position */
S#define SC_ALTCTL_TMR2_ATV_Msk              (1ul << SC_ALTCTL_TMR2_ATV_Pos)  /*!< SC ALTCTL: TMR2_ATV Mask */
S
S#define SC_ALTCTL_TMR1_ATV_Pos              14                               /*!< SC ALTCTL: TMR1_ATV Position */
S#define SC_ALTCTL_TMR1_ATV_Msk              (1ul << SC_ALTCTL_TMR1_ATV_Pos)  /*!< SC ALTCTL: TMR1_ATV Mask */
S
S#define SC_ALTCTL_TMR0_ATV_Pos              13                               /*!< SC ALTCTL: TMR0_ATV Position */
S#define SC_ALTCTL_TMR0_ATV_Msk              (1ul << SC_ALTCTL_TMR0_ATV_Pos)  /*!< SC ALTCTL: TMR0_ATV Mask */
S
S#define SC_ALTCTL_RX_BGT_EN_Pos             12                               /*!< SC ALTCTL: RX_BGT_EN Position */
S#define SC_ALTCTL_RX_BGT_EN_Msk             (1ul << SC_ALTCTL_RX_BGT_EN_Pos) /*!< SC ALTCTL: RX_BGT_EN Mask */
S
S#define SC_ALTCTL_INIT_SEL_Pos              8                                /*!< SC ALTCTL: INIT_SEL Position */
S#define SC_ALTCTL_INIT_SEL_Msk              (3ul << SC_ALTCTL_INIT_SEL_Pos)  /*!< SC ALTCTL: INIT_SEL Mask */
S
S#define SC_ALTCTL_TMR2_SEN_Pos              7                                /*!< SC ALTCTL: TMR2_SEN Position */
S#define SC_ALTCTL_TMR2_SEN_Msk              (1ul << SC_ALTCTL_TMR2_SEN_Pos)  /*!< SC ALTCTL: TMR2_SEN Mask */
S
S#define SC_ALTCTL_TMR1_SEN_Pos              6                                /*!< SC ALTCTL: TMR1_SEN Position */
S#define SC_ALTCTL_TMR1_SEN_Msk              (1ul << SC_ALTCTL_TMR1_SEN_Pos)  /*!< SC ALTCTL: TMR1_SEN Mask */
S
S#define SC_ALTCTL_TMR0_SEN_Pos              5                                /*!< SC ALTCTL: TMR0_SEN Position */
S#define SC_ALTCTL_TMR0_SEN_Msk              (1ul << SC_ALTCTL_TMR0_SEN_Pos)  /*!< SC ALTCTL: TMR0_SEN Mask */
S
S#define SC_ALTCTL_WARST_EN_Pos              4                                /*!< SC ALTCTL: WARST_EN Position */
S#define SC_ALTCTL_WARST_EN_Msk              (1ul << SC_ALTCTL_WARST_EN_Pos)  /*!< SC ALTCTL: WARST_EN Mask */
S
S#define SC_ALTCTL_ACT_EN_Pos                3                                /*!< SC ALTCTL: ACT_EN Position */
S#define SC_ALTCTL_ACT_EN_Msk                (1ul << SC_ALTCTL_ACT_EN_Pos)    /*!< SC ALTCTL: ACT_EN Mask */
S
S#define SC_ALTCTL_DACT_EN_Pos               2                                /*!< SC ALTCTL: DACT_EN Position */
S#define SC_ALTCTL_DACT_EN_Msk               (1ul << SC_ALTCTL_DACT_EN_Pos)   /*!< SC ALTCTL: DACT_EN Mask */
S
S#define SC_ALTCTL_RX_RST_Pos                1                                /*!< SC ALTCTL: RX_RST Position */
S#define SC_ALTCTL_RX_RST_Msk                (1ul << SC_ALTCTL_RX_RST_Pos)    /*!< SC ALTCTL: RX_RST Mask */
S
S#define SC_ALTCTL_TX_RST_Pos                0                                /*!< SC ALTCTL: TX_RST Position */
S#define SC_ALTCTL_TX_RST_Msk                (1ul << SC_ALTCTL_TX_RST_Pos)    /*!< SC ALTCTL: TX_RST Mask */
S
S/* SC EGTR Bit Field Definitions */
S#define SC_EGTR_EGT_Pos                     0                               /*!< SC EGTR: EGT Position */
S#define SC_EGTR_EGT_Msk                     (0xFFul << SC_EGTR_EGT_Pos)     /*!< SC EGTR: EGT Mask */
S
S/* SC RFTMR Bit Field Definitions */
S#define SC_RFTMR_RFTM_Pos                   0                               /*!< SC RFTMR: RFTM Position */
S#define SC_RFTMR_RFTM_Msk                   (0x1FFul << SC_RFTMR_RFTM_Pos)  /*!< SC RFTMR: RFTM Mask */
S
S/* SC ETUCR Bit Field Definitions */
S#define SC_ETUCR_COMPEN_EN_Pos              15                               /*!< SC ETUCR: COMPEN_EN Position */
S#define SC_ETUCR_COMPEN_EN_Msk              (1ul << SC_ETUCR_COMPEN_EN_Pos)  /*!< SC ETUCR: COMPEN_EN Mask */
S
S#define SC_ETUCR_ETU_RDIV_Pos               0                                   /*!< SC ETUCR: ETU_RDIV Position */
S#define SC_ETUCR_ETU_RDIV_Msk               (0xFFFul << SC_ETUCR_ETU_RDIV_Pos)  /*!< SC ETUCR: ETU_RDIV Mask */
S
S/* SC IER Bit Field Definitions */
S#define SC_IER_ACON_ERR_IE_Pos              10                                  /*!< SC IER: ACON_ERR_IE Position */
S#define SC_IER_ACON_ERR_IE_Msk              (1ul << SC_IER_ACON_ERR_IE_Pos)     /*!< SC IER: ACON_ERR_IE Mask */
S
S#define SC_IER_RTMR_IE_Pos                  9                               /*!< SC IER: RTMR_IE Position */
S#define SC_IER_RTMR_IE_Msk                  (1ul << SC_IER_RTMR_IE_Pos)     /*!< SC IER: RTMR_IE Mask */
S
S#define SC_IER_INIT_IE_Pos                  8                               /*!< SC IER: INIT_IE Position */
S#define SC_IER_INIT_IE_Msk                  (1ul << SC_IER_INIT_IE_Pos)     /*!< SC IER: INIT_IE Mask */
S
S#define SC_IER_CD_IE_Pos                    7                               /*!< SC IER: CD_IE Position */
S#define SC_IER_CD_IE_Msk                    (1ul << SC_IER_CD_IE_Pos)       /*!< SC IER: CD_IE Mask */
S
S#define SC_IER_BGT_IE_Pos                   6                               /*!< SC IER: BGT_IE Position */
S#define SC_IER_BGT_IE_Msk                   (1ul << SC_IER_BGT_IE_Pos)      /*!< SC IER: BGT_IE Mask */
S
S#define SC_IER_TMR2_IE_Pos                  5                               /*!< SC IER: TMR2_IE Position */
S#define SC_IER_TMR2_IE_Msk                  (1ul << SC_IER_TMR2_IE_Pos)     /*!< SC IER: TMR2_IE Mask */
S
S#define SC_IER_TMR1_IE_Pos                  4                               /*!< SC IER: TMR1_IE Position */
S#define SC_IER_TMR1_IE_Msk                  (1ul << SC_IER_TMR1_IE_Pos)     /*!< SC IER: TMR1_IE Mask */
S
S#define SC_IER_TMR0_IE_Pos                  3                               /*!< SC IER: TMR0_IE Position */
S#define SC_IER_TMR0_IE_Msk                  (1ul << SC_IER_TMR0_IE_Pos)     /*!< SC IER: TMR0_IE Mask */
S
S#define SC_IER_TERR_IE_Pos                  2                               /*!< SC IER: TERR_IE Position */
S#define SC_IER_TERR_IE_Msk                  (1ul << SC_IER_TERR_IE_Pos)     /*!< SC IER: TERR_IE Mask */
S
S#define SC_IER_TBE_IE_Pos                   1                               /*!< SC IER: TBE_IE Position */
S#define SC_IER_TBE_IE_Msk                   (1ul << SC_IER_TBE_IE_Pos)      /*!< SC IER: TBE_IE Mask */
S
S#define SC_IER_RDA_IE_Pos                   0                               /*!< SC IER: RDA_IE Position */
S#define SC_IER_RDA_IE_Msk                   (1ul << SC_IER_RDA_IE_Pos)      /*!< SC IER: RDA_IE Mask */
S
S/* SC ISR Bit Field Definitions */
S#define SC_ISR_ACON_ERR_IS_Pos              10                              /*!< SC ISR: ACON_ERR_IS Position */
S#define SC_ISR_ACON_ERR_IS_Msk              (1ul << SC_ISR_ACON_ERR_IS_Pos) /*!< SC ISR: ACON_ERR_IS Mask */
S
S#define SC_ISR_RTMR_IS_Pos                  9                               /*!< SC ISR: RTMR_IS Position */
S#define SC_ISR_RTMR_IS_Msk                  (1ul << SC_ISR_RTMR_IS_Pos)     /*!< SC ISR: RTMR_IS Mask */
S
S#define SC_ISR_INIT_IS_Pos                  8                               /*!< SC ISR: INIT_IS Position */
S#define SC_ISR_INIT_IS_Msk                  (1ul << SC_ISR_INIT_IS_Pos)     /*!< SC ISR: INIT_IS Mask */
S
S#define SC_ISR_CD_IS_Pos                    7                               /*!< SC ISR: CD_IS Position */
S#define SC_ISR_CD_IS_Msk                    (1ul << SC_ISR_CD_IS_Pos)       /*!< SC ISR: CD_IS Mask */
S
S#define SC_ISR_BGT_IS_Pos                   6                               /*!< SC ISR: BGT_IS Position */
S#define SC_ISR_BGT_IS_Msk                   (1ul << SC_ISR_BGT_IS_Pos)      /*!< SC ISR: BGT_IS Mask */
S
S#define SC_ISR_TMR2_IS_Pos                  5                               /*!< SC ISR: TMR2_IS Position */
S#define SC_ISR_TMR2_IS_Msk                  (1ul << SC_ISR_TMR2_IS_Pos)     /*!< SC ISR: TMR2_IS Mask */
S
S#define SC_ISR_TMR1_IS_Pos                  4                               /*!< SC ISR: TMR1_IS Position */
S#define SC_ISR_TMR1_IS_Msk                  (1ul << SC_ISR_TMR1_IS_Pos)     /*!< SC ISR: TMR1_IS Mask */
S
S#define SC_ISR_TMR0_IS_Pos                  3                               /*!< SC ISR: TMR0_IS Position */
S#define SC_ISR_TMR0_IS_Msk                  (1ul << SC_ISR_TMR0_IS_Pos)     /*!< SC ISR: TMR0_IS Mask */
S
S#define SC_ISR_TERR_IS_Pos                  2                               /*!< SC ISR: TERR_IS Position */
S#define SC_ISR_TERR_IS_Msk                  (1ul << SC_ISR_TERR_IS_Pos)     /*!< SC ISR: TERR_IS Mask */
S
S#define SC_ISR_TBE_IS_Pos                   1                               /*!< SC ISR: TXBE_IS Position */
S#define SC_ISR_TBE_IS_Msk                   (1ul << SC_ISR_TBE_IS_Pos)      /*!< SC ISR: TXBE_IS Mask */
S
S#define SC_ISR_RDA_IS_Pos                   0                               /*!< SC ISR: RDA_IS Position */
S#define SC_ISR_RDA_IS_Msk                   (1ul << SC_ISR_RDA_IS_Pos)      /*!< SC ISR: RDA_IS Mask */
S
S
S/* SC TRSR Bit Field Definitions */
S#define SC_TRSR_TX_ATV_Pos                  31                              /*!< SC TRSR: TX_ATV Position */
S#define SC_TRSR_TX_ATV_Msk                  (1ul << SC_TRSR_TX_ATV_Pos)     /*!< SC TRSR: TX_ATV Mask */
S
S#define SC_TRSR_TX_OVER_REERR_Pos           30                                  /*!< SC TRSR: TX_OVER_REERR Position */
S#define SC_TRSR_TX_OVER_REERR_Msk           (1ul << SC_TRSR_TX_OVER_REERR_Pos)  /*!< SC TRSR: TX_OVER_REERR Mask */
S
S#define SC_TRSR_TX_REERR_Pos                29                               /*!< SC TRSR: TX_REERR Position */
S#define SC_TRSR_TX_REERR_Msk                (1ul << SC_TRSR_TX_REERR_Pos)    /*!< SC TRSR: TX_REERR Mask */
S
S#define SC_TRSR_TX_POINT_F_Pos              24                               /*!< SC TRSR: TX_POINT_F Position */
S#define SC_TRSR_TX_POINT_F_Msk              (7ul << SC_TRSR_TX_POINT_F_Pos)  /*!< SC TRSR: TX_POINT_F Mask */
S
S#define SC_TRSR_RX_ATV_Pos                  23                               /*!< SC TRSR: RX_ATV Position */
S#define SC_TRSR_RX_ATV_Msk                  (1ul << SC_TRSR_RX_ATV_Pos)      /*!< SC TRSR: RX_ATV Mask */
S
S#define SC_TRSR_RX_OVER_REERR_Pos           22                                  /*!< SC TRSR: RX_OVER_REERR Position */
S#define SC_TRSR_RX_OVER_REERR_Msk           (1ul << SC_TRSR_RX_OVER_REERR_Pos)  /*!< SC TRSR: RX_OVER_REERR Mask */
S
S#define SC_TRSR_RX_REERR_Pos                21                                  /*!< SC TRSR: RX_REERR Position */
S#define SC_TRSR_RX_REERR_Msk                (1ul << SC_TRSR_RX_REERR_Pos)       /*!< SC TRSR: RX_REERR Mask */
S
S#define SC_TRSR_RX_POINT_F_Pos              16                                  /*!< SC TRSR: RX_POINT_F Position */
S#define SC_TRSR_RX_POINT_F_Msk              (7ul << SC_TRSR_RX_POINT_F_Pos)     /*!< SC TRSR: RX_POINT_F Mask */
S
S#define SC_TRSR_TX_FULL_F_Pos               10                                  /*!< SC TRSR: TX_FULL_F Position */
S#define SC_TRSR_TX_FULL_F_Msk               (1ul << SC_TRSR_TX_FULL_F_Pos)      /*!< SC TRSR: TX_FULL_F Mask */
S
S#define SC_TRSR_TX_EMPTY_F_Pos              9                                   /*!< SC TRSR: TX_EMPTY_F Position */
S#define SC_TRSR_TX_EMPTY_F_Msk              (1ul << SC_TRSR_TX_EMPTY_F_Pos)     /*!< SC TRSR: TX_EMPTY_F Mask */
S
S#define SC_TRSR_TX_OVER_F_Pos               8                                   /*!< SC TRSR: TX_OVER_F Position */
S#define SC_TRSR_TX_OVER_F_Msk               (1ul << SC_TRSR_TX_OVER_F_Pos)      /*!< SC TRSR: TX_OVER_F Mask */
S
S#define SC_TRSR_RX_EBR_F_Pos                6                                   /*!< SC TRSR: RX_EBR_F Position */
S#define SC_TRSR_RX_EBR_F_Msk                (1ul << SC_TRSR_RX_EBR_F_Pos)       /*!< SC TRSR: RX_EBR_F Mask */
S
S#define SC_TRSR_RX_EFR_F_Pos                5                                   /*!< SC TRSR: RX_EFR_F Position */
S#define SC_TRSR_RX_EFR_F_Msk                (1ul << SC_TRSR_RX_EFR_F_Pos)       /*!< SC TRSR: RX_EFR_F Mask */
S
S#define SC_TRSR_RX_EPA_F_Pos                4                                   /*!< SC TRSR: RX_EPA_F Position */
S#define SC_TRSR_RX_EPA_F_Msk                (1ul << SC_TRSR_RX_EPA_F_Pos)       /*!< SC TRSR: RX_EPA_F Mask */
S
S#define SC_TRSR_RX_FULL_F_Pos               2                                   /*!< SC TRSR: RX_FULL_F Position */
S#define SC_TRSR_RX_FULL_F_Msk               (1ul << SC_TRSR_RX_FULL_F_Pos)      /*!< SC TRSR: RX_FULL_F Mask */
S
S#define SC_TRSR_RX_EMPTY_F_Pos              1                                   /*!< SC TRSR: RX_EMPTY_F Position */
S#define SC_TRSR_RX_EMPTY_F_Msk              (1ul << SC_TRSR_RX_EMPTY_F_Pos)     /*!< SC TRSR: RX_EMPTY_F Mask */
S
S#define SC_TRSR_RX_OVER_F_Pos               0                                   /*!< SC TRSR: RX_OVER_F Position */
S#define SC_TRSR_RX_OVER_F_Msk               (1ul << SC_TRSR_RX_OVER_F_Pos)      /*!< SC TRSR: RX_OVER_F Mask */
S
S/* SC PINCSR Bit Field Definitions */
S#define SC_PINCSR_SC_DATA_I_ST_Pos          16                                  /*!< SC PINCSR: SC_DATA_I_ST Position */
S#define SC_PINCSR_SC_DATA_I_ST_Msk          (1ul << SC_PINCSR_SC_DATA_I_ST_Pos) /*!< SC PINCSR: SC_DATA_I_ST Mask */
S
S#define SC_PINCSR_POW_INV_Pos               11                                  /*!< SC PINCSR: POW_INV Position */
S#define SC_PINCSR_POW_INV_Msk               (1ul << SC_PINCSR_POW_INV_Pos)      /*!< SC PINCSR: POW_INV Mask */
S
S#define SC_PINCSR_CD_LEV_Pos                10                                  /*!< SC PINCSR: CD_LEV Position */
S#define SC_PINCSR_CD_LEV_Msk                (1ul << SC_PINCSR_CD_LEV_Pos)       /*!< SC PINCSR: CD_LEV Mask */
S
S#define SC_PINCSR_SC_DATA_O_Pos             9                                   /*!< SC PINCSR: SC_DATA_O Position */
S#define SC_PINCSR_SC_DATA_O_Msk             (1ul << SC_PINCSR_SC_DATA_O_Pos)    /*!< SC PINCSR: SC_DATA_O Mask */
S
S#define SC_PINCSR_SC_OEN_ST_Pos             8                                   /*!< SC PINCSR: SC_OEN_ST Position */
S#define SC_PINCSR_SC_OEN_ST_Msk             (1ul << SC_PINCSR_SC_OEN_ST_Pos)    /*!< SC PINCSR: SC_OEN_ST Mask */
S
S#define SC_PINCSR_ADAC_CD_EN_Pos            7                                   /*!< SC PINCSR: ADAC_CD_EN Position */
S#define SC_PINCSR_ADAC_CD_EN_Msk            (1ul << SC_PINCSR_ADAC_CD_EN_Pos)   /*!< SC PINCSR: ADAC_CD_EN Mask */
S
S#define SC_PINCSR_CLK_KEEP_Pos              6                                   /*!< SC PINCSR: CLK_KEEP Position */
S#define SC_PINCSR_CLK_KEEP_Msk              (1ul << SC_PINCSR_CLK_KEEP_Pos)     /*!< SC PINCSR: CLK_KEEP Mask */
S
S#define SC_PINCSR_CLK_STOP_LEV_Pos          5                                   /*!< SC PINCSR: CLK_STOP_LEV Position */
S#define SC_PINCSR_CLK_STOP_LEV_Msk          (1ul << SC_PINCSR_CLK_STOP_LEV_Pos) /*!< SC PINCSR: CLK_STOP_LEV Mask */
S
S#define SC_PINCSR_CD_PIN_ST_Pos             4                                   /*!< SC PINCSR: CD_PIN_ST Position */
S#define SC_PINCSR_CD_PIN_ST_Msk             (1ul << SC_PINCSR_CD_PIN_ST_Pos)    /*!< SC PINCSR: CD_PIN_ST Mask */
S
S#define SC_PINCSR_CD_INS_F_Pos              3                                   /*!< SC PINCSR: CD_INS_F Position */
S#define SC_PINCSR_CD_INS_F_Msk              (1ul << SC_PINCSR_CD_INS_F_Pos)     /*!< SC PINCSR: CD_INS_F Mask */
S
S#define SC_PINCSR_CD_REM_F_Pos              2                                   /*!< SC PINCSR: CD_REM_F Position */
S#define SC_PINCSR_CD_REM_F_Msk              (1ul << SC_PINCSR_CD_REM_F_Pos)     /*!< SC PINCSR: CD_REM_F Mask */
S
S#define SC_PINCSR_SC_RST_Pos                1                                   /*!< SC PINCSR: SC_RST Position */
S#define SC_PINCSR_SC_RST_Msk                (1ul << SC_PINCSR_SC_RST_Pos)       /*!< SC PINCSR: SC_RST Mask */
S
S#define SC_PINCSR_POW_EN_Pos                0                                   /*!< SC PINCSR: POW_EN Position */
S#define SC_PINCSR_POW_EN_Msk                (1ul << SC_PINCSR_POW_EN_Pos)       /*!< SC PINCSR: POW_EN Mask */
S
S/* SC TMR0 Bit Field Definitions */
S#define SC_TMR0_MODE_Pos                    24                              /*!< SC TMR0: MODE Position */
S#define SC_TMR0_MODE_Msk                    (0xFul << SC_TMR0_MODE_Pos)     /*!< SC TMR0: MODE Mask */
S
S#define SC_TMR0_CNT_Pos                     0                               /*!< SC TMR0: CNT Position */
S#define SC_TMR0_CNT_Msk                     (0xFFFFFFul << SC_TMR0_CNT_Pos) /*!< SC TMR0: CNT Mask */
S
S/* SC TMR1 Bit Field Definitions */
S#define SC_TMR1_MODE_Pos                    24                              /*!< SC TMR1: MODE Position */
S#define SC_TMR1_MODE_Msk                    (0xFul << SC_TMR1_MODE_Pos)     /*!< SC TMR1: MODE Mask */
S
S#define SC_TMR1_CNT_Pos                     0                               /*!< SC TMR1: CNT Position */
S#define SC_TMR1_CNT_Msk                     (0xFFul << SC_TMR1_CNT_Pos)     /*!< SC TMR1: CNT Mask */
S
S/* SC TMR2 Bit Field Definitions */
S#define SC_TMR2_MODE_Pos                    24                              /*!< SC TMR2: MODE Position */
S#define SC_TMR2_MODE_Msk                    (0xFul << SC_TMR2_MODE_Pos)     /*!< SC TMR2: MODE Mask */
S
S#define SC_TMR2_CNT_Pos                     0                               /*!< SC TMR2: CNT Position */
S#define SC_TMR2_CNT_Msk                     (0xFFul << SC_TMR2_CNT_Pos)     /*!< SC TMR2: CNT Mask */
S
S/* SC TDRA Bit Field Definitions */
S#define SC_TDRA_TDR0_Pos                    0                                   /*!< SC TDRA: TDR0 Position */
S#define SC_TDRA_TDR0_Msk                    (0xFFFFFFul << SC_TDRA_TDR0_Pos)    /*!< SC TDRA: TDR0 Mask */
S
S/* SC TDRB Bit Field Definitions */
S#define SC_TDRB_TDR2_Pos                    8                               /*!< SC TDRB: TDR2 Position */
S#define SC_TDRB_TDR2_Msk                    (0xFFul << SC_TDRB_TDR2_Pos)    /*!< SC TDRB: TDR2 Mask */
S
S#define SC_TDRB_TDR1_Pos                    0                               /*!< SC TDRB: TDR1 Position */
S#define SC_TDRB_TDR1_Msk                    (0xFFul << SC_TDRB_TDR1_Pos)    /*!< SC TDRB: TDR1 Mask */
S
S
S/*@}*/ /* end of group NUC200_SMARTCARD */
S/*@}*/ /* end of group NUC200 */
S
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup NUC200_PERIPHERAL_MEM_MAP NUC200 Peripheral Memory Map
S  Memory Mapped Structure for NUC200 Series Peripheral
S  @{
S */
S/* Peripheral and SRAM base address */
S#define FLASH_BASE          ((     uint32_t)0x00000000)
S#define SRAM_BASE           ((     uint32_t)0x20000000)
S#define AHB_BASE            ((     uint32_t)0x50000000)
S#define APB1_BASE           ((     uint32_t)0x40000000)
S#define APB2_BASE           ((     uint32_t)0x40100000)
S
S/* Peripheral memory map */
S#define GPIO_BASE           (AHB_BASE        + 0x4000)                   /*!< GPIO Base Address                                   */
S#define PA_BASE             (GPIO_BASE               )                   /*!< GPIO PORTA Base Address                             */  
S#define PB_BASE             (GPIO_BASE       + 0x0040)                   /*!< GPIO PORTB Base Address                             */
S#define PC_BASE             (GPIO_BASE       + 0x0080)                   /*!< GPIO PORTC Base Address                             */
S#define PD_BASE             (GPIO_BASE       + 0x00C0)                   /*!< GPIO PORTD Base Address                             */
S#define PE_BASE             (GPIO_BASE       + 0x0100)                   /*!< GPIO PORTE Base Address                             */
S#define PF_BASE             (GPIO_BASE       + 0x0140)                   /*!< GPIO PORTF Base Address                             */
S#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
S#define GPIO_PIN_DATA_BASE  (GPIO_BASE       + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
S
S
S#define UART0_BASE           (APB1_BASE      + 0x50000)
S#define UART1_BASE           (APB2_BASE      + 0x50000)
S#define UART2_BASE           (APB2_BASE      + 0x54000)
S
S
S#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
S#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
S#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
S#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
S
S#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watchdog Timer Base Address                      */
S
S#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watchdog Timer Base Address               */
S
S#define SPI0_BASE            (APB1_BASE      + 0x30000)
S#define SPI1_BASE            (APB1_BASE      + 0x34000)
S#define SPI2_BASE            (APB2_BASE      + 0x30000)
S#define SPI3_BASE            (APB2_BASE      + 0x34000)
S
S#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
S#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
S
S#define RTC_BASE             (APB1_BASE      + 0x08000)                 /*!< RTC Base Address                                 */
S
S#define ADC_BASE             (APB1_BASE      + 0xE0000)
S
S#define ACMP_BASE            (APB1_BASE      + 0xD0000)   
S
S#define SYSCLK_BASE          (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
S
S#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
S
S#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
S
S#define FMC_BASE             (AHB_BASE       + 0x0C000)
S
S#define PS2_BASE             (APB2_BASE      + 0x00000)					/*!< PS/2 Base Address                                 */
S
S#define CAN0_BASE            (APB2_BASE      + 0x80000)
S#define CAN1_BASE            (APB2_BASE      + 0x84000)
S#define C_CAN_BASE           (APB2_BASE      + 0x88000)
S
S#define USBD_BASE            (APB1_BASE      + 0x60000)
S
S#define PDMA0_BASE           (AHB_BASE       + 0x08000)                 /*!< PDMA0 Base Address                               */
S#define PDMA1_BASE           (AHB_BASE       + 0x08100)                 /*!< PDMA1 Base Address                               */
S#define PDMA2_BASE           (AHB_BASE       + 0x08200)                 /*!< PDMA2 Base Address                               */
S#define PDMA3_BASE           (AHB_BASE       + 0x08300)                 /*!< PDMA3 Base Address                               */
S#define PDMA4_BASE           (AHB_BASE       + 0x08400)                 /*!< PDMA4 Base Address                               */
S#define PDMA5_BASE           (AHB_BASE       + 0x08500)                 /*!< PDMA5 Base Address                               */
S#define PDMA6_BASE           (AHB_BASE       + 0x08600)                 /*!< PDMA6 Base Address                               */
S#define PDMA7_BASE           (AHB_BASE       + 0x08700)                 /*!< PDMA7 Base Address                               */
S#define PDMA8_BASE           (AHB_BASE       + 0x08800)                 /*!< PDMA8 Base Address                               */
S
S#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)                 /*!< PDMA Grobal Base Address                               */
S
S#define CRC_BASE             (AHB_BASE       + 0x08E00)                 /*!< CRC Base Address                                 */
S
S#define PWMA_BASE            (APB1_BASE      + 0x40000)                 /*!< PWMA Base Address                                */
S#define PWMB_BASE            (APB2_BASE      + 0x40000)                 /*!< PWMB Base Address                                */
S
S#define SC0_BASE             (APB2_BASE      + 0x90000)                 /*!< SC0 Base Address                                */
S#define SC1_BASE             (APB2_BASE      + 0x94000)                 /*!< SC1 Base Address                               */
S#define SC2_BASE             (APB2_BASE      + 0x98000)                 /*!< SC2 Base Address                               */
S
S#define I2S_BASE             (APB2_BASE      + 0xA0000)
S
S/*@}*/ /* end of group NUC200_PERIPHERAL_MEM_MAP */
S
S/******************************************************************************/
S/*                         Peripheral Definitions                             */
S/******************************************************************************/
S
S/** @addtogroup NUC200_PERIPHERAL NUC200 Peripheral Definitions
S  The Definitions of NUC200 Series Peripheral
S  @{
S */
S#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
S#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
S#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
S#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
S#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
S#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
S#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */ 
S
S#define UART0               ((UART_T *) UART0_BASE)
S#define UART1               ((UART_T *) UART1_BASE)
S#define UART2               ((UART_T *) UART2_BASE)
S
S#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< Timer0 Configuration Struct                      */
S#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< Timer1 Configuration Struct                      */
S#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< Timer2 Configuration Struct                      */
S#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< Timer3 Configuration Struct                      */
S
S#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watchdog Timer Configuration Struct              */
S
S#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watchdog Timer Configuration Struct       */
S
S#define SPI0                ((SPI_T *) SPI0_BASE)
S#define SPI1                ((SPI_T *) SPI1_BASE)
S#define SPI2                ((SPI_T *) SPI2_BASE)
S#define SPI3                ((SPI_T *) SPI3_BASE)
S
S#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
S#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
S
S#define I2S                 ((I2S_T *) I2S_BASE)
S
S#define RTC                 ((RTC_T *) RTC_BASE)                        /*!< RTC Configuration Struct                         */
S
S#define ADC                 ((ADC_T *) ADC_BASE)
S
S#define ACMP                ((ACMP_T *) ACMP_BASE)
S
S#define SYSCLK              ((SYSCLK_T *) SYSCLK_BASE)                  /*!< System Clock Controller Configuration Struct     */
S
S#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
S
S#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
S
S#define FMC                 ((FMC_T *) FMC_BASE)
S
S#define PS2                 ((PS2_T *) PS2_BASE)						/*!< PS/2 Configuration Struct                        */
S
S#define CAN                 ((CAN_T *) CAN0_BASE)
S#define CAN0                ((CAN_T *) CAN0_BASE)
S#define CAN1                ((CAN_T *) CAN1_BASE)
S
S#define USBD                ((USBD_T *) USBD_BASE)
S
S#define PDMA0               ((PDMA_T *) PDMA0_BASE)                     /*!< PDMA0 Configuration Struct                       */
S#define PDMA1               ((PDMA_T *) PDMA1_BASE)                     /*!< PDMA1 Configuration Struct                       */
S#define PDMA2               ((PDMA_T *) PDMA2_BASE)                     /*!< PDMA2 Configuration Struct                       */
S#define PDMA3               ((PDMA_T *) PDMA3_BASE)                     /*!< PDMA3 Configuration Struct                       */
S#define PDMA4               ((PDMA_T *) PDMA4_BASE)                     /*!< PDMA4 Configuration Struct                       */
S#define PDMA5               ((PDMA_T *) PDMA5_BASE)                     /*!< PDMA5 Configuration Struct                       */
S#define PDMA6               ((PDMA_T *) PDMA6_BASE)                     /*!< PDMA6 Configuration Struct                       */
S#define PDMA7               ((PDMA_T *) PDMA7_BASE)                     /*!< PDMA7 Configuration Struct                       */
S#define PDMA8               ((PDMA_T *) PDMA8_BASE)                     /*!< PDMA8 Configuration Struct                       */
S
S#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)              /*!< PDMA Global Configuration Struct                 */
S
S#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
S
S#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
S#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
S
S#define SC0                 ((SC_T *) SC0_BASE)                         /*!< SC0 Configuration Struct                        */
S#define SC1                 ((SC_T *) SC1_BASE)                         /*!< SC1 Configuration Struct                        */
S#define SC2                 ((SC_T *) SC2_BASE)                         /*!< SC2 Configuration Struct                        */
S
S/*@}*/ /* end of group NUC200_PERIPHERAL */
S
S#define UNLOCKREG(x)        do{*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88}while(*((__IO uint32_t *)(GCR_BASE + 0x100))==0)
S#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00;     
S
S#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
S#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
S
S//=============================================================================
Stypedef volatile unsigned char  vu8;
Stypedef volatile unsigned long  vu32;
Stypedef volatile unsigned short vu16;
S#define M8(adr)  (*((vu8  *) (adr)))
S#define M16(adr) (*((vu16 *) (adr)))
S#define M32(adr) (*((vu32 *) (adr)))
S
S#define outpw(port,value)   *((volatile unsigned int *)(port))=(value)
S#define inpw(port)          (*((volatile unsigned int *)(port)))
S#define outpb(port,value)   *((volatile unsigned char *)(port))=(value)
S#define inpb(port)          (*((volatile unsigned char *)(port)))
S#define outps(port,value)   *((volatile unsigned short *)(port))=(value)
S#define inps(port)          (*((volatile unsigned short *)(port)))
S
S#define outp32(port,value)  *((volatile unsigned int *)(port))=(value)
S#define inp32(port)         (*((volatile unsigned int *)(port)))
S#define outp8(port,value)   *((volatile unsigned char *)(port))=(value)
S#define inp8(port)          (*((volatile unsigned char *)(port)))
S#define outp16(port,value)  *((volatile unsigned short *)(port))=(value)
S#define inp16(port)         (*((volatile unsigned short *)(port)))
S
S
S#define E_SUCCESS   0
S#ifndef NULL
S#define NULL        0
S#endif
S
S#define TRUE        1
S#define FALSE       0
S
S#define ENABLE     1
S#define DISABLE    0
S
S/* Define one bit mask */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S
S/******************************************************************************/
S/*                         Peripheral header files                            */
S/******************************************************************************/ 
S#include "SYS.h"
S#include "ADC.h"
S#include "FMC.h"
S#include "GPIO.h"
S#include "I2C.h"
S#include "PWM.h"
S#include "SPI.h"
S#include "TIMER.h"
S#include "WDT.h"
S#include "RTC.h"
S#include "UART.h"
S#include "I2S.h"
S#include "USB.h"
S#include "PDMA.h"
S#include "SC.h"
S#include "PS2.h"
N#endif
N                                                                                                 
L 16 "..\..\LibNUC200Series\StdDriver\inc\SYS.h" 2
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup SYS_FUNC SYS Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCON constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_PLLCON_FIN_IRC22M   0x00080000UL        /*!< For PLL clock source is internal RC clock. 4MHz < FIN < 24MHz */ 
N#define SYSCLK_PLLCON_FIN_XTAL     0x00000000UL        /*!< For PLL clock source is external cristal.  4MHz < FIN < 24MHz */
N
N#define SYSCLK_PLLCON_NR(x)        (((x)-2)<<9)        /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 15MHz */
N#define SYSCLK_PLLCON_NF(x)         ((x)-2)            /*!< x must be constant and 2 <= x <= 513. 100MHz < FIN*NF/NR < 200MHz. (120MHz < FIN*NF/NR < 200MHz is preferred.) */ 
N 
N#define SYSCLK_PLLCON_NO_1         0x0000UL            /*!< For output divider is 1 */
N#define SYSCLK_PLLCON_NO_2         0x4000UL            /*!< For output divider is 2 */
N#define SYSCLK_PLLCON_NO_4         0xC000UL            /*!< For output divider is 4 */
N
N#if (__XTAL == 12000000)
X#if ((12000000UL) == 12000000)
N#define SYSCLK_PLLCON_FOR_I2S      (0xA54)                                                                                     /*!< Predefined PLLCON setting for 147428571.428571Hz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_50MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(3) | SYSCLK_PLLCON_NF( 25) | SYSCLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_48MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(7) | SYSCLK_PLLCON_NF(112) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_36MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(7) | SYSCLK_PLLCON_NF( 84) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 36MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_32MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(6) | SYSCLK_PLLCON_NF( 64) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 32MHz PLL output with 12MHz X'tal */
N#define SYSCLK_PLLCON_24MHz_XTAL   (SYSCLK_PLLCON_FIN_XTAL | SYSCLK_PLLCON_NR(2) | SYSCLK_PLLCON_NF( 16) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 24MHz PLL output with 12MHz X'tal */
N#else
S# error "The PLL pre-definitions are only valid when external crystal is 12MHz"
N#endif
N
N#define SYSCLK_PLLCON_50MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR(13) | SYSCLK_PLLCON_NF( 59) | SYSCLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50.1918MHz PLL output with 22.1184MHz IRC */
N#define SYSCLK_PLLCON_48MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR(13) | SYSCLK_PLLCON_NF(113) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48.064985MHz PLL output with 22.1184MHz IRC*/
N#define SYSCLK_PLLCON_36MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR(12) | SYSCLK_PLLCON_NF( 78) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 35.9424MHz PLL output with 22.1184MHz IRC */
N#define SYSCLK_PLLCON_32MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR( 9) | SYSCLK_PLLCON_NF( 52) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 31.9488MHz PLL output with 22.1184MHz IRC*/
N#define SYSCLK_PLLCON_24MHz_IRC22M (SYSCLK_PLLCON_FIN_IRC22M | SYSCLK_PLLCON_NR( 3) | SYSCLK_PLLCON_NF( 13) | SYSCLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 23.9616MHz PLL output with 22.1184MHz IRC*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKSEL0_HCLK_XTAL          0x00UL /*!< Setting clock source as external X'tal */ 
N#define SYSCLK_CLKSEL0_HCLK_XTAL32K       0x01UL /*!< Setting clock source as external X'tal 32.768KHz*/ 
N#define SYSCLK_CLKSEL0_HCLK_PLL           0x02UL /*!< Setting clock source as PLL output */
N#define SYSCLK_CLKSEL0_HCLK_IRC10K        0x03UL /*!< Setting clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL0_HCLK_IRC22M        0x07UL /*!< Setting clock source as internal 22.1184MHz RC clock */
N
N#define SYSCLK_CLKSEL0_STCLK_XTAL         0x00UL    /*!< Setting clock source as external X'tal */ 
N#define SYSCLK_CLKSEL0_STCLK_XTAL32K      (1UL<<3)  /*!< Setting clock source as external X'tal 32.768KHz*/ 
N#define SYSCLK_CLKSEL0_STCLK_XTAL_DIV2    (2UL<<3)  /*!< Setting clock source as external X'tal/2 */
N#define SYSCLK_CLKSEL0_STCLK_HCLK_DIV2    (3UL<<3)  /*!< Setting clock source as HCLK/2 */
N#define SYSCLK_CLKSEL0_STCLK_IRC22M_DIV2  (7UL<<3)  /*!< Setting clock source as internal 22.1184MHz RC clock/2 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKSEL1_WDT_XTAL32K       (1UL<<0)       /*!< Setting WDT clock source as external X'tal 32.768KHz*/ 
N#define SYSCLK_CLKSEL1_WDT_HCLK_DIV2048  (2UL<<0)       /*!< Setting WDT clock source as HCLK/2048 */
N#define SYSCLK_CLKSEL1_WDT_IRC10K        (3UL<<0)       /*!< Setting WDT clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL1_ADC_XTAL          0x00000000UL   /*!< Setting ADC clock source as external X'tal */
N#define SYSCLK_CLKSEL1_ADC_PLL           (1UL<<2)       /*!< Setting ADC clock source as PLL */ 
N#define SYSCLK_CLKSEL1_ADC_HCLK          (2UL<<2)       /*!< Setting ADC clock source as HCLK */
N#define SYSCLK_CLKSEL1_ADC_IRC22M        (3UL<<2)       /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_SPI0_PLL          0x00000000UL   /*!< Setting SPI0 clock source as PLL */ 
N#define SYSCLK_CLKSEL1_SPI0_HCLK         (1UL<<4)       /*!< Setting SPI0 clock source as HCLK */
N#define SYSCLK_CLKSEL1_SPI1_PLL          0x00000000UL   /*!< Setting SPI1 clock source as PLL */ 
N#define SYSCLK_CLKSEL1_SPI1_HCLK         (1UL<<5)       /*!< Setting SPI1 clock source as HCLK */
N#define SYSCLK_CLKSEL1_SPI2_PLL          0x00000000UL   /*!< Setting SPI2 clock source as PLL */ 
N#define SYSCLK_CLKSEL1_SPI2_HCLK         (1UL<<6)       /*!< Setting SPI2 clock source as HCLK */
N#define SYSCLK_CLKSEL1_SPI3_PLL          0x00000000UL   /*!< Setting SPI3 clock source as PLL */ 
N#define SYSCLK_CLKSEL1_SPI3_HCLK         (1UL<<7)       /*!< Setting SPI3 clock source as HCLK */
N
N#define SYSCLK_CLKSEL1_TMR0_XTAL         0x00000000UL   /*!< Setting Timer 0 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR0_XTAL32K      (1UL<<8)       /*!< Setting Timer 0 clock source as external X'tal 32.768KHz */
N#define SYSCLK_CLKSEL1_TMR0_HCLK         (2UL<<8)       /*!< Setting Timer 0 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR0_EXT_TRG      (3UL<<8)       /*!< Setting Timer 0 clock source as external trigger */
N#define SYSCLK_CLKSEL1_TMR0_IRC10K       (5UL<<8)       /*!< Setting Timer 0 clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL1_TMR0_IRC22M       (7UL<<8)       /*!< Setting Timer 0 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_TMR1_XTAL         0x00000000UL   /*!< Setting Timer 1 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR1_XTAL32K      (1UL<<12)      /*!< Setting Timer 1 clock source as external X'tal 32.768KHz */
N#define SYSCLK_CLKSEL1_TMR1_HCLK         (2UL<<12)      /*!< Setting Timer 1 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR1_EXT_TRG      (3UL<<12)      /*!< Setting Timer 1 clock source as external trigger */
N#define SYSCLK_CLKSEL1_TMR1_IRC10K       (5UL<<12)      /*!< Setting Timer 1 clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL1_TMR1_IRC22M       (7UL<<12)      /*!< Setting Timer 1 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_TMR2_XTAL         0x00000000UL   /*!< Setting Timer 2 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR2_XTAL32K      (1UL<<16)      /*!< Setting Timer 2 clock source as external X'tal 32.768KHz */
N#define SYSCLK_CLKSEL1_TMR2_HCLK         (2UL<<16)      /*!< Setting Timer 2 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR2_EXT_TRG      (3UL<<16)      /*!< Setting Timer 2 clock source as external trigger */
N#define SYSCLK_CLKSEL1_TMR2_IRC10K       (5UL<<16)      /*!< Setting Timer 2 clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL1_TMR2_IRC22M       (7UL<<16)      /*!< Setting Timer 2 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_TMR3_XTAL         0x00000000UL   /*!< Setting Timer 3 clock source as external X'tal */
N#define SYSCLK_CLKSEL1_TMR3_XTAL32K      (1UL<<20)      /*!< Setting Timer 3 clock source as external X'tal 32.768KHz */
N#define SYSCLK_CLKSEL1_TMR3_HCLK         (2UL<<20)      /*!< Setting Timer 3 clock source as HCLK */
N#define SYSCLK_CLKSEL1_TMR3_EXT_TRG      (3UL<<20)      /*!< Setting Timer 3 clock source as external trigger */
N#define SYSCLK_CLKSEL1_TMR3_IRC10K       (5UL<<20)      /*!< Setting Timer 3 clock source as internal 10KHz RC clock */
N#define SYSCLK_CLKSEL1_TMR3_IRC22M       (7UL<<20)      /*!< Setting Timer 3 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL1_UART_XTAL         0x00000000UL   /*!< Setting UART clock source as external X'tal */
N#define SYSCLK_CLKSEL1_UART_PLL          (1UL<<24)      /*!< Setting UART clock source as external PLL */
N#define SYSCLK_CLKSEL1_UART_IRC22M       (3UL<<24)      /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N
N#define SYSCLK_CLKSEL1_PWM01_XTAL        0x00000000UL   /*!< Setting PWM01 clock source control CLKSEL1[29:28] as external X'tal, 
N                                                             user must set SYSCLK_CLKSEL2_PWM01_EXT_XTAL concurrently to complete clock source as external X'tal setting*/
N#define SYSCLK_CLKSEL1_PWM01_XTAL32K     (1UL<<28)      /*!< Setting PWM01 clock source as external X'tal 32.768KHz,
N                                                             user must set SYSCLK_CLKSEL2_PWM01_EXT_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define SYSCLK_CLKSEL1_PWM01_HCLK        (2UL<<28)      /*!< Setting PWM01 clock source as HCLK 
N                                                             user must set SYSCLK_CLKSEL2_PWM01_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define SYSCLK_CLKSEL1_PWM01_IRC22M      (3UL<<28)      /*!< Setting PWM01 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM01_EXT_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/ 
N#define SYSCLK_CLKSEL1_PWM01_IRC10K      (3UL<<28)      /*!< Setting PWM01 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM01_EXT_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/
N#define SYSCLK_CLKSEL1_PWM23_XTAL        0x00000000UL   /*!< Setting PWM23 clock source as external X'tal,
N                                                             user must set SYSCLK_CLKSEL2_PWM23_EXT_XTAL concurrently to complete clock source as external X'tal setting*/
N#define SYSCLK_CLKSEL1_PWM23_XTAL32K     (1UL<<30)      /*!< Setting PWM23 clock source as external X'tal 32.768KHz,
N                                                             user must set SYSCLK_CLKSEL2_PWM23_EXT_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define SYSCLK_CLKSEL1_PWM23_HCLK        (2UL<<30)      /*!< Setting PWM23 clock source as HCLK,
N                                                             user must set SYSCLK_CLKSEL2_PWM23_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define SYSCLK_CLKSEL1_PWM23_IRC22M      (3UL<<30)      /*!< Setting PWM23 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM23_EXT_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define SYSCLK_CLKSEL1_PWM23_IRC10K      (3UL<<30)      /*!< Setting PWM23 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM23_EXT_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKSEL2_I2S_XTAL           0x00000000UL  /*!< Setting I2S clock source as external X'tal */ 
N#define SYSCLK_CLKSEL2_I2S_PLL            (1UL<<0)      /*!< Setting I2S clock source as PLL */
N#define SYSCLK_CLKSEL2_I2S_HCLK           (2UL<<0)      /*!< Setting I2S clock source as HCLK */
N#define SYSCLK_CLKSEL2_I2S_IRC22M         (3UL<<0)      /*!< Setting I2S clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL2_FRQDIV_XTAL        0x00000000UL  /*!< Setting FRQDIV clock source as external X'tal */ 
N#define SYSCLK_CLKSEL2_FRQDIV_XTAL32K     (1UL<<2)      /*!< Setting FRQDIV clock source as external X'tal 32.768KHz */ 
N#define SYSCLK_CLKSEL2_FRQDIV_HCLK        (2UL<<2)      /*!< Setting FRQDIV clock source as HCLK */
N#define SYSCLK_CLKSEL2_FRQDIV_IRC22M      (3UL<<2)      /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N
N#define SYSCLK_CLKSEL2_PWM45_XTAL         0x00000000UL  /*!< Setting PWM45 clock source as external X'tal,
N                                                             user must set SYSCLK_CLKSEL2_PWM45_EXT_XTAL concurrently to complete clock source as external X'tal setting*/ 
N#define SYSCLK_CLKSEL2_PWM45_XTAL32K      (1UL<<4)      /*!< Setting PWM45 clock source as external X'tal 32.768KHz,
N                                                             user must set SYSCLK_CLKSEL2_PWM45_EXT_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define SYSCLK_CLKSEL2_PWM45_HCLK         (2UL<<4)      /*!< Setting PWM45 clock source as HCLK,
N                                                             user must set SYSCLK_CLKSEL2_PWM45_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define SYSCLK_CLKSEL2_PWM45_IRC22M       (3UL<<4)      /*!< Setting PWM45 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM45_EXT_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define SYSCLK_CLKSEL2_PWM45_IRC10K       (3UL<<4)      /*!< Setting PWM45 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM45_EXT_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/
N#define SYSCLK_CLKSEL2_PWM67_XTAL         0x00000000UL  /*!< Setting PWM67 clock source as external X'tal,
N                                                             user must set SYSCLK_CLKSEL2_PWM67_EXT_XTAL concurrently to complete clock source as external X'tal setting*/ 
N#define SYSCLK_CLKSEL2_PWM67_XTAL32K      (1UL<<6)      /*!< Setting PWM67 clock source as external X'tal 32.768KHz,
N                                                             user must set SYSCLK_CLKSEL2_PWM67_EXT_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/ 
N#define SYSCLK_CLKSEL2_PWM67_HCLK         (2UL<<6)      /*!< Setting PWM67 clock source as HCLK,
N                                                             user must set SYSCLK_CLKSEL2_PWM67_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define SYSCLK_CLKSEL2_PWM67_IRC22M       (3UL<<6)      /*!< Setting PWM67 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM67_EXT_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define SYSCLK_CLKSEL2_PWM67_IRC10K       (3UL<<6)      /*!< Setting PWM67 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL2_PWM67_EXT_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define SYSCLK_CLKSEL2_PWM01_EXT_XTAL     0x00000000UL  /*!< Setting PWM01 clock source as external X'tal,
N                                                             user must set SYSCLK_CLKSEL1_PWM01_XTAL concurrently to complete clock source as external X'tal setting*/ 
N#define SYSCLK_CLKSEL2_PWM01_EXT_XTAL32K  0x00000000UL  /*!< Setting PWM01 clock source as external X'tal  32.768KHz,
N                                                             user must set SYSCLK_CLKSEL1_PWM01_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/ 
N#define SYSCLK_CLKSEL2_PWM01_EXT_HCLK     0x00000000UL  /*!< Setting PWM01 clock source as HCLK,
N                                                             user must set SYSCLK_CLKSEL1_PWM01_HCLK concurrently to complete clock source as HCLK setting*/ 
N#define SYSCLK_CLKSEL2_PWM01_EXT_IRC22M   0x00000000UL  /*!< Setting PWM01 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM01_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/ 
N#define SYSCLK_CLKSEL2_PWM01_EXT_IRC10K   (1UL<<8)      /*!< Setting PWM01 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM01_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/ 
N
N#define SYSCLK_CLKSEL2_PWM23_EXT_XTAL     0x00000000UL  /*!< Setting PWM23 clock source as external X'tal,
N                                                             user must set SYSCLK_CLKSEL1_PWM23_XTAL concurrently to complete clock source as external X'tal setting*/ 
N#define SYSCLK_CLKSEL2_PWM23_EXT_XTAL32K  0x00000000UL  /*!< Setting PWM23 clock source as external X'tal  32.768KHz,
N                                                             user must set SYSCLK_CLKSEL1_PWM23_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/ 
N#define SYSCLK_CLKSEL2_PWM23_EXT_HCLK     0x00000000UL  /*!< Setting PWM23 clock source as HCLK,
N                                                             user must set SYSCLK_CLKSEL1_PWM23_HCLK concurrently to complete clock source as HCLK setting*/ 
N#define SYSCLK_CLKSEL2_PWM23_EXT_IRC22M   0x00000000UL  /*!< Setting PWM23 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM23_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/  
N#define SYSCLK_CLKSEL2_PWM23_EXT_IRC10K   (1UL<<9)      /*!< Setting PWM23 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM23_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/ 
N
N#define SYSCLK_CLKSEL2_PWM45_EXT_XTAL     0x00000000UL  /*!< Setting PWM45 clock source as external X'tal,
N                                                             user must set SYSCLK_CLKSEL1_PWM45_XTAL concurrently to complete clock source as external X'tal setting*/ 
N#define SYSCLK_CLKSEL2_PWM45_EXT_XTAL32K  0x00000000UL  /*!< Setting PWM45 clock source as external X'tal  32.768KHz,
N                                                             user must set SYSCLK_CLKSEL1_PWM45_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/  
N#define SYSCLK_CLKSEL2_PWM45_EXT_HCLK     0x00000000UL  /*!< Setting PWM45 clock source as HCLK,
N                                                             user must set SYSCLK_CLKSEL1_PWM45_HCLK concurrently to complete clock source as HCLK setting*/ 
N#define SYSCLK_CLKSEL2_PWM45_EXT_IRC22M   0x00000000UL  /*!< Setting PWM45 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM45_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/   
N#define SYSCLK_CLKSEL2_PWM45_EXT_IRC10K   (1UL<<10)     /*!< Setting PWM45 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM45_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/ 
N
N#define SYSCLK_CLKSEL2_PWM67_EXT_XTAL     0x00000000UL  /*!< Setting PWM67 clock source as external X'tal,
N                                                             user must set SYSCLK_CLKSEL1_PWM67_XTAL concurrently to complete clock source as external X'tal setting*/ 
N#define SYSCLK_CLKSEL2_PWM67_EXT_XTAL32K  0x00000000UL  /*!< Setting PWM67 clock source as external X'tal  32.768KHz,
N                                                             user must set SYSCLK_CLKSEL1_PWM67_XTAL32K concurrently to complete clock source as external X'tal 32.768KHz setting*/ 
N#define SYSCLK_CLKSEL2_PWM67_EXT_HCLK     0x00000000UL  /*!< Setting PWM67 clock source as HCLK,
N                                                             user must set SYSCLK_CLKSEL1_PWM67_HCLK concurrently to complete clock source as HCLK setting*/ 
N#define SYSCLK_CLKSEL2_PWM67_EXT_IRC22M   0x00000000UL  /*!< Setting PWM67 clock source as internal 22.1184MHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM67_IRC22M concurrently to complete clock source as internal 22.1184MHz RC clock setting*/     
N#define SYSCLK_CLKSEL2_PWM67_EXT_IRC10K   (1UL<<11)     /*!< Setting PWM67 clock source as internal 10KHz RC clock,
N                                                             user must set SYSCLK_CLKSEL1_PWM67_IRC10K concurrently to complete clock source as internal 10KHz RC clock setting*/         
N
N#define SYSCLK_CLKSEL2_WWDT_HCLK_DIV2048   (2UL<<16)    /*!< Setting Window Watchdog Timer clock source as external X'tal */ 
N#define SYSCLK_CLKSEL2_WWDT_IRC10K         (3UL<<16)    /*!< Setting Window Watchdog Timer clock source as internal 10KHz RC clock */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL3 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKSEL3_SC0_XTAL           0x00000000UL  /*!< Setting SC0 clock source as external X'tal */ 
N#define SYSCLK_CLKSEL3_SC0_PLL            (1UL<<0)      /*!< Setting SC0 clock source as PLL */
N#define SYSCLK_CLKSEL3_SC0_HCLK           (2UL<<0)      /*!< Setting SC0 clock source as HCLK */
N#define SYSCLK_CLKSEL3_SC0_IRC22M         (3UL<<0)      /*!< Setting SC0 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL3_SC1_XTAL           0x00000000UL  /*!< Setting SC1 clock source as external X'tal */ 
N#define SYSCLK_CLKSEL3_SC1_PLL            (1UL<<2)      /*!< Setting SC1 clock source as PLL */
N#define SYSCLK_CLKSEL3_SC1_HCLK           (2UL<<2)      /*!< Setting SC1 clock source as HCLK */
N#define SYSCLK_CLKSEL3_SC1_IRC22M         (3UL<<2)      /*!< Setting SC1 clock source as internal 22.1184MHz RC clock */
N#define SYSCLK_CLKSEL3_SC2_XTAL           0x00000000UL  /*!< Setting SC2 clock source as external X'tal */ 
N#define SYSCLK_CLKSEL3_SC2_PLL            (1UL<<4)      /*!< Setting SC2 clock source as PLL */
N#define SYSCLK_CLKSEL3_SC2_HCLK           (2UL<<4)      /*!< Setting SC2 clock source as HCLK */
N#define SYSCLK_CLKSEL3_SC2_IRC22M         (3UL<<4)      /*!< Setting SC2 clock source as internal 22.1184MHz RC clock */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKDIV_HCLK(x)  ((x)-1)        /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */ 
N#define SYSCLK_CLKDIV_USB(x)  (((x)-1) <<  4) /*!< CLKDIV Setting for USB clock divider. It could be 1~16  */ 
N#define SYSCLK_CLKDIV_UART(x) (((x)-1) <<  8) /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */ 
N#define SYSCLK_CLKDIV_ADC(x)  (((x)-1) << 16) /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */ 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYSCLK_CLKDIV1_SC0(x)  ((x)-1)        /*!< CLKDIV1 Setting for SC0 clock divider. It could be 1~256*/ 
N#define SYSCLK_CLKDIV1_SC1(x)  (((x)-1) << 8) /*!< CLKDIV1 Setting for SC1 clock divider. It could be 1~256*/ 
N#define SYSCLK_CLKDIV1_SC2(x)  (((x)-1) << 16)/*!< CLKDIV1 Setting for SC2 clock divider. It could be 1~256*/ 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N//#define SYS_MFP_TYPE_Msk(bit)       (1UL << ((bit) +16))
N//#define SYS_MFP_MFP_Msk(bit)        (1UL << ((bit)    ))
N
N/* How to use below #define?
NExample 1: If user want to set PA.0 as ADC0 and PA1 as ADC1 in initial function, 
N           user can issue following command to achieve it.
N           
N           SYS->GPA_MFP  = SYS_GPA_MFP_PA0_ADC0 | SYS_GPA_MFP_PA1_ADC1;
N           SYS->ALT_MFP1 = SYS_ALT_MFP1_PA0_ADC0| SYS_ALT_MFP1_PA1_ADC1;
N         
NExample 2: If user has set PA.0 as ADC0 in initial function, user want to set PA.1 as ADC1 now. 
N           User can issue following command to achieve PA.1 setting and it will not affect PA.0's setting.
N           _SYS_GPA_MFP_PA1(SYS_GPA_MFP_PA1_ADC1);
N           _SYS_ALT_MFP1_PA1(SYS_ALT_MFP1_PA1_ADC1);                     
N*/
N
N//PA.0
N#define SYS_GPA_MFP_PA0_GPIO    0x00000000UL            /*!< GPA_MFP PA.0 setting for GPIO  */    
N#define SYS_ALT_MFP_PA0_GPIO    NULL                    /*!< No ALT_MFP setting for PA.0    */
N#define SYS_ALT_MFP1_PA0_GPIO   0x00000000UL            /*!< ALT_MFP1 PA.0 setting for GPIO */
N  
N#define SYS_GPA_MFP_PA0_ADC0    (1UL<<0)                /*!< GPA_MFP PA.0 setting for ADC0  */ 
N#define SYS_ALT_MFP_PA0_ADC0    NULL                    /*!< No ALT_MFP setting for PA.0    */
N#define SYS_ALT_MFP1_PA0_ADC0   0x00000000UL            /*!< ALT_MFP1 PA.0 setting for ADC0 */
N
N#define SYS_GPA_MFP_PA0_SC0PWR  (1UL<<0)                /*!< GPA_MFP PA.0 setting for SC0PWR  */  
N#define SYS_ALT_MFP_PA0_SC0PWR  NULL                    /*!< No ALT_MFP setting for PA.0      */
N#define SYS_ALT_MFP1_PA0_SC0PWR (1UL<<2)                /*!< ALT_MFP1 PA.0 setting for SC0PWR */
N
N#define SYS_GPA_MFP_PA0_Msk     (1UL<<0)                /*!< GPA_MFP PA.0 mask             */ 
N#define SYS_ALT_MFP1_PA0_Msk    (1UL<<2)                /*!< ALT_MFP1 PA.0 mask            */            
N
N//PA.1   
N#define SYS_GPA_MFP_PA1_GPIO    0x00000000UL            /*!< GPA_MFP PA.1 setting for GPIO  */    
N#define SYS_ALT_MFP_PA1_GPIO    NULL                    /*!< No ALT_MFP setting for PA.1    */
N#define SYS_ALT_MFP1_PA1_GPIO   0x00000000UL            /*!< ALT_MFP1 PA.1 setting for GPIO */
N    
N#define SYS_GPA_MFP_PA1_ADC1    (1UL<<1)                /*!< GPA_MFP PA.1 setting for ADC1  */    
N#define SYS_ALT_MFP_PA1_ADC1    NULL                    /*!< No ALT_MFP setting for PA.1    */
N#define SYS_ALT_MFP1_PA1_ADC1   0x00000000UL            /*!< ALT_MFP1 PA.1 setting for ADC1 */ 
N
N#define SYS_GPA_MFP_PA1_SC0RST  (1UL<<1)                /*!< GPA_MFP PA.1 setting for SC0RST  */    
N#define SYS_ALT_MFP_PA1_SC0RST  NULL                    /*!< No ALT_MFP setting for PA.1      */
N#define SYS_ALT_MFP1_PA1_SC0RST (1UL<<3)                /*!< ALT_MFP1 PA.1 setting for SC0RST */ 
N 
N#define SYS_GPA_MFP_PA1_Msk     (1UL<<1)                /*!< GPA_MFP PA.1 mask             */      
N#define SYS_ALT_MFP1_PA1_Msk    (1UL<<3)                /*!< ALT_MFP1 PA.1 mask             */ 
N
N//PA.2
N#define SYS_GPA_MFP_PA2_GPIO    0x00000000UL            /*!< GPA_MFP PA.2 setting for GPIO  */    
N#define SYS_ALT_MFP_PA2_GPIO    NULL                    /*!< No ALT_MFP setting for PA.2    */
N#define SYS_ALT_MFP1_PA2_GPIO   0x00000000UL            /*!< ALT_MFP1 PA.2 setting for GPIO */
N
N#define SYS_GPA_MFP_PA2_ADC2    (1UL<<2)                /*!< GPA_MFP PA.2 setting for ADC2  */    
N#define SYS_ALT_MFP_PA2_ADC2    NULL                    /*!< No ALT_MFP setting for PA.2    */
N#define SYS_ALT_MFP1_PA2_ADC2   0x00000000UL            /*!< ALT_MFP1 PA.2 setting for ADC2 */
N
N#define SYS_GPA_MFP_PA2_SC0CLK  (1UL<<2)                /*!< GPA_MFP PA.2 setting for SC0CLK  */    
N#define SYS_ALT_MFP_PA2_SC0CLK  NULL                    /*!< No ALT_MFP setting for PA.2      */
N#define SYS_ALT_MFP1_PA2_SC0CLK (1UL<<0)                /*!< ALT_MFP1 PA.2 setting for SC0CLK */ 
N
N#define SYS_GPA_MFP_PA2_Msk     (1UL<<2)                /*!< GPA_MFP PA.2 mask             */      
N#define SYS_ALT_MFP1_PA2_Msk    (1UL<<0)                /*!< ALT_MFP1 PA.2 mask            */ 
N
N//PA.3   
N#define SYS_GPA_MFP_PA3_GPIO    0x00000000UL            /*!< GPA_MFP PA.3 setting for GPIO  */    
N#define SYS_ALT_MFP_PA3_GPIO    NULL                    /*!< No ALT_MFP setting for PA.3    */
N#define SYS_ALT_MFP1_PA3_GPIO   0x00000000UL            /*!< ALT_MFP1 PA.3 setting for GPIO */
N
N#define SYS_GPA_MFP_PA3_ADC3    (1UL<<3)                /*!< GPA_MFP PA.3 setting for ADC3  */    
N#define SYS_ALT_MFP_PA3_ADC3    NULL                    /*!< No ALT_MFP setting for PA.3    */
N#define SYS_ALT_MFP1_PA3_ADC3   0x00000000UL            /*!< ALT_MFP1 PA.3 setting for ADC3 */
N
N#define SYS_GPA_MFP_PA3_SC0DAT  (1UL<<3)               /*!< GPA_MFP PA.3 setting for SC0DAT  */    
N#define SYS_ALT_MFP_PA3_SC0DAT  NULL                   /*!< No ALT_MFP setting for PA.3      */
N#define SYS_ALT_MFP1_PA3_SC0DAT (1UL<<1)               /*!< ALT_MFP1 PA.3 setting for SC0DAT */ 
N
N#define SYS_GPA_MFP_PA3_Msk     (1UL<<3)                /*!< GPA_MFP PA.3 mask             */      
N#define SYS_ALT_MFP1_PA3_Msk    (1UL<<1)                /*!< ALT_MFP1 PA.3 mask            */ 
N
N//PA.4   
N#define SYS_GPA_MFP_PA4_GPIO    0x00000000UL            /*!< GPA_MFP PA.4 setting for GPIO  */    
N#define SYS_ALT_MFP_PA4_GPIO    NULL                    /*!< No ALT_MFP setting for PA.4    */
N#define SYS_ALT_MFP1_PA4_GPIO   0x00000000UL            /*!< ALT_MFP1 PA.4 setting for GPIO */
N
N#define SYS_GPA_MFP_PA4_ADC4    (1UL<<4)                /*!< GPA_MFP PA.4 setting for ADC4  */    
N#define SYS_ALT_MFP_PA4_ADC4    NULL                    /*!< No ALT_MFP setting for PA.4    */
N#define SYS_ALT_MFP1_PA4_ADC4   0x00000000UL            /*!< ALT_MFP1 PA.4 setting for ADC4 */
N
N#define SYS_GPA_MFP_PA4_SC1PWR  (1UL<<4)               /*!< GPA_MFP PA.4 setting for SC1PWR  */    
N#define SYS_ALT_MFP_PA4_SC1PWR  NULL                   /*!< No ALT_MFP setting for PA.4      */
N#define SYS_ALT_MFP1_PA4_SC1PWR (1UL<<7)               /*!< ALT_MFP1 PA.4 setting for SC1PWR */ 
N
N#define SYS_GPA_MFP_PA4_Msk     (1UL<<4)                /*!< GPA_MFP PA.4 mask             */      
N#define SYS_ALT_MFP1_PA4_Msk    (1UL<<7)                /*!< ALT_MFP1 PA.4 mask            */ 
N
N//PA.5   
N#define SYS_GPA_MFP_PA5_GPIO    0x00000000UL            /*!< GPA_MFP PA.5 setting for GPIO  */    
N#define SYS_ALT_MFP_PA5_GPIO    NULL                    /*!< No ALT_MFP setting for PA.5    */
N#define SYS_ALT_MFP1_PA5_GPIO   0x00000000UL            /*!< ALT_MFP1 PA.5 setting for GPIO */
N
N#define SYS_GPA_MFP_PA5_ADC5    (1UL<<5)                /*!< GPA_MFP PA.5 setting for ADC5  */     
N#define SYS_ALT_MFP_PA5_ADC5    NULL                    /*!< No ALT_MFP setting for PA.5    */
N#define SYS_ALT_MFP1_PA5_ADC5   0x00000000UL            /*!< ALT_MFP1 PA.5 setting for ADC5 */
N
N#define SYS_GPA_MFP_PA5_SC1RST  (1UL<<5)               /*!< GPA_MFP PA.5 setting for SC1RST  */    
N#define SYS_ALT_MFP_PA5_SC1RST  NULL                   /*!< No ALT_MFP setting for PA.5      */
N#define SYS_ALT_MFP1_PA5_SC1RST (1UL<<8)               /*!< ALT_MFP1 PA.5 setting for SC1RST */ 
N
N#define SYS_GPA_MFP_PA5_Msk     (1UL<<5)                /*!< GPA_MFP PA.5 mask             */      
N#define SYS_ALT_MFP1_PA5_Msk    (1UL<<8)                /*!< ALT_MFP1 PA.5 mask            */ 
N
N//PA.6   
N#define SYS_GPA_MFP_PA6_GPIO    0x00000000UL    /*!< GPA_MFP PA.6 setting for GPIO  */    
N#define SYS_ALT_MFP_PA6_GPIO    NULL            /*!< No ALT_MFP setting for PA.6    */
N#define SYS_ALT_MFP1_PA6_GPIO   0x00000000UL    /*!< ALT_MFP1 PA.6 setting for GPIO */
N
N#define SYS_GPA_MFP_PA6_ADC6    (1UL<<6)        /*!< GPA_MFP PA.6 setting for ADC6  */     
N#define SYS_ALT_MFP_PA6_ADC6    NULL            /*!< No ALT_MFP setting for PA.6    */
N#define SYS_ALT_MFP1_PA6_ADC6   0x00000000UL    /*!< ALT_MFP1 PA.6 setting for ADC6 */
N
N#define SYS_GPA_MFP_PA6_SC1CLK  (1UL<<6)        /*!< GPA_MFP PA.6 setting for SC1CLK  */    
N#define SYS_ALT_MFP_PA6_SC1CLK  NULL            /*!< No ALT_MFP setting for PA.6      */
N#define SYS_ALT_MFP1_PA6_SC1CLK (1UL<<5)        /*!< ALT_MFP1 PA.6 setting for SC1CLK */ 
N
N#define SYS_GPA_MFP_PA6_Msk     (1UL<<6)        /*!< GPA_MFP PA.6 mask             */      
N#define SYS_ALT_MFP1_PA6_Msk    (1UL<<5)        /*!< ALT_MFP1 PA.6 mask            */ 
N
N//PA.7   
N#define SYS_GPA_MFP_PA7_GPIO    0x00000000UL        /*!< GPA_MFP PA.7 setting for GPIO  */    
N#define SYS_ALT_MFP_PA7_GPIO    0x00000000UL        /*!< ALT_MFP PA.7 setting for GPIO  */ 
N#define SYS_ALT_MFP1_PA7_GPIO   0x00000000UL        /*!< ALT_MFP1 PA.7 setting for GPIO */
N
N#define SYS_GPA_MFP_PA7_ADC7    (1UL<<7)            /*!< GPA_MFP PA.7 setting for ADC7  */    
N#define SYS_ALT_MFP_PA7_ADC7    0x00000000UL        /*!< ALT_MFP PA.7 setting for ADC7  */ 
N#define SYS_ALT_MFP1_PA7_ADC7   0x00000000UL        /*!< ALT_MFP1 PA.7 setting for ADC7 */
N
N#define SYS_GPA_MFP_PA7_SPISS21     (1UL<<7)        /*!< GPA_MFP PA.7 setting for SPISS21  */    
N#define SYS_ALT_MFP_PA7_SPISS21     (1UL<<2)        /*!< ALT_MFP PA.7 setting for SPISS21  */ 
N#define SYS_ALT_MFP1_PA7_SPISS21    0x00000000UL    /*!< ALT_MFP1 PA.7 setting for SPISS21 */
N
N#define SYS_GPA_MFP_PA7_SC1DAT   (1UL<<7)            /*!< GPA_MFP PA.7 setting for SC1DAT  */    
N#define SYS_ALT_MFP_PA7_SC1DAT   0x00000000UL        /*!< ALT_MFP PA.7 setting for SC1DAT  */ 
N#define SYS_ALT_MFP1_PA7_SC1DAT  (1UL<<6)            /*!< ALT_MFP1 PA.7 setting for SC1DAT */ 
N
N#define SYS_GPA_MFP_PA7_Msk     (1UL<<7)                /*!< GPA_MFP PA.7 mask             */      
N#define SYS_ALT_MFP_PA7_Msk     (1UL<<2)                /*!< ALT_MFP PA.7 mask             */ 
N#define SYS_ALT_MFP1_PA7_Msk    (1UL<<6)                /*!< ALT_MFP1 PA.7 mask            */ 
N
N//PA.8   
N#define SYS_GPA_MFP_PA8_GPIO    0x00000000UL    /*!< GPA_MFP PA.8 setting for GPIO */    
N#define SYS_ALT_MFP_PA8_GPIO    NULL            /*!< No ALT_MFP setting for PA.8   */
N#define SYS_ALT_MFP1_PA8_GPIO   NULL            /*!< No ALT_MFP1 setting for PA.8  */
N
N#define SYS_GPA_MFP_PA8_SDA0    (1UL<<8)        /*!< GPA_MFP PA.8 setting for SDA0 */    
N#define SYS_ALT_MFP_PA8_SDA0    NULL            /*!< No ALT_MFP setting for PA.8   */
N#define SYS_ALT_MFP_PA8_SDA0    NULL            /*!< No ALT_MFP1 setting for PA.8  */
N
N#define SYS_GPA_MFP_PA8_Msk     (1UL<<8)        /*!< GPA_MFP PA.8 mask             */      
N
N//PA.9   
N#define SYS_GPA_MFP_PA9_GPIO    0x00000000UL    /*!< GPA_MFP PA.9 setting for GPIO */    
N#define SYS_ALT_MFP_PA9_GPIO    NULL            /*!< No ALT_MFP setting for PA.9   */
N#define SYS_ALT_MFP1_PA9_GPIO   NULL            /*!< No ALT_MFP1 setting for PA.9  */
N
N#define SYS_GPA_MFP_PA9_SCL0    (1UL<<9)        /*!< GPA_MFP PA.9 setting for SCL0 */    
N#define SYS_ALT_MFP_PA9_SCL0    NULL            /*!< No ALT_MFP setting for PA.9   */
N#define SYS_ALT_MFP1_PA9_SCL0   NULL            /*!< No ALT_MFP1 setting for PA.9  */
N
N#define SYS_GPA_MFP_PA9_Msk     (1UL<<9)        /*!< GPA_MFP PA.9 mask             */ 
N
N//PA.10   
N#define SYS_GPA_MFP_PA10_GPIO    0x00000000UL       /*!< GPA_MFP PA.10 setting for GPIO */    
N#define SYS_ALT_MFP_PA10_GPIO    0x00000000UL       /*!< ALT_MFP PA.10 setting for GPIO */
N#define SYS_ALT_MFP1_PA10_GPIO   NULL               /*!< No ALT_MFP1 setting for PA.10  */
N 
N#define SYS_GPA_MFP_PA10_SDA1    (1UL<<10)          /*!< GPA_MFP PA.10 setting for SDA1 */    
N#define SYS_ALT_MFP_PA10_SDA1    0x00000000UL       /*!< ALT_MFP PA.10 setting for SDA1 */ 
N#define SYS_ALT_MFP1_PA10_SDA1   NULL               /*!< No ALT_MFP1 setting for PA.10  */
N
N#define SYS_GPA_MFP_PA10_CANTX1  (1UL<<10)          /*!< GPA_MFP PA.10 setting for CANTX1 */    
N#define SYS_ALT_MFP_PA10_CANTX1  (1UL<<28)          /*!< ALT_MFP PA.10 setting for CANTX1 */ 
N#define SYS_ALT_MFP1_PA10_CANTX1 NULL               /*!< No ALT_MFP1 setting for PA.10    */
N
N#define SYS_GPA_MFP_PA10_Msk     (1UL<<10)          /*!< GPA_MFP PA.10 mask             */      
N#define SYS_ALT_MFP_PA10_Msk     (1UL<<28)          /*!< ALT_MFP PA.10 mask             */ 
N
N
N//PA.11   
N#define SYS_GPA_MFP_PA11_GPIO    0x00000000UL           /*!< GPA_MFP PA.11 setting for GPIO */    
N#define SYS_ALT_MFP_PA11_GPIO    0x00000000UL           /*!< ALT_MFP PA.11 setting for GPIO */
N#define SYS_ALT_MFP1_PA11_GPIO   NULL                   /*!< No ALT_MFP1 setting for PA.11  */
N
N#define SYS_GPA_MFP_PA11_SCL1    (1UL<<11)              /*!< GPA_MFP PA.11 setting for SCL1 */    
N#define SYS_ALT_MFP_PA11_SCL1    0x00000000UL           /*!< ALT_MFP PA.11 setting for SCL1 */ 
N#define SYS_ALT_MFP1_PA11_SCL1   NULL                   /*!< No ALT_MFP1 setting for PA.11  */
N
N#define SYS_GPA_MFP_PA11_CANRX1  (1UL<<11)              /*!< GPA_MFP PA.11 setting for CANRX1 */    
N#define SYS_ALT_MFP_PA11_CANRX1  (1UL<<28)              /*!< ALT_MFP PA.11 setting for CANRX1 */ 
N#define SYS_ALT_MFP1_PA11_CANRX1 NULL                   /*!< No ALT_MFP1 setting for PA.11    */
N
N#define SYS_GPA_MFP_PA11_Msk     (1UL<<11)              /*!< GPA_MFP PA.11 mask             */      
N#define SYS_ALT_MFP_PA11_Msk     (1UL<<28)              /*!< ALT_MFP PA.11 mask             */ 
N
N
N//PA.12   
N#define SYS_GPA_MFP_PA12_GPIO    0x00000000UL           /*!< GPA_MFP PA.12 setting for GPIO   */    
N#define SYS_ALT_MFP_PA12_GPIO    NULL                   /*!< No ALT_MFP setting for PA.12     */
N#define SYS_ALT_MFP1_PA12_GPIO   0x00000000UL           /*!< ALT_MFP1 PA.12 setting for GPIO  */
N    
N#define SYS_GPA_MFP_PA12_PWM0    (1UL<<12)              /*!< GPA_MFP PA.12 setting for PWM0  */    
N#define SYS_ALT_MFP_PA12_PWM0    NULL                   /*!< No ALT_MFP setting for PA.12    */    
N#define SYS_ALT_MFP1_PA12_PWM0   0x00000000UL           /*!< ALT_MFP1 PA.12 setting for PWM0 */ 
N
N#define SYS_GPA_MFP_PA12_SC2DAT  (1UL<<12)              /*!< GPA_MFP PA.12 setting for SC2DAT  */    
N#define SYS_ALT_MFP_PA12_SC2DAT  NULL                   /*!< No ALT_MFP setting for PA.12      */
N#define SYS_ALT_MFP1_PA12_SC2DAT (1UL<<11)              /*!< ALT_MFP1 PA.12 setting for SC2DAT */ 
N 
N#define SYS_GPA_MFP_PA12_Msk     (1UL<<12)              /*!< GPA_MFP PA.12 mask             */      
N#define SYS_ALT_MFP1_PA12_Msk    (1UL<<11)              /*!< ALT_MFP1 PA.12 mask             */ 
N
N//PA.13   
N#define SYS_GPA_MFP_PA13_GPIO    0x00000000UL           /*!< GPA_MFP PA.13 setting for GPIO  */    
N#define SYS_ALT_MFP_PA13_GPIO    NULL                   /*!< No ALT_MFP setting for PA.13    */
N#define SYS_ALT_MFP1_PA13_GPIO   0x00000000UL           /*!< ALT_MFP1 PA.13 setting for GPIO */
N    
N#define SYS_GPA_MFP_PA13_PWM1    (1UL<<13)              /*!< GPA_MFP PA.13 setting for PWM1  */    
N#define SYS_ALT_MFP_PA13_PWM1    NULL                   /*!< No ALT_MFP setting for PA.13    */
N#define SYS_ALT_MFP1_PA13_PWM1   0x00000000UL           /*!< ALT_MFP1 PA.13 setting for PWM1 */ 
N
N#define SYS_GPA_MFP_PA13_SC2CLK  (1UL<<13)              /*!< GPA_MFP PA.13 setting for SC2CLK  */    
N#define SYS_ALT_MFP_PA13_SC2CLK  NULL                   /*!< No ALT_MFP setting for PA.13      */
N#define SYS_ALT_MFP1_PA13_SC2CLK (1UL<<10)              /*!< ALT_MFP1 PA.13 setting for SC2CLK */  
N 
N#define SYS_GPA_MFP_PA13_Msk     (1UL<<13)              /*!< GPA_MFP PA.13 mask             */      
N#define SYS_ALT_MFP1_PA13_Msk    (1UL<<10)              /*!< ALT_MFP1 PA.13 mask             */ 
N
N//PA.14   
N#define SYS_GPA_MFP_PA14_GPIO    0x00000000UL           /*!< GPA_MFP PA.14 setting for GPIO  */    
N#define SYS_ALT_MFP_PA14_GPIO    NULL                   /*!< No ALT_MFP setting for PA.14    */
N#define SYS_ALT_MFP1_PA14_GPIO   0x00000000UL           /*!< ALT_MFP1 PA.14 setting for GPIO */
N    
N#define SYS_GPA_MFP_PA14_PWM2    (1UL<<14)              /*!< GPA_MFP PA.14 setting for PWM2  */    
N#define SYS_ALT_MFP_PA14_PWM2    NULL                   /*!< No ALT_MFP setting for PA.14    */
N#define SYS_ALT_MFP1_PA14_PWM2   0x00000000UL           /*!< ALT_MFP1 PA.14 setting for PWM2 */ 
N
N#define SYS_GPA_MFP_PA14_SC2RST  (1UL<<14)              /*!< GPA_MFP PA.14 setting for SC2RST  */    
N#define SYS_ALT_MFP_PA14_SC2RST  NULL                   /*!< No ALT_MFP setting for PA.14      */
N#define SYS_ALT_MFP1_PA14_SC2RST (1UL<<13)              /*!< ALT_MFP1 PA.14 setting for SC2RST */  
N 
N#define SYS_GPA_MFP_PA14_Msk     (1UL<<14)              /*!< GPA_MFP PA.14 mask             */      
N#define SYS_ALT_MFP1_PA14_Msk    (1UL<<13)              /*!< ALT_MFP1 PA.14 mask             */ 
N
N//PA.15   
N#define SYS_GPA_MFP_PA15_GPIO    0x00000000UL   /*!< GPA_MFP PA.15 setting for GPIO */    
N#define SYS_ALT_MFP_PA15_GPIO    0x00000000UL   /*!< ALT_MFP PA.15 setting for GPIO */
N#define SYS_ALT_MFP1_PA15_GPIO   0x00000000UL   /*!< ALT_MFP1 PA.15 setting for GPIO */
N    
N#define SYS_GPA_MFP_PA15_PWM3    (1UL<<15)      /*!< GPA_MFP PA.15 setting for PWM3 */    
N#define SYS_ALT_MFP_PA15_PWM3    0x00000000UL   /*!< ALT_MFP PA.15 setting for PWM3 */ 
N#define SYS_ALT_MFP1_PA15_PWM3   0x00000000UL   /*!< ALT_MFP1 PA.15 setting for PWM3 */ 
N
N#define SYS_GPA_MFP_PA15_I2SMCLK  (1UL<<15)     /*!< GPA_MFP PA.15 setting for I2SMCLK  */    
N#define SYS_ALT_MFP_PA15_I2SMCLK  (1UL<<9)      /*!< ALT_MFP PA.15 setting for I2SMCLK  */  
N#define SYS_ALT_MFP1_PA15_I2SMCLK 0x00000000UL  /*!< ALT_MFP1 PA.15 setting for I2SMCLK  */ 
N
N#define SYS_GPA_MFP_PA15_SC2PWR  (1UL<<15)      /*!< GPA_MFP PA.15 setting for SC2PWR  */    
N#define SYS_ALT_MFP_PA15_SC2PWR  0x00000000UL   /*!< ALT_MFP PA.15 setting for SC2PWR  */  
N#define SYS_ALT_MFP1_PA15_SC2PWR (1UL<<12)      /*!< ALT_MFP1 PA.15 setting for SC2PWR  */ 
N 
N#define SYS_GPA_MFP_PA15_Msk     (1UL<<15)      /*!< GPA_MFP PA.15 mask             */      
N#define SYS_ALT_MFP_PA15_Msk     (1UL<<9)       /*!< ALT_MFP PA.15 mask             */ 
N#define SYS_ALT_MFP1_PA15_Msk    (1UL<<12)      /*!< ALT_MFP1 PA.15 mask             */ 
N
N//PB.0
N#define SYS_GPB_MFP_PB0_GPIO     0x00000000UL    /*!< GPA_MFP PB.0 setting for GPIO */      
N#define SYS_ALT_MFP_PB0_GPIO     NULL            /*!< No ALT_MFP setting for PB.0   */
N#define SYS_ALT_MFP1_PB0_GPIO    NULL            /*!< No ALT_MFP1 setting for PB.0  */
N
N#define SYS_GPB_MFP_PB0_RXD0     (1UL<<0)        /*!< GPA_MFP PB.0 setting for RXD0 */  
N#define SYS_ALT_MFP_PB0_RXD0     NULL            /*!< No ALT_MFP setting for PB.0   */
N#define SYS_ALT_MFP1_PB0_RXD0    NULL            /*!< No ALT_MFP1 setting for PB.0  */
N
N#define SYS_GPB_MFP_PB0_Msk      (1UL<<0)        /*!< GPA_MFP PB.0 mask             */   
N
N//PB.1
N#define SYS_GPB_MFP_PB1_GPIO    0x00000000UL    /*!< GPA_MFP PB.1 setting for GPIO */      
N#define SYS_ALT_MFP_PB1_GPIO    NULL            /*!< No ALT_MFP setting for PB.1   */
N#define SYS_ALT_MFP1_PB1_GPIO   NULL            /*!< No ALT_MFP1 setting for PB.1  */
N
N#define SYS_GPB_MFP_PB1_TXD0    (1UL<<1)            /*!< GPA_MFP PB.1 setting for TXD0 */  
N#define SYS_ALT_MFP_PB1_TXD0    NULL                /*!< No ALT_MFP setting for PB.1   */
N#define SYS_ALT_MFP1_PB1_TXD0   NULL                /*!< No ALT_MFP1 setting for PB.1  */
N
N#define SYS_GPB_MFP_PB1_Msk     (1UL<<1)        /*!< GPA_MFP PB.1 mask             */  
N
N//PB.2   
N#define SYS_GPB_MFP_PB2_GPIO    0x00000000UL            /*!< GPB_MFP PB.2 setting for GPIO */    
N#define SYS_ALT_MFP_PB2_GPIO    0x00000000UL            /*!< ALT_MFP PB.2 setting for GPIO */
N#define SYS_ALT_MFP1_PB2_GPIO   NULL                    /*!< No ALT_MFP1 setting for PB.2  */
N
N#define SYS_GPB_MFP_PB2_RTS0    (1UL<<2)                /*!< GPB_MFP PB.2 setting for RTS0 */    
N#define SYS_ALT_MFP_PB2_RTS0    0x00000000UL            /*!< ALT_MFP PB.2 setting for RTS0 */ 
N#define SYS_ALT_MFP1_PB2_RTS0   NULL                    /*!< No ALT_MFP1 setting for PB.2  */
N
N#define SYS_GPB_MFP_PB2_T2EX    (1UL<<2)                /*!< GPB_MFP PB.2 setting for T2EX */    
N#define SYS_ALT_MFP_PB2_T2EX    (1UL<<26)               /*!< ALT_MFP PB.2 setting for T2EX */ 
N#define SYS_ALT_MFP1_PB2_T2EX   NULL                    /*!< No ALT_MFP1 setting for PB.2  */
N
N#define SYS_GPB_MFP_PB2_CPO0    (1UL<<2)                /*!< GPB_MFP PB.2 setting for CPO0 */    
N#define SYS_ALT_MFP_PB2_CPO0    (1UL<<30)               /*!< ALT_MFP PB.2 setting for CPO0 */ 
N#define SYS_ALT_MFP1_PB2_CPO0   NULL                    /*!< No ALT_MFP1 setting for PB.2  */
N
N#define SYS_GPB_MFP_PB2_Msk     (1UL<<2)                /*!< GPB_MFP PB.2 mask */      
N#define SYS_ALT_MFP_PB2_Msk     ((1UL<<30)|(1UL<<26))   /*!< ALT_MFP PB.2 mask */ 
N
N//PB.3   
N#define SYS_GPB_MFP_PB3_GPIO    0x00000000UL    /*!< GPB_MFP PB.3 setting for GPIO */    
N#define SYS_ALT_MFP_PB3_GPIO    0x00000000UL    /*!< ALT_MFP PB.3 setting for GPIO */
N#define SYS_ALT_MFP1_PB3_GPIO   0x00000000UL    /*!< ALT_MFP1 PB.3 setting for GPIO */
N    
N#define SYS_GPB_MFP_PB3_CTS0    (1UL<<3)        /*!< GPB_MFP PB.3 setting for CTS0 */    
N#define SYS_ALT_MFP_PB3_CTS0    0x00000000UL    /*!< ALT_MFP PB.3 setting for CTS0 */ 
N#define SYS_ALT_MFP1_PB3_CTS0   0x00000000UL    /*!< ALT_MFP1 PB.3 setting for CTS0 */ 
N
N#define SYS_GPB_MFP_PB3_T3EX    (1UL<<3)        /*!< GPB_MFP PB.3 setting for T3EX */    
N#define SYS_ALT_MFP_PB3_T3EX    (1UL<<27)       /*!< ALT_MFP PB.3 setting for T3EX */ 
N#define SYS_ALT_MFP1_PB3_T3EX   0x00000000UL    /*!< ALT_MFP1 PB.3 setting for T3EX */ 
N
N#define SYS_GPB_MFP_PB3_SC2CD   (1UL<<3)        /*!< GPB_MFP PB.3 setting for SC2CD */    
N#define SYS_ALT_MFP_PB3_SC2CD   0x00000000UL    /*!< ALT_MFP PB.3 setting for SC2CD */ 
N#define SYS_ALT_MFP1_PB3_SC2CD  (1UL<<14)       /*!< ALT_MFP1 PB.3 setting for SC2CD */ 
N 
N#define SYS_GPB_MFP_PB3_Msk     (1UL<<3)        /*!< GPB_MFP PB.3 mask */      
N#define SYS_ALT_MFP_PB3_Msk     (1UL<<27)       /*!< ALT_MFP PB.3 mask */ 
N#define SYS_ALT_MFP1_PB3_Msk    (1UL<<14)       /*!< ALT_MFP1 PB.3 mask */ 
N
N//PB.4
N#define SYS_GPB_MFP_PB4_GPIO     0x00000000UL    /*!< GPA_MFP PB.4 setting for GPIO */      
N#define SYS_ALT_MFP_PB4_GPIO     NULL            /*!< No ALT_MFP setting for PB.4   */
N#define SYS_ALT_MFP1_PB4_GPIO    NULL            /*!< No ALT_MFP1 setting for PB.4  */   
N
N#define SYS_GPB_MFP_PB4_RXD1     (1UL<<4)        /*!< GPA_MFP PB.4 setting for RXD1 */  
N#define SYS_ALT_MFP_PB4_RXD1     NULL            /*!< No ALT_MFP setting for PB.4   */
N#define SYS_ALT_MFP1_PB4_RXD1    NULL            /*!< No ALT_MFP1 setting for PB.4  */
N
N#define SYS_GPB_MFP_PB4_Msk         (1UL<<4)        /*!< GPA_MFP PB.4 mask */ 
N
N//PB.5
N#define SYS_GPB_MFP_PB5_GPIO        0x00000000UL    /*!< GPA_MFP PB.5 setting for GPIO */      
N#define SYS_ALT_MFP_PB5_GPIO        NULL            /*!< No ALT_MFP setting for PB.5   */ 
N#define SYS_ALT_MFP1_PB5_GPIO       NULL            /*!< No ALT_MFP1 setting for PB.5  */ 
N
N#define SYS_GPB_MFP_PB5_TXD1       (1UL<<5)         /*!< GPA_MFP PB.5 setting for TXD1 */
N#define SYS_ALT_MFP_PB5_TXD1       NULL             /*!< No ALT_MFP setting for PB.5   */
N#define SYS_ALT_MFP1_PB5_TXD1      NULL             /*!< No ALT_MFP1 setting for PB.5  */
N
N#define SYS_GPB_MFP_PB5_Msk         (1UL<<5)        /*!< GPA_MFP PB.5 mask */ 
N
N//PB.6   
N#define SYS_GPB_MFP_PB6_GPIO    0x00000000UL    /*!< GPB_MFP PB.6 setting for GPIO */        
N#define SYS_GPB_MFP_PB6_RTS1    (1UL<<6)        /*!< GPB_MFP PB.6 setting for RTS1 */     
N#define SYS_GPB_MFP_PB6_Msk     (1UL<<6)        /*!< GPB_MFP PB.6 mask */      
N
N//PB.7   
N#define SYS_GPB_MFP_PB7_GPIO    0x00000000UL    /*!< GPB_MFP PB.7 setting for GPIO */      
N#define SYS_GPB_MFP_PB7_CTS1    (1UL<<7)        /*!< GPB_MFP PB.7 setting for CTS1 */     
N#define SYS_GPB_MFP_PB7_Msk     (1UL<<7)        /*!< GPB_MFP PB.7 mask */
N
N//PB.8
N#define SYS_GPB_MFP_PB8_GPIO    0x00000000UL    /*!< GPA_MFP PB.8 setting for GPIO */   
N#define SYS_ALT_MFP_PB8_GPIO    0x00000000UL    /*!< ALT_MFP PB.8 setting for GPIO */
N#define SYS_ALT_MFP1_PB8_GPIO   NULL            /*!< No ALT_MFP1 setting for PB.8  */
N
N#define SYS_GPB_MFP_PB8_TM0     (1UL<<8)        /*!< GPA_MFP PB.8 setting for TM0 */  
N#define SYS_ALT_MFP_PB8_TM0     0x00000000UL    /*!< ALT_MFP PB.8 setting for TM0 */
N#define SYS_ALT_MFP1_PB8_TM0    NULL            /*!< No ALT_MFP1 setting for PB.8  */
N
N#define SYS_GPB_MFP_PB8_CLKO    (1UL<<8)        /*!< GPA_MFP PB.8 setting for CLKO */  
N#define SYS_ALT_MFP_PB8_CLKO    (1UL<<29)       /*!< ALT_MFP PB.8 setting for CLKO */
N#define SYS_ALT_MFP1_PB8_CLKO   NULL            /*!< No ALT_MFP1 setting for PB.8  */
N
N#define SYS_GPB_MFP_PB8_Msk     (1UL<<8)        /*!< GPA_MFP PB.8 mask */ 
N#define SYS_ALT_MFP_PB8_Msk     (1UL<<29)       /*!< ALT_MFP PB.8 mask */ 
N
N//PB.9   
N#define SYS_GPB_MFP_PB9_GPIO    0x00000000UL    /*!< GPB_MFP PB.9 setting for GPIO */    
N#define SYS_ALT_MFP_PB9_GPIO    0x00000000UL    /*!< ALT_MFP PB.9 setting for GPIO */
N#define SYS_ALT_MFP1_PB9_GPIO   NULL            /*!< No ALT_MFP1 setting for PB.9  */
N    
N#define SYS_GPB_MFP_PB9_TM1     (1UL<<9)        /*!< GPB_MFP PB.9 setting for TM1 */    
N#define SYS_ALT_MFP_PB9_TM1     0x00000000UL    /*!< ALT_MFP PB.9 setting for TM1 */ 
N#define SYS_ALT_MFP1_PB9_TM1    NULL            /*!< No ALT_MFP1 setting for PB.9 */
N
N#define SYS_GPB_MFP_PB9_SPISS11  (1UL<<9)        /*!< GPB_MFP PB.9 setting for SPISS11  */    
N#define SYS_ALT_MFP_PB9_SPISS11  (1UL<<1)        /*!< ALT_MFP PB.9 setting for SPISS11  */ 
N#define SYS_ALT_MFP1_PB9_SPISS11 NULL            /*!< No ALT_MFP1 setting for PB.9  */
N
N#define SYS_GPB_MFP_PB9_Msk     (1UL<<9)        /*!< GPB_MFP PB.9 mask */      
N#define SYS_ALT_MFP_PB9_Msk     (1UL<<1)        /*!< ALT_MFP PB.9 mask */ 
N
N
N//PB.10   
N#define SYS_GPB_MFP_PB10_GPIO    0x00000000UL       /*!< GPB_MFP PB.10 setting for GPIO */    
N#define SYS_ALT_MFP_PB10_GPIO    0x00000000UL       /*!< ALT_MFP PB.10 setting for GPIO */
N#define SYS_ALT_MFP1_PB10_GPIO   NULL               /*!< No ALT_MFP1 setting for PB.10  */
N
N#define SYS_GPB_MFP_PB10_TM2     (1UL<<10)          /*!< GPB_MFP PB.10 setting for TM2 */    
N#define SYS_ALT_MFP_PB10_TM2     0x00000000UL       /*!< ALT_MFP PB.10 setting for TM2 */ 
N#define SYS_ALT_MFP1_PB10_TM2    NULL               /*!< No ALT_MFP1 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_SPISS01  (1UL<<10)         /*!< GPB_MFP PB.10 setting for SPISS01 */    
N#define SYS_ALT_MFP_PB10_SPISS01  (1UL<<0)          /*!< ALT_MFP PB.10 setting for SPISS01 */ 
N#define SYS_ALT_MFP1_PB10_SPISS01 NULL              /*!< No ALT_MFP1 setting for PB.10     */
N    
N#define SYS_GPB_MFP_PB10_Msk    (1UL<<10)           /*!< GPB_MFP PB.10 mask */      
N#define SYS_ALT_MFP_PB10_Msk    (1UL<<0)            /*!< ALT_MFP PB.10 mask */ 
N
N//PB.11   
N#define SYS_GPB_MFP_PB11_GPIO   0x00000000UL       /*!< GPB_MFP PB.11 setting for GPIO */    
N#define SYS_ALT_MFP_PB11_GPIO   0x00000000UL       /*!< ALT_MFP PB.11 setting for GPIO */
N#define SYS_ALT_MFP1_PB11_GPIO  NULL               /*!< No ALT_MFP1 setting for PB.11  */
N
N#define SYS_GPB_MFP_PB11_TM3    (1UL<<11)          /*!< GPB_MFP PB.11 setting for TM3 */    
N#define SYS_ALT_MFP_PB11_TM3    0x00000000UL       /*!< ALT_MFP PB.11 setting for TM3 */ 
N#define SYS_ALT_MFP1_PB11_TM3   NULL               /*!< No ALT_MFP1 setting for PB.11  */
N
N#define SYS_GPB_MFP_PB11_PWM4   (1UL<<11)           /*!< GPB_MFP PB.11 setting for PWM4  */    
N#define SYS_ALT_MFP_PB11_PWM4   (1UL<<4)            /*!< ALT_MFP PB.11 setting for PWM4  */ 
N#define SYS_ALT_MFP1_PB11_PWM4  NULL                /*!< No ALT_MFP1 setting for PB.11  */
N
N#define SYS_GPB_MFP_PB11_Msk    (1UL<<11)           /*!< GPB_MFP PB.11 mask */      
N#define SYS_ALT_MFP_PB11_Msk    (1UL<<4)            /*!< ALT_MFP PB.11 mask */ 
N
N//PB.12 is reserved
N
N//PB.13   
N#define SYS_GPB_MFP_PB13_GPIO   0x00000000UL        /*!< GPB_MFP PB.13 setting for GPIO */      
N#define SYS_ALT_MFP_PB13_GPIO   NULL                /*!< No ALT_MFP setting for PB.13   */
N#define SYS_ALT_MFP1_PB13_GPIO  NULL                /*!< No ALT_MFP1 setting for PB.13  */
N
N#define SYS_GPB_MFP_PB13_CPO1   (1UL<<13)           /*!< GPB_MFP PB.13 setting for CPO1 */ 
N#define SYS_ALT_MFP_PB13_CPO1   NULL                /*!< No ALT_MFP setting for PB.13   */
N#define SYS_ALT_MFP1_PB13_CPO1  NULL                /*!< No ALT_MFP1 setting for PB.13  */
N
N#define SYS_GPB_MFP_PB13_Msk    (1UL<<13)           /*!< GPB_MFP PB.13 mask */      
N
N//PB.14   
N#define SYS_GPB_MFP_PB14_GPIO   0x00000000UL        /*!< GPB_MFP PB.14 setting for GPIO */    
N#define SYS_ALT_MFP_PB14_GPIO   0x00000000UL        /*!< ALT_MFP PB.14 setting for GPIO */
N#define SYS_ALT_MFP1_PB14_GPIO  NULL                /*!< No ALT_MFP1 setting for PB.14  */
N
N#define SYS_GPB_MFP_PB14_INT0   (1UL<<14)           /*!< GPB_MFP PB.14 setting for INT0 */    
N#define SYS_ALT_MFP_PB14_INT0   0x00000000UL        /*!< ALT_MFP PB.14 setting for INT0 */ 
N#define SYS_ALT_MFP1_PB14_INT0  NULL                /*!< No ALT_MFP1 setting for PB.14  */
N
N#define SYS_GPB_MFP_PB14_SPISS31    (1UL<<14)       /*!< GPB_MFP PB.14 setting for SPISS31 */    
N#define SYS_ALT_MFP_PB14_SPISS31    (1UL<<3)        /*!< ALT_MFP PB.14 setting for SPISS31 */ 
N#define SYS_ALT_MFP1_PB14_SPISS31   NULL            /*!< No ALT_MFP1 setting for PB.14     */
N
N#define SYS_GPB_MFP_PB14_Msk    (1UL<<14)           /*!< GPB_MFP PB.14 mask */      
N#define SYS_ALT_MFP_PB14_Msk    (1UL<<3)            /*!< ALT_MFP PB.14 mask */ 
N#define SYS_ALT_MFP1_PB14_Msk   NULL
N
N//PB.15   
N#define SYS_GPB_MFP_PB15_GPIO    0x00000000UL   /*!< GPB_MFP PB.15 setting for GPIO */    
N#define SYS_ALT_MFP_PB15_GPIO    0x00000000UL   /*!< ALT_MFP PB.15 setting for GPIO */
N#define SYS_ALT_MFP1_PB15_GPIO   NULL
N
N#define SYS_GPB_MFP_PB15_INT1    (1UL<<15)      /*!< GPB_MFP PB.15 setting for INT1 */    
N#define SYS_ALT_MFP_PB15_INT1    0x00000000UL   /*!< ALT_MFP PB.15 setting for INT1 */ 
N#define SYS_ALT_MFP1_PB15_INT1   NULL
N
N#define SYS_GPB_MFP_PB15_T0EX   (1UL<<15)       /*!< GPB_MFP PB.15 setting for T0EX  */    
N#define SYS_ALT_MFP_PB15_T0EX   (1UL<<24)       /*!< ALT_MFP PB.15 setting for T0EX  */ 
N#define SYS_ALT_MFP1_PB15_T0EX  NULL
N
N#define SYS_GPB_MFP_PB15_Msk    (1UL<<15)       /*!< GPB_MFP PB.15 mask */      
N#define SYS_ALT_MFP_PB15_Msk    (1UL<<24)       /*!< ALT_MFP PB.15 mask */ 
N
N//PC.0   
N#define SYS_GPC_MFP_PC0_GPIO        0x00000000UL   /*!< GPC_MFP PC.0 setting for GPIO */    
N#define SYS_ALT_MFP_PC0_GPIO        0x00000000UL   /*!< ALT_MFP PC.0 setting for GPIO */
N#define SYS_ALT_MFP1_PC0_GPIO       NULL
N
N#define SYS_GPC_MFP_PC0_SPISS00     (1UL<<0)       /*!< GPC_MFP PC.0 setting for SPISS00 */    
N#define SYS_ALT_MFP_PC0_SPISS00     0x00000000UL   /*!< ALT_MFP PC.0 setting for SPISS00 */ 
N#define SYS_ALT_MFP1_PC0_SPISS00    NULL
N
N#define SYS_GPC_MFP_PC0_I2SLRCLK    (1UL<<0)       /*!< GPC_MFP PC.0 setting for I2SLRCLK  */    
N#define SYS_ALT_MFP_PC0_I2SLRCLK    (1UL<<5)       /*!< ALT_MFP PC.0 setting for I2SLRCLK  */ 
N#define SYS_ALT_MFP1_PC0_I2SLRCLK   NULL
N
N#define SYS_GPC_MFP_PC0_Msk         (1UL<<0)       /*!< GPC_MFP PC.0 mask */      
N#define SYS_ALT_MFP_PC0_Msk         (1UL<<5)       /*!< ALT_MFP PC.0 mask */ 
N
N//PC.1   
N#define SYS_GPC_MFP_PC1_GPIO        0x00000000UL   /*!< GPC_MFP PC.1 setting for GPIO */    
N#define SYS_ALT_MFP_PC1_GPIO        0x00000000UL   /*!< ALT_MFP PC.1 setting for GPIO */
N#define SYS_ALT_MFP1_PC1_GPIO       NULL
N
N#define SYS_GPC_MFP_PC1_SPICLK0     (1UL<<1)       /*!< GPC_MFP PC.1 setting for SPICLK0 */    
N#define SYS_ALT_MFP_PC1_SPICLK0     0x00000000UL   /*!< ALT_MFP PC.1 setting for SPICLK0 */ 
N#define SYS_ALT_MFP1_PC1_SPICLK0    NULL
N
N#define SYS_GPC_MFP_PC1_I2SBCLK     (1UL<<1)       /*!< GPC_MFP PC.1 setting for I2SBCLK  */    
N#define SYS_ALT_MFP_PC1_I2SBCLK     (1UL<<6)       /*!< ALT_MFP PC.1 setting for I2SBCLK  */ 
N#define SYS_ALT_MFP1_PC1_I2SBCLK    NULL 
N 
N#define SYS_GPC_MFP_PC1_Msk         (1UL<<1)       /*!< GPC_MFP PC.1 mask */      
N#define SYS_ALT_MFP_PC1_Msk         (1UL<<6)       /*!< ALT_MFP PC.1 mask */ 
N
N//PC.2   
N#define SYS_GPC_MFP_PC2_GPIO        0x00000000UL   /*!< GPC_MFP PC.2 setting for GPIO */    
N#define SYS_ALT_MFP_PC2_GPIO        0x00000000UL   /*!< ALT_MFP PC.2 setting for GPIO */
N#define SYS_ALT_MFP1_PC2_GPIO       NULL
N
N#define SYS_GPC_MFP_PC2_MISO00      (1UL<<2)       /*!< GPC_MFP PC.2 setting for MISO00 */    
N#define SYS_ALT_MFP_PC2_MISO00      0x00000000UL   /*!< ALT_MFP PC.2 setting for MISO00 */ 
N#define SYS_ALT_MFP1_PC2_MISO00     NULL
N
N#define SYS_GPC_MFP_PC2_I2SDI       (1UL<<2)       /*!< GPC_MFP PC.2 setting for I2SDI  */    
N#define SYS_ALT_MFP_PC2_I2SDI       (1UL<<7)       /*!< ALT_MFP PC.2 setting for I2SDI  */ 
N#define SYS_ALT_MFP1_PC2_I2SDI      NULL
N
N#define SYS_GPC_MFP_PC2_Msk         (1UL<<2)       /*!< GPC_MFP PC.2 mask */      
N#define SYS_ALT_MFP_PC2_Msk         (1UL<<7)       /*!< ALT_MFP PC.2 mask */ 
N
N//PC.3   
N#define SYS_GPC_MFP_PC3_GPIO        0x00000000UL   /*!< GPC_MFP PC.3 setting for GPIO */    
N#define SYS_ALT_MFP_PC3_GPIO        0x00000000UL   /*!< ALT_MFP PC.3 setting for GPIO */
N#define SYS_ALT_MFP1_PC3_GPIO       NULL
N
N#define SYS_GPC_MFP_PC3_MOSI00      (1UL<<3)       /*!< GPC_MFP PC.3 setting for MOSI00 */    
N#define SYS_ALT_MFP_PC3_MOSI00      0x00000000UL   /*!< ALT_MFP PC.3 setting for MOSI00 */ 
N#define SYS_ALT_MFP1_PC3_MOSI00     NULL
N
N#define SYS_GPC_MFP_PC3_I2SDO       (1UL<<3)       /*!< GPC_MFP PC.3 setting for I2SDO  */    
N#define SYS_ALT_MFP_PC3_I2SDO       (1UL<<8)       /*!< ALT_MFP PC.3 setting for I2SDO  */ 
N#define SYS_ALT_MFP1_PC3_I2SDO      NULL
N
N#define SYS_GPC_MFP_PC3_Msk         (1UL<<3)       /*!< GPC_MFP PC.3 mask */      
N#define SYS_ALT_MFP_PC3_Msk         (1UL<<8)       /*!< ALT_MFP PC.3 mask */ 
N
N//PC.4   
N#define SYS_GPC_MFP_PC4_GPIO        0x00000000UL   /*!< GPC_MFP PC.4 setting for GPIO */     
N#define SYS_ALT_MFP_PC4_GPIO        NULL
N#define SYS_ALT_MFP1_PC4_GPIO       NULL
N
N#define SYS_GPC_MFP_PC4_MISO1       (1UL<<4)       /*!< GPC_MFP PC.4 setting for MISO01 */      
N#define SYS_ALT_MFP_PC4_MISO1       NULL
N#define SYS_ALT_MFP1_PC4_MISO1      NULL
N
N#define SYS_GPC_MFP_PC4_Msk         (1UL<<4)       /*!< GPC_MFP PC.4 mask */      
N
N//PC.5   
N#define SYS_GPC_MFP_PC5_GPIO        0x00000000UL   /*!< GPC_MFP PC.5 setting for GPIO */     
N#define SYS_ALT_MFP_PC5_GPIO        NULL
N#define SYS_ALT_MFP1_PC5_GPIO       NULL
N
N#define SYS_GPC_MFP_PC5_MOSI01      (1UL<<5)       /*!< GPC_MFP PC.5 setting for MOSI01 */      
N#define SYS_ALT_MFP_PC5_MOSI01      NULL
N#define SYS_ALT_MFP1_PC5_MOSI01     NULL
N
N#define SYS_GPC_MFP_PC5_Msk         (1UL<<5)       /*!< GPC_MFP PC.5 mask */  
N
N//PC.6   
N#define SYS_GPC_MFP_PC6_GPIO        0x00000000UL   /*!< GPC_MFP PC.6 setting for GPIO */    
N#define SYS_ALT_MFP_PC6_GPIO        NULL
N#define SYS_ALT_MFP1_PC6_GPIO       0x00000000UL   /*!< ALT_MFP1 PC.6 setting for GPIO */
N
N#define SYS_GPC_MFP_PC6_CPP0        (1UL<<6)       /*!< GPC_MFP PC.6 setting for CPP0 */    
N#define SYS_ALT_MFP_PC6_CPP0        NULL
N#define SYS_ALT_MFP1_PC6_CPP0       0x00000000UL   /*!< ALT_MFP1 PC.6 setting for CPP0 */ 
N
N#define SYS_GPC_MFP_PC6_SC0CD       (1UL<<6)       /*!< GPC_MFP PC.6 setting for SC0CD  */    
N#define SYS_ALT_MFP_PC6_SC0CD       NULL
N#define SYS_ALT_MFP1_PC6_SC0CD      (1UL<<4)       /*!< ALT_MFP1 PC.6 setting for SC0CD  */ 
N 
N#define SYS_GPC_MFP_PC6_Msk         (1UL<<6)       /*!< GPC_MFP PC.6 mask */      
N#define SYS_ALT_MFP1_PC6_Msk        (1UL<<4)       /*!< ALT_MFP1 PC.6 mask */ 
N
N//PC.7   
N#define SYS_GPC_MFP_PC7_GPIO        0x00000000UL   /*!< GPC_MFP PC.7 setting for GPIO */    
N#define SYS_ALT_MFP_PC7_GPIO        NULL
N#define SYS_ALT_MFP1_PC7_GPIO       0x00000000UL   /*!< ALT_MFP1 PC.7 setting for GPIO */
N    
N#define SYS_GPC_MFP_PC7_CPN0        (1UL<<7)       /*!< GPC_MFP PC.7 setting for CPN0 */    
N#define SYS_ALT_MFP_PC7_CPN0        NULL
N#define SYS_ALT_MFP1_PC7_CPN0       0x00000000UL   /*!< ALT_MFP1 PC.7 setting for CPN0 */ 
N
N#define SYS_GPC_MFP_PC7_SC1CD       (1UL<<7)       /*!< GPC_MFP PC.7 setting for SC1CD  */    
N#define SYS_ALT_MFP_PC7_SC1CD       NULL
N#define SYS_ALT_MFP1_PC7_SC1CD      (1UL<<9)       /*!< ALT_MFP1 PC.7 setting for SC1CD  */ 
N 
N#define SYS_GPC_MFP_PC7_Msk         (1UL<<7)       /*!< GPC_MFP PC.7 mask */      
N#define SYS_ALT_MFP1_PC7_Msk        (1UL<<9)       /*!< ALT_MFP1 PC.7 mask */ 
N
N//PC.8   
N#define SYS_GPC_MFP_PC8_GPIO        0x00000000UL   /*!< GPC_MFP PC.8 setting for GPIO */    
N#define SYS_ALT_MFP_PC8_GPIO        NULL
N#define SYS_ALT_MFP1_PC8_GPIO       NULL
N
N#define SYS_GPC_MFP_PC8_SPISS10     (1UL<<8)       /*!< GPC_MFP PC.8 setting for SPISS10 */    
N#define SYS_ALT_MFP_PC8_SPISS10     NULL
N#define SYS_ALT_MFP1_PC8_SPISS10    NULL
N
N#define SYS_GPC_MFP_PC8_Msk         (1UL<<8)       /*!< GPC_MFP PC.8 mask */      
N
N//PC.9   
N#define SYS_GPC_MFP_PC9_GPIO        0x00000000UL   /*!< GPC_MFP PC.9 setting for GPIO */       
N#define SYS_ALT_MFP_PC9_GPIO        NULL
N#define SYS_ALT_MFP1_PC9_GPIO       NULL
N
N#define SYS_GPC_MFP_PC9_SPICLK1     (1UL<<9)       /*!< GPC_MFP PC.9 setting for SPICLK1 */    
N#define SYS_ALT_MFP_PC9_SPICLK1     NULL
N#define SYS_ALT_MFP1_PC9_SPICLK1    NULL
N
N#define SYS_GPC_MFP_PC9_Msk         (1UL<<9)       /*!< GPC_MFP PC.9 mask */      
N
N//PC.10   
N#define SYS_GPC_MFP_PC10_GPIO       0x00000000UL   /*!< GPC_MFP PC.10 setting for GPIO */        
N#define SYS_ALT_MFP_PC10_GPIO       NULL
N#define SYS_ALT_MFP1_PC10_GPIO      NULL
N
N#define SYS_GPC_MFP_PC10_MISO10     (1UL<<10)      /*!< GPC_MFP PC.10 setting for MISO10 */    
N#define SYS_ALT_MFP_PC10_MISO10     NULL
N#define SYS_ALT_MFP1_PC10_MISO10    NULL
N
N#define SYS_GPC_MFP_PC10_Msk         (1UL<<10)      /*!< GPC_MFP PC.10 mask */      
N
N//PC.11   
N#define SYS_GPC_MFP_PC11_GPIO       0x00000000UL   /*!< GPC_MFP PC.11 setting for GPIO */     
N#define SYS_ALT_MFP_PC11_GPIO       NULL
N#define SYS_ALT_MFP1_PC11_GPIO      NULL
N
N#define SYS_GPC_MFP_PC11_MOSI10     (1UL<<11)      /*!< GPC_MFP PC.11 setting for MOSI10 */    
N#define SYS_ALT_MFP_PC11_MOSI10     NULL
N#define SYS_ALT_MFP1_PC11_MOSI10    NULL
N
N#define SYS_GPC_MFP_PC11_Msk         (1UL<<11)      /*!< GPC_MFP PC.11 mask */      
N
N
N//PC.12   
N#define SYS_GPC_MFP_PC12_GPIO        0x00000000UL   /*!< GPC_MFP PC.12 setting for GPIO */     
N#define SYS_ALT_MFP_PC12_GPIO        NULL
N#define SYS_ALT_MFP1_PC12_GPIO       NULL
N
N#define SYS_GPC_MFP_PC12_MISO11      (1UL<<12)      /*!< GPC_MFP PC.12 setting for MISO11 */      
N#define SYS_ALT_MFP_PC12_MISO11      NULL
N#define SYS_ALT_MFP1_PC12_MISO11     NULL
N
N#define SYS_GPC_MFP_PC12_Msk         (1UL<<12)      /*!< GPC_MFP PC.12 mask */   
N
N//PC.13   
N#define SYS_GPC_MFP_PC13_GPIO        0x00000000UL   /*!< GPC_MFP PC.13 setting for GPIO */     
N#define SYS_ALT_MFP_PC13_GPIO        NULL
N#define SYS_ALT_MFP1_PC13_GPIO       NULL
N
N#define SYS_GPC_MFP_PC13_MOSI11      (1UL<<13)      /*!< GPC_MFP PC.13 setting for MOSI11 */      
N#define SYS_ALT_MFP_PC13_MOSI11      NULL
N#define SYS_ALT_MFP1_PC13_MOSI11     NULL
N
N#define SYS_GPC_MFP_PC13_Msk         (1UL<<13)      /*!< GPC_MFP PC.13 mask */   
N
N//PC.14   
N#define SYS_GPC_MFP_PC14_GPIO        0x00000000UL   /*!< GPC_MFP PC.14 setting for GPIO */       
N#define SYS_ALT_MFP_PC14_GPIO        NULL
N#define SYS_ALT_MFP1_PC14_GPIO       NULL
N
N#define SYS_GPC_MFP_PC14_CPP1        (1UL<<14)      /*!< GPC_MFP PC.14 setting for CPP1  */    
N#define SYS_ALT_MFP_PC14_CPP1        NULL
N#define SYS_ALT_MFP1_PC14_CPP1       NULL
N
N#define SYS_GPC_MFP_PC14_Msk         (1UL<<14)      /*!< GPC_MFP PC.14 mask */      
N
N
N//PC.15   
N#define SYS_GPC_MFP_PC15_GPIO        0x00000000UL   /*!< GPC_MFP PC.15 setting for GPIO */        
N#define SYS_ALT_MFP_PC15_GPIO        NULL
N#define SYS_ALT_MFP1_PC15_GPIO       NULL
N
N#define SYS_GPC_MFP_PC15_CPN1        (1UL<<15)      /*!< GPC_MFP PC.15 setting for CPN1  */    
N#define SYS_ALT_MFP_PC15_CPN1        NULL
N#define SYS_ALAT_MFP1_PC15_CPN1      NULL
N
N#define SYS_GPC_MFP_PC15_Msk         (1UL<<15)      /*!< GPC_MFP PC.15 mask */      
N
N
N//PD.0   
N#define SYS_GPD_MFP_PD0_GPIO        0x00000000UL  /*!< GPD_MFP PD.0 setting for GPIO */       
N#define SYS_ALT_MFP_PD0_GPIO        NULL
N#define SYS_ALT_MFP1_PD0_GPIO       NULL
N
N#define SYS_GPD_MFP_PD0_SPISS20     (1UL<<0)      /*!< GPD_MFP PD.0 setting for SPISS20 */    
N#define SYS_ALT_MFP_PD0_SPISS20     NULL
N#define SYS_ALT_MFP1_PD0_SPISS20    NULL
N
N#define SYS_GPD_MFP_PD0_Msk         (1UL<<0)      /*!< GPD_MFP PD.0 mask */      
N
N//PD.1   
N#define SYS_GPD_MFP_PD1_GPIO        0x00000000UL  /*!< GPD_MFP PD.1 setting for GPIO */       
N#define SYS_ALT_MFP_PD1_GPIO        NULL
N#define SYS_ALT_MFP1_PD1_GPIO       NULL
N
N#define SYS_GPD_MFP_PD1_SPICLK2     (1UL<<1)      /*!< GPD_MFP PD.1 setting for SPICLK2 */     
N#define SYS_ALT_MFP_PD1_SPICLK2     NULL
N#define SYS_ALT_MFP1_PD1_SPICLK2    NULL
N
N#define SYS_GPD_MFP_PD1_Msk         (1UL<<1)      /*!< GPD_MFP PD.1 mask */      
N
N//PD.2   
N#define SYS_GPD_MFP_PD2_GPIO        0x00000000UL  /*!< GPD_MFP PD.2 setting for GPIO */        
N#define SYS_ALT_MFP_PD2_GPIO        NULL
N#define SYS_ALT_MFP1_PD2_GPIO       NULL
N
N#define SYS_GPD_MFP_PD2_MISO20      (1UL<<2)      /*!< GPD_MFP PD.2 setting for MISO20 */    
N#define SYS_ALT_MFP_PD2_MISO20      NULL
N#define SYS_ALT_MFP1_PD2_MISO20     NULL
N
N#define SYS_GPD_MFP_PD2_Msk         (1UL<<2)      /*!< GPD_MFP PD.2 mask */      
N
N//PD.3   
N#define SYS_GPD_MFP_PD3_GPIO        0x00000000UL  /*!< GPD_MFP PD.3 setting for GPIO */        
N#define SYS_ALT_MFP_PD3_GPIO        NULL
N#define SYS_ALT_MFP1_PD3_GPIO       NULL
N
N#define SYS_GPD_MFP_PD3_MOSI20      (1UL<<3)      /*!< GPD_MFP PD.3 setting for MOSI20 */    
N#define SYS_ALT_MFP_PD3_MOSI20      NULL
N#define SYS_ALT_MFP1_PD3_MOSI20     NULL
N
N#define SYS_GPD_MFP_PD3_Msk         (1UL<<3)      /*!< GPD_MFP PD.3 mask */      
N
N//PD.4   
N#define SYS_GPD_MFP_PD4_GPIO        0x00000000UL  /*!< GPD_MFP PD.4 setting for GPIO */       
N#define SYS_ALT_MFP_PD4_GPIO        NULL
N#define SYS_ALT_MFP1_PD4_GPIO       NULL
N
N#define SYS_GPD_MFP_PD4_MISO21      (1UL<<4)      /*!< GPD_MFP PD.4 setting for MISO21   */    
N#define SYS_ALT_MFP_PD4_MISO21      NULL
N#define SYS_ALT_MFP1_PD4_MISO21     NULL
N
N#define SYS_GPD_MFP_PD4_Msk         (1UL<<4)      /*!< GPD_MFP PD.4 mask */      
N
N//PD.5   
N#define SYS_GPD_MFP_PD5_GPIO        0x00000000UL  /*!< GPD_MFP PD.5 setting for GPIO */       
N#define SYS_ALT_MFP_PD5_GPIO        NULL
N#define SYS_ALT_MFP1_PD5_GPIO       NULL
N
N#define SYS_GPD_MFP_PD5_MOSI21      (1UL<<5)      /*!< GPD_MFP PD.5 setting for MOSI21   */    
N#define SYS_ALT_MFP_PD5_MOSI21      NULL
N#define SYS_ALT_MFP1_PD5_MOSI21     NULL
N
N#define SYS_GPD_MFP_PD5_Msk         (1UL<<5)      /*!< GPD_MFP PD.5 mask */ 
N
N//PD.6   
N#define SYS_GPD_MFP_PD6_GPIO        0x00000000UL  /*!< GPD_MFP PD.6 setting for GPIO */       
N#define SYS_ALT_MFP_PD6_GPIO        NULL
N#define SYS_ALT_MFP1_PD6_GPIO       NULL
N
N#define SYS_GPD_MFP_PD6_CAN0RX      (1UL<<6)      /*!< GPD_MFP PD.6 setting for CAN0RX   */    
N#define SYS_ALT_MFP_PD6_CAN0RX      NULL
N#define SYS_ALT_MFP1_PD6_CAN0RX     NULL
N
N#define SYS_GPD_MFP_PD6_Msk         (1UL<<6)      /*!< GPD_MFP PD.6 mask */ 
N
N//PD.7   
N#define SYS_GPD_MFP_PD7_GPIO        0x00000000UL  /*!< GPD_MFP PD.7 setting for GPIO */       
N#define SYS_ALT_MFP_PD7_GPIO
N#define SYS_ALT_MFP1_PD7_GPIO
N
N#define SYS_GPD_MFP_PD7_CAN0TX      (1UL<<7)      /*!< GPD_MFP PD.7 setting for CAN0TX   */    
N#define SYS_ALT_MFP_PD7_CAN0TX      NULL
N#define SYS_ALT_MFP1_PD7_CAN0TX     NULL
N
N#define SYS_GPD_MFP_PD7_Msk         (1UL<<7)      /*!< GPD_MFP PD.7 mask */ 
N
N//PD.8   
N#define SYS_GPD_MFP_PD8_GPIO        0x00000000UL  /*!< GPD_MFP PD.8 setting for GPIO */       
N#define SYS_ALT_MFP_PD8_GPIO        NULL
N#define SYS_ALT_MFP1_PD8_GPIO       NULL
N
N#define SYS_GPD_MFP_PD8_SS30        (1UL<<8)      /*!< GPD_MFP PD.8 setting for SPI3 SS30   */    
N#define SYS_ALT_MFP_PD8_SS30        NULL
N#define SYS_ALT_MFP1_PD8_SS30       NULL
N
N#define SYS_GPD_MFP_PD8_Msk         (1UL<<8)      /*!< GPD_MFP PD.8 mask */ 
N
N//PD.9   
N#define SYS_GPD_MFP_PD9_GPIO        0x00000000UL  /*!< GPD_MFP PD.9 setting for GPIO */       
N#define SYS_ALT_MFP_PD9_GPIO        NULL
N#define SYS_ALT_MFP1_PD9_GPIO       NULL
N
N#define SYS_GPD_MFP_PD9_SPI3CLK     (1UL<<9)      /*!< GPD_MFP PD.9 setting for SPI3CLK   */    
N#define SYS_ALT_MFP_PD9_SPI3CLK     NULL
N#define SYS_ALT_MFP1_PD9_SPI3CLK    NULL
N
N#define SYS_GPD_MFP_PD9_Msk         (1UL<<9)      /*!< GPD_MFP PD.9 mask */ 
N
N//PD.10   
N#define SYS_GPD_MFP_PD10_GPIO       0x00000000UL  /*!< GPD_MFP PD.10 setting for GPIO */       
N#define SYS_ALT_MFP_PD10_GPIO       NULL
N#define SYS_ALT_MFP1_PD10_GPIO      NULL
N
N#define SYS_GPD_MFP_PD10_MISO30     (1UL<<10)     /*!< GPD_MFP PD.10 setting for MISO30   */    
N#define SYS_ALT_MFP_PD10_MISO30     NULL
N#define SYS_ALT_MFP1_PD10_MISO30    NULL
N
N#define SYS_GPD_MFP_PD10_Msk        (1UL<<10)     /*!< GPD_MFP PD.10 mask */
N
N//PD.11   
N#define SYS_GPD_MFP_PD11_GPIO       0x00000000UL  /*!< GPD_MFP PD.11 setting for GPIO */       
N#define SYS_ALT_MFP_PD11_GPIO       NULL
N#define SYS_ALT_MFP1_PD11_GPIO      NULL
N
N#define SYS_GPD_MFP_PD11_MOSI30     (1UL<<11)     /*!< GPD_MFP PD.11 setting for MOSI30   */    
N#define SYS_ALT_MFP_PD11_MOSI30     NULL
N#define SYS_ALT_MFP1_PD11_MOSI30    NULL
N
N#define SYS_GPD_MFP_PD11_Msk        (1UL<<11)     /*!< GPD_MFP PD.11 mask */
N
N//PD.12   
N#define SYS_GPD_MFP_PD12_GPIO       0x00000000UL  /*!< GPD_MFP PD.12 setting for GPIO */       
N#define SYS_ALT_MFP_PD12_GPIO       NULL
N#define SYS_ALT_MFP1_PD12_GPIO      NULL
N
N#define SYS_GPD_MFP_PD12_MISO31     (1UL<<12)     /*!< GPD_MFP PD.12 setting for MISO31   */    
N#define SYS_ALT_MFP_PD12_MISO31     NULL
N#define SYS_ALT_MFP1_PD12_MISO31    NULL
N
N#define SYS_GPD_MFP_PD12_Msk        (1UL<<12)     /*!< GPD_MFP PD.12 mask */
N
N//PD.13   
N#define SYS_GPD_MFP_PD13_GPIO       0x00000000UL  /*!< GPD_MFP PD.13 setting for GPIO */       
N#define SYS_ALT_MFP_PD13_GPIO       NULL
N#define SYS_ALT_MFP1_PD13_GPIO      NULL
N
N#define SYS_GPD_MFP_PD13_MOSI31     (1UL<<13)     /*!< GPD_MFP PD.13 setting for MOSI31   */    
N#define SYS_ALT_MFP_PD13_MOSI31     NULL
N#define SYS_ALT_MFP1_PD13_MOSI31    NULL
N
N#define SYS_GPD_MFP_PD13_Msk        (1UL<<13)     /*!< GPD_MFP PD.13 mask */
N
N//PD.14   
N#define SYS_GPD_MFP_PD14_GPIO       0x00000000UL  /*!< GPD_MFP PD.14 setting for GPIO */       
N#define SYS_ALT_MFP_PD14_GPIO       NULL
N#define SYS_ALT_MFP1_PD14_GPIO      NULL
N
N#define SYS_GPD_MFP_PD14_RXD2       (1UL<<14)     /*!< GPD_MFP PD.14 setting for RXD2 */    
N#define SYS_ALT_MFP_PD14_RXD2       NULL
N#define SYS_ALT_MFP1_PD14_RXD2      NULL
N
N#define SYS_GPD_MFP_PD14_Msk        (1UL<<14)     /*!< GPD_MFP PD.14 mask */
N
N//PD.15   
N#define SYS_GPD_MFP_PD15_GPIO       0x00000000UL  /*!< GPD_MFP PD.15 setting for GPIO */       
N#define SYS_ALT_MFP_PD15_GPIO       NULL
N#define SYS_ALT_MFP1_PD15_GPIO      NULL
N
N#define SYS_GPD_MFP_PD15_TXD2       (1UL<<15)     /*!< GPD_MFP PD.15 setting for TXD2 */    
N#define SYS_ALT_MFP_PD15_TXD2       NULL
N#define SYS_ALT_MFP1_PD15_TXD2      NULL
N
N#define SYS_GPD_MFP_PD15_Msk        (1UL<<15)     /*!< GPD_MFP PD.15 mask */
N
N//PE.0   
N#define SYS_GPE_MFP_PE0_GPIO        0x00000000UL  /*!< GPE_MFP PE.0 setting for GPIO */       
N#define SYS_ALT_MFP_PE0_GPIO        NULL
N#define SYS_ALT_MFP1_PE0_GPIO       NULL
N
N#define SYS_GPE_MFP_PE0_PWM6        (1UL<<0)      /*!< GPE_MFP PE.0 setting for PWM6   */    
N#define SYS_ALT_MFP_PE0_PWM6        NULL
N#define SYS_ALT_MFP1_PE0_PWM6       NULL
N
N#define SYS_GPE_MFP_PE0_Msk         (1UL<<0)      /*!< GPE_MFP PE.0 mask */
N
N//PE.1   
N#define SYS_GPE_MFP_PE1_GPIO        0x00000000UL  /*!< GPE_MFP PE.1 setting for GPIO */       
N#define SYS_ALT_MFP_PE1_GPIO        NULL
N#define SYS_ALT_MFP1_PE1_GPIO       NULL
N
N#define SYS_GPE_MFP_PE1_PWM7        (1UL<<1)      /*!< GPE_MFP PE.1 setting for PWM7   */    
N#define SYS_ALT_MFP_PE1_PWM7        NULL
N#define SYS_ALT_MFP1_PE1_PWM7       NULL
N
N#define SYS_GPE_MFP_PE1_Msk         (1UL<<1)      /*!< GPE_MFP PE.1 mask */
N
N//PE.5   
N#define SYS_GPE_MFP_PE5_GPIO        0x00000000UL   /*!< GPE_MFP PE.5 setting for GPIO */    
N#define SYS_ALT_MFP_PE5_GPIO        0x00000000UL   /*!< ALT_MFP PE.5 setting for GPIO */
N#define SYS_ALT_MFP1_PE5_GPIO       NULL
N
N#define SYS_GPE_MFP_PE5_PWM5        (1UL<<5)       /*!< GPE_MFP PE.5 setting for PWM5  */    
N#define SYS_ALT_MFP_PE5_PWM5        0x00000000UL   /*!< ALT_MFP PE.5 setting for PWM5  */ 
N#define SYS_ALT_MFP1_PE5_PWM5       NULL
N
N#define SYS_GPE_MFP_PE5_T1EX        (1UL<<5)       /*!< GPE_MFP PE.5 setting for T1EX  */    
N#define SYS_ALT_MFP_PE5_T1EX        (1UL<<25)      /*!< ALT_MFP PE.5 setting for T1EX  */ 
N#define SYS_ALT_MFP1_PE5_T1EX       NULL
N
N#define SYS_GPE_MFP_PE5_Msk         (1UL<<5)       /*!< GPE_MFP PE.5 mask */      
N#define SYS_ALT_MFP_PE5_Msk         (1UL<<25)      /*!< ALT_MFP PE.5 mask */ 
N
N//PF.0   
N#define SYS_GPF_MFP_PF0_GPIO        0x00000000UL  /*!< GPF_MFP PF.0 setting for GPIO */       
N#define SYS_ALT_MFP_PF0_GPIO        NULL
N#define SYS_ALT_MFP1_PF0_GPIO       NULL
N
N#define SYS_GPF_MFP_PF0_XT1_OUT     (1UL<<0)      /*!< GPF_MFP PF.0 setting for XT1_OUT   */    
N#define SYS_ALT_MFP_PF0_XT1_OUT     NULL
N#define SYS_ALT_MFP1_PF0_XT1_OUT    NULL
N
N#define SYS_GPF_MFP_PF0_Msk         (1UL<<0)      /*!< GPF_MFP PF.0 mask */
N
N//PF.1   
N#define SYS_GPF_MFP_PF1_GPIO        0x00000000UL  /*!< GPF_MFP PF.1 setting for GPIO */       
N#define SYS_ALT_MFP_PF1_GPIO        NULL
N#define SYS_ALT_MFP1_PF1_GPIO       NULL
N
N#define SYS_GPF_MFP_PF1_XT1_IN      (1UL<<1)      /*!< GPF_MFP PF.1 setting for XT1_IN   */    
N#define SYS_ALT_MFP_PF1_XT1_IN      NULL
N#define SYS_ALT_MFP1_PF1_XT1_IN     NULL
N
N#define SYS_GPF_MFP_PF1_Msk         (1UL<<1)      /*!< GPF_MFP PF.1 mask */
N
N//PF.2   
N#define SYS_GPF_MFP_PF2_GPIO        0x00000000UL  /*!< GPF_MFP PF.2 setting for GPIO */       
N#define SYS_ALT_MFP_PF2_GPIO        NULL
N#define SYS_ALT_MFP1_PF2_GPIO       NULL
N
N#define SYS_GPF_MFP_PF2_PS2DAT      (1UL<<2)      /*!< GPF_MFP PF.2 setting for PS2DAT   */    
N#define SYS_ALT_MFP_PF2_PS2DAT      NULL
N#define SYS_ALT_MFP1_PF2_PS2DAT     NULL
N
N#define SYS_GPF_MFP_PF2_Msk         (1UL<<2)      /*!< GPF_MFP PF.2 mask */
N
N//PF.3   
N#define SYS_GPF_MFP_PF3_GPIO        0x00000000UL  /*!< GPF_MFP PF.3 setting for GPIO */       
N#define SYS_ALT_MFP_PF3_GPIO        NULL
N#define SYS_ALT_MFP1_PF3_GPIO       NULL
N
N#define SYS_GPF_MFP_PF3_PS2CLK      (1UL<<3)      /*!< GPF_MFP PF.3 setting for PS2CLK   */    
N#define SYS_ALT_MFP_PF3_PS2CLK      NULL
N#define SYS_ALT_MFP1_PF3_PS2CLK     NULL
N
N#define SYS_GPF_MFP_PF3_Msk         (1UL<<3)      /*!< GPF_MFP PF.3 mask */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_VL_4_5V     0x06UL       /*!< Setting Brown Out Detector Threshold Voltage as 4.5V */
N#define SYS_BODCR_BOD_VL_3_8V     0x04UL       /*!< Setting Brown Out Detector Threshold Voltage as 3.8V */ 
N#define SYS_BODCR_BOD_VL_2_7V     0x02UL       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V     0x00UL       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macro                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define _SYS_RESET_CPU()   (SYS->IPRSTC1 |= SYS_IPRSTC1_CPU_RST_Msk) /*!< Reset CPU by setting CPU_RST bit from IPRSTC1 Register         */
N#define _SYS_RESET_CHIP()  (SYS->IPRSTC1 = SYS_IPRSTC1_CHIP_RST_Msk) /*!< Reset Whole Chip by setting CHIP_RST bit from IPRSTC1 Register */
N
N//PA.0
N#define _SYS_GPA_MFP_PA0(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA0_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA0(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA0_Msk))| (x))
N
N//PA.1
N#define _SYS_GPA_MFP_PA1(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA1_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA1(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA1_Msk))| (x))
N
N//PA.2
N#define _SYS_GPA_MFP_PA2(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA2_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA2(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA2_Msk))| (x))
N
N//PA.3
N#define _SYS_GPA_MFP_PA3(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA3_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA3(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA3_Msk))| (x))
N
N//PA.4
N#define _SYS_GPA_MFP_PA4(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA4_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA4(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA4_Msk))| (x))
N
N//PA.5
N#define _SYS_GPA_MFP_PA5(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA5_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA5(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA5_Msk))| (x))
N
N//PA.6
N#define _SYS_GPA_MFP_PA6(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA6_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA6(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA6_Msk))| (x))
N
N//PA.7
N#define _SYS_GPA_MFP_PA7(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA7_Msk)) | (x))
N#define _SYS_ALT_MFP_PA7(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PA7_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA7(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA7_Msk))| (x))
N
N//PA.8
N#define _SYS_GPA_MFP_PA8(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA8_Msk)) | (x))
N
N//PA.9
N#define _SYS_GPA_MFP_PA9(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA9_Msk)) | (x))
N
N//PA.10
N#define _SYS_GPA_MFP_PA10(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA10_Msk)) | (x))
N#define _SYS_ALT_MFP_PA10(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PA10_Msk)) | (x))
N
N//PA.11
N#define _SYS_GPA_MFP_PA11(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA11_Msk)) | (x))
N#define _SYS_ALT_MFP_PA11(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PA11_Msk)) | (x))
N
N//PA.12
N#define _SYS_GPA_MFP_PA12(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA12_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA12(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA12_Msk))| (x))
N
N//PA.13
N#define _SYS_GPA_MFP_PA13(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA13_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA13(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA13_Msk))| (x))
N
N//PA.14
N#define _SYS_GPA_MFP_PA14(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA14_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA14(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA14_Msk))| (x))
N
N//PA.15
N#define _SYS_GPA_MFP_PA15(x)    (SYS->GPA_MFP = (SYS->GPA_MFP & (~SYS_GPA_MFP_PA15_Msk)) | (x))
N#define _SYS_ALT_MFP_PA15(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PA15_Msk)) | (x))
N#define _SYS_ALT_MFP1_PA15(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PA15_Msk))| (x))
N
N//PB.0
N#define _SYS_GPB_MFP_PB0(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB0_Msk)) | (x))
N
N//PB.1
N#define _SYS_GPB_MFP_PB1(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB1_Msk)) | (x))
N
N//PB.2
N#define _SYS_GPB_MFP_PB2(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB2_Msk)) | (x))
N#define _SYS_ALT_MFP_PB2(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB2_Msk)) | (x))
N
N//PB.3
N#define _SYS_GPB_MFP_PB3(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB3_Msk)) | (x))
N#define _SYS_ALT_MFP_PB3(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB3_Msk)) | (x))
N#define _SYS_ALT_MFP1_PB3(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT_MFP1_PB3_Msk))| (x))
N
N//PB.4
N#define _SYS_GPB_MFP_PB4(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB4_Msk)) | (x))
N
N//PB.5
N#define _SYS_GPB_MFP_PB5(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB5_Msk)) | (x))
N
N//PB.6
N#define _SYS_GPB_MFP_PB6(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB6_Msk)) | (x))
N
N//PB.7
N#define _SYS_GPB_MFP_PB7(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB7_Msk)) | (x))
N
N//PB.8
N#define _SYS_GPB_MFP_PB8(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB8_Msk)) | (x))
N#define _SYS_ALT_MFP_PB8(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB8_Msk)) | (x))
N
N//PB.9
N#define _SYS_GPB_MFP_PB9(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB9_Msk)) | (x))
N#define _SYS_ALT_MFP_PB9(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB9_Msk)) | (x))
N
N//PB.10
N#define _SYS_GPB_MFP_PB10(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB10_Msk)) | (x))
N#define _SYS_ALT_MFP_PB10(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB10_Msk)) | (x))
N
N//PB.11
N#define _SYS_GPB_MFP_PB11(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB11_Msk)) | (x))
N#define _SYS_ALT_MFP_PB11(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB11_Msk)) | (x))
N
N//PB.12 Reserved
N
N//PB.13
N#define _SYS_GPB_MFP_PB13(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB13_Msk)) | (x))
N
N//PB.14
N#define _SYS_GPB_MFP_PB14(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB14_Msk)) | (x))
N#define _SYS_ALT_MFP_PB14(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB14_Msk)) | (x))
N
N//PB.15
N#define _SYS_GPB_MFP_PB15(x)    (SYS->GPB_MFP = (SYS->GPB_MFP & (~SYS_GPB_MFP_PB15_Msk)) | (x))
N#define _SYS_ALT_MFP_PB15(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PB15_Msk)) | (x))
N
N//PC.0
N#define _SYS_GPC_MFP_PC0(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC0_Msk)) | (x))
N#define _SYS_ALT_MFP_PC0(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PC0_Msk)) | (x))
N
N//PC.1
N#define _SYS_GPC_MFP_PC1(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC1_Msk)) | (x))
N#define _SYS_ALT_MFP_PC1(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PC1_Msk)) | (x))
N
N//PC.2
N#define _SYS_GPC_MFP_PC2(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC2_Msk)) | (x))
N#define _SYS_ALT_MFP_PC2(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PC2_Msk)) | (x))
N
N//PC.3
N#define _SYS_GPC_MFP_PC3(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC3_Msk)) | (x))
N#define _SYS_ALT_MFP_PC3(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PC3_Msk)) | (x))
N
N//PC.4
N#define _SYS_GPC_MFP_PC4(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC4_Msk)) | (x))
N
N//PC.5
N#define _SYS_GPC_MFP_PC5(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC5_Msk)) | (x))
N
N//PC.6
N#define _SYS_GPC_MFP_PC6(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC6_Msk)) | (x))
N#define _SYS_ALT_MFP1_PC6(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT1_MFP_PC6_Msk))| (x))
N
N//PC.7
N#define _SYS_GPC_MFP_PC7(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC7_Msk)) | (x))
N#define _SYS_ALT_MFP1_PC7(x)   (SYS->ALT_MFP1= (SYS->ALT_MFP1& (~SYS_ALT1_MFP_PC7_Msk))| (x))
N
N//PC.8
N#define _SYS_GPC_MFP_PC8(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC8_Msk)) | (x))
N
N//PC.9
N#define _SYS_GPC_MFP_PC9(x)    (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC9_Msk)) | (x))
N
N//PC.10
N#define _SYS_GPC_MFP_PC10(x)   (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC10_Msk)) | (x))
N
N//PC.11
N#define _SYS_GPC_MFP_PC11(x)   (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC11_Msk)) | (x))
N
N//PC.12
N#define _SYS_GPC_MFP_PC12(x)   (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC12_Msk)) | (x))
N
N//PC.13
N#define _SYS_GPC_MFP_PC13(x)   (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC13_Msk)) | (x))
N
N//PC.14
N#define _SYS_GPC_MFP_PC14(x)   (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC14_Msk)) | (x))
N
N//PC.15
N#define _SYS_GPC_MFP_PC15(x)   (SYS->GPC_MFP = (SYS->GPC_MFP & (~SYS_GPC_MFP_PC15_Msk)) | (x))
N
N//PD.0
N#define _SYS_GPD_MFP_PD0(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD0_Msk)) | (x))
N//PD.1
N#define _SYS_GPD_MFP_PD1(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD1_Msk)) | (x))
N//PD.2
N#define _SYS_GPD_MFP_PD2(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD2_Msk)) | (x))
N//PD.3
N#define _SYS_GPD_MFP_PD3(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD3_Msk)) | (x))
N//PD.4
N#define _SYS_GPD_MFP_PD4(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD4_Msk)) | (x))
N//PD.5
N#define _SYS_GPD_MFP_PD5(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD5_Msk)) | (x))
N//PD.6
N#define _SYS_GPD_MFP_PD6(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD6_Msk)) | (x))
N//PD.7
N#define _SYS_GPD_MFP_PD7(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD7_Msk)) | (x))
N//PD.8
N#define _SYS_GPD_MFP_PD8(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD8_Msk)) | (x))
N//PD.9
N#define _SYS_GPD_MFP_PD9(x)    (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD9_Msk)) | (x))
N//PD.10
N#define _SYS_GPD_MFP_PD10(x)   (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD10_Msk))| (x))
N//PD.11
N#define _SYS_GPD_MFP_PD11(x)   (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD11_Msk))| (x))
N//PD.12
N#define _SYS_GPD_MFP_PD12(x)   (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD12_Msk))| (x))
N//PD.13
N#define _SYS_GPD_MFP_PD13(x)   (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD13_Msk))| (x))
N//PD.14
N#define _SYS_GPD_MFP_PD14(x)   (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD14_Msk))| (x))
N//PD.15
N#define _SYS_GPD_MFP_PD15(x)   (SYS->GPD_MFP = (SYS->GPD_MFP & (~SYS_GPD_MFP_PD15_Msk))| (x))
N
N//PE.0
N#define _SYS_GPE_MFP_PE0(x)    (SYS->GPE_MFP = (SYS->GPE_MFP & (~SYS_GPE_MFP_PE0_Msk)) | (x))
N
N//PE.1
N#define _SYS_GPE_MFP_PE1(x)    (SYS->GPE_MFP = (SYS->GPE_MFP & (~SYS_GPE_MFP_PE1_Msk)) | (x))
N
N//PE.5
N#define _SYS_GPE_MFP_PE5(x)    (SYS->GPE_MFP = (SYS->GPE_MFP & (~SYS_GPE_MFP_PE5_Msk)) | (x))
N#define _SYS_ALT_MFP_PE5(x)    (SYS->ALT_MFP = (SYS->ALT_MFP & (~SYS_ALT_MFP_PE5_Msk)) | (x))
N
N//PF.0
N#define _SYS_GPF_MFP_PF0(x)    (SYS->GPF_MFP = (SYS->GPF_MFP & (~SYS_GPF_MFP_PF0_Msk)) | (x))
N//PF.1
N#define _SYS_GPF_MFP_PF1(x)    (SYS->GPF_MFP = (SYS->GPF_MFP & (~SYS_GPF_MFP_PF1_Msk)) | (x))
N//PF.2
N#define _SYS_GPF_MFP_PF2(x)    (SYS->GPF_MFP = (SYS->GPF_MFP & (~SYS_GPF_MFP_PF2_Msk)) | (x))
N//PF.3
N#define _SYS_GPF_MFP_PF3(x)    (SYS->GPF_MFP = (SYS->GPF_MFP & (~SYS_GPF_MFP_PF3_Msk)) | (x))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief    Get PLL Clock Output Frequency  
N *
N * @param    None
N *
N * @return   PLL clock output frequency 
N *
N * @details  To get actual PLL clock output frequency. The clock uint is in Hz.
N */
Nstatic __INLINE uint32_t DrvSYS_GetPLLClockFreq(void)
Xstatic __inline uint32_t DrvSYS_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUT_DV :DEF: {1, 2, 2, 4} */
N    uint32_t u32Reg;
N
N    u32PllFreq = 0;
N    u32Reg = SYSCLK->PLLCON;
X    u32Reg = ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON;
N    if((u32Reg & (SYSCLK_PLLCON_PD_Msk | SYSCLK_PLLCON_OE_Msk)) == 0)
X    if((u32Reg & ((1ul << 16) | (1ul << 18))) == 0)
N    {    
N        /* PLL is enabled and output enabled */
N
N        u32FIN = (u32Reg & SYSCLK_PLLCON_PLL_SRC_Msk)?__IRC22M:__XTAL;
X        u32FIN = (u32Reg & (1ul << 19))?(22118400UL):(12000000UL);
N        if(u32Reg & SYSCLK_PLLCON_BP_Msk)
X        if(u32Reg & (1ul << 17))
N        {
N            /* PLL is in bypass mode */
N            u32PllFreq = u32FIN;
N        }
N        else 
N        {
N            /* PLL is in normal work mode */
N            u32NO = au8NoTbl[((u32Reg & SYSCLK_PLLCON_OUT_DV_Msk) >> SYSCLK_PLLCON_OUT_DV_Pos)];
X            u32NO = au8NoTbl[((u32Reg & (3ul << 14)) >> 14)];
N            u32NF  = ((u32Reg & SYSCLK_PLLCON_FB_DV_Msk) >> SYSCLK_PLLCON_FB_DV_Pos) + 2;
X            u32NF  = ((u32Reg & (0x1FFul << 0)) >> 0) + 2;
N            u32NR  = ((u32Reg & SYSCLK_PLLCON_IN_DV_Msk) >> SYSCLK_PLLCON_IN_DV_Pos) + 2;
X            u32NR  = ((u32Reg & (0x1Ful << 9)) >> 9) + 2;
N            /* u32FIN is shifted 2 bits to avoid overflow */
N            u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2); 
N        }
N    }
N
N    return u32PllFreq;
N}
N
N
N/**
N * @brief    Waiting for clock stable
N *
N * @param    Mask bits of CLKSTATUS register. Including:
N *           SYSCLK_CLKSTATUS_CLK_SW_FAIL_Msk
N *           SYSCLK_CLKSTATUS_IRC22M_STB_Msk
N *           SYSCLK_CLKSTATUS_IRC10K_STB_Msk
N *           SYSCLK_CLKSTATUS_PLL_STB_Msk
N *           SYSCLK_CLKSTATUS_XTL12M_STB_Msk
N *
N * @return   None
N *
N * @details  To wait for clock ready by specified CLKSTATUS bit or timeout (~5ms)
N */
Nstatic __INLINE void SYS_WaitingForClockReady(uint32_t u32Mask)
Xstatic __inline void SYS_WaitingForClockReady(uint32_t u32Mask)
N{
N    int32_t i32TimeOutCnt;
N
N    i32TimeOutCnt = __HSI / 200; /* About 5ms */
X    i32TimeOutCnt = (50000000UL) / 200;  
N    
N    while((SYSCLK->CLKSTATUS & u32Mask) != u32Mask)
X    while((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSTATUS & u32Mask) != u32Mask)
N    {
N        if(i32TimeOutCnt-- <= 0)
N            break;    
N    }
N}
N
N/**
N * @brief      Generate the Delay Time by Systick
N *
N * @param[in]  us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N *                             50MHz => 335544us, 48MHz => 349525us, 28MHz => 699050us ...
N *
N * @return     None
N *
N * @details    Use the SysTick to generate the delay time and the UNIT is in us. 
N *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N */
Nstatic __INLINE void SYS_SysTickDelay(uint32_t us)
Xstatic __inline void SYS_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD = us * CyclesPerUs;
N    SysTick->VAL  =  (0x00);
X    ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL  =  (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL = (1ul << 2) | (1ul << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL & (1ul << 16)) == 0);
N}
N
N
N/**
N * @brief      Enable CKO clock
N *
N * @param[in]  u32ClkSrc  Select the source clock for CKO. It could be 
N *                        SYSCLK_CLKSEL2_FRQDIV_XTAL, SYSCLK_CLKSEL2_FRQDIV_HCLK or SYSCLK_CLKSEL2_FRQDIV_IRC22M.
N * @param[in]  u32ClkDiv  Set the clock divider to CKO. 0 <= u32ClkDiv <= 15
N *
N * @return     None
N *
N * @details    Ouput selected clock to CKO. The output clock frequency is divided by u32ClkDiv. 
N *             The formula is:
N *                 CKO frequency = (Clock source frequency) / 2^(u32ClkDiv + 1)
N *             This function is just used to set CKO clock.
N *             User must enable I/O for CKO clock output pin by themselves.
N */
Nstatic __INLINE void SYS_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
Xstatic __inline void SYS_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
N{
N    /* CKO = clock source / 2^(u32ClkDiv + 1) */
N    SYSCLK->FRQDIV = SYSCLK_FRQDIV_DIVIDER_EN_Msk | u32ClkDiv;
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->FRQDIV = (1ul << 4) | u32ClkDiv;
N
N    /* Enable CKO clock source */
N    SYSCLK->APBCLK |= SYSCLK_APBCLK_FDIV_EN_Msk;
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->APBCLK |= (1ul << 6);
N
N    /* Select CKO clock source */
N    SYSCLK->CLKSEL2 = (SYSCLK->CLKSEL2 & (~SYSCLK_CLKSEL2_FRQDIV_S_Msk)) | u32ClkSrc;
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL2 = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL2 & (~(3ul << 2))) | u32ClkSrc;
N}
N
N
N/**
N * @brief      Disable CKO clock
N *
N * @return     None
N *
N * @details    Disable CKO clock 
N *
N */
Nstatic __INLINE void SYS_DisableCKO(void)
Xstatic __inline void SYS_DisableCKO(void)
N{
N    /* Disable CKO clock source */
N    SYSCLK->APBCLK &= (~SYSCLK_APBCLK_FDIV_EN_Msk);
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->APBCLK &= (~(1ul << 6));
N}
N
N/**
N * @brief      Initialization for power down (Deep sleep)
N *
N * @details    To inital the power down control registers
N *
N * @note   
N *             User must call SYS_UnlockReg() to unlock protected registers before calling this function 
N */
Nstatic __INLINE void SYS_PowerDownInit(void)
Xstatic __inline void SYS_PowerDownInit(void)
N{   
N    SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SCR = (1ul << 2);
N    SYSCLK->PWRCON |= (SYSCLK_PWRCON_PD_WAIT_CPU_Msk | SYSCLK_PWRCON_PWR_DOWN_EN_Msk | SYSCLK_PWRCON_PD_WU_STS_Msk);
X    ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PWRCON |= ((1ul << 8) | (1ul << 7) | (1ul << 6));
N}
N
N
N/**
N * @brief      Unlock the protected registers
N *
N * @details    To unlock the protected register to allow write access
N *
N */
Nstatic __INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{   
N    do
N    {
N        SYS->REGWRPROT = 0x59;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x59;
N        SYS->REGWRPROT = 0x16;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x16;
N        SYS->REGWRPROT = 0x88;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x88;
N    }while(SYS->REGWRPROT == 0);
X    }while(((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT == 0);
N}
N
N/**
N * @brief      Lock the protected registers
N *
N * @details    To lock the protected register to forbid write access
N *
N */
Nstatic __INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{   
N    SYS->REGWRPROT = 0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0;
N}
N
N
N/**
N  * @} End of SYS Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif  //__SYS_H__
N
L 6296 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "ADC.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\ADC.h" 1
N/**************************************************************************//**
N * @file     ADC.h
N * @version  V1.0
N * $Revision: 5 $
N * $Date: 12/08/08 4:53p $
N * @brief    NUC200 Series ADC Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup ADC_FUNC ADC Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADCR Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCR_ADEN_CONVERTER_DISABLE   (0UL<<ADC_ADCR_ADEN_Pos)     /*!< ADC Converter Disable          */
N#define ADC_ADCR_ADEN_CONVERTER_ENABLE    (1UL<<ADC_ADCR_ADEN_Pos)     /*!< ADC Converter Enable           */
N
N#define ADC_ADCR_ADMD_SINGLE            (0UL<<ADC_ADCR_ADMD_Pos)     /*!< Single mode                */
N#define ADC_ADCR_ADMD_SINGLE_CYCLE      (2UL<<ADC_ADCR_ADMD_Pos)     /*!< Single cycle scan mode     */
N#define ADC_ADCR_ADMD_CONTINUOUS        (3UL<<ADC_ADCR_ADMD_Pos)     /*!< Continuous scan mode       */
N
N#define ADC_ADCR_TRGS_STADC             (0UL<<ADC_ADCR_TRGS_Pos)     /*!< STADC external pin trigger */
N#define ADC_ADCR_TRGS_PWM_TRG           (3UL<<ADC_ADCR_TRGS_Pos)     /*!< PWM center-aligned trigger */
N
N#define ADC_ADCR_TRGCOND_LOW_LEVEL      (0UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Low level active     */
N#define ADC_ADCR_TRGCOND_HIGH_LEVEL     (1UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC High level active    */
N#define ADC_ADCR_TRGCOND_FALLING_EDGE   (2UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Falling edge active  */
N#define ADC_ADCR_TRGCOND_RISING_EDGE    (3UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Rising edge active   */
N
N#define ADC_ADCR_TRGEN_DISABLE          (0UL<<ADC_ADCR_TRGEN_Pos)    /*!< Enable or disable triggering of A/D conversion by external STADC pin.   */
N#define ADC_ADCR_TRGEN_ENABLE           (1UL<<ADC_ADCR_TRGEN_Pos)    /*!< Disable or disable triggering of A/D conversion by external STADC pin.  */
N
N#define ADC_ADCR_DIFFEN_SINGLE_END      (0UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Single end input mode      */
N#define ADC_ADCR_DIFFEN_DIFFERENTIAL    (1UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Differential input type    */
N
N#define ADC_ADCR_DMOF_UNSIGNED_OUTPUT   (0UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define ADC_ADCR_DMOF_TWOS_COMPLEMENT   (1UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCHER Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL         (0<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the external analog input                   */   
N#define ADC_ADCHER_PRESEL_INT_BANDGAP              (1<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the internal bandgap voltage                */
N#define ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR   (2<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the output of internal temperature sensor   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCMPR Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPD(x)                    ((x) << ADC_ADCMPR_CMPD_Pos)          /*!< Compare value for compare function            */
N#define ADC_ADCMPR_CMPMATCNT(x)               (((x)-1) << ADC_ADCMPR_CMPMATCNT_Pos) /*!< Match count for compare function              */
N#define ADC_ADCMPR_CMPCH(x)                   ((x) << ADC_ADCMPR_CMPCH_Pos)  /*!< Compare channel for compare function                 */
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0<<ADC_ADCMPR_CMPCOND_Pos)    /*!< The compare condition is "less than".                */   
N#define ADC_ADCHER_CMPCOND_GREATER_OR_EQUAL   (1<<ADC_ADCMPR_CMPCOND_Pos)    /*!< The compare condition is "greater than or equal to". */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Operation Mode Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SINGLE_MODE         0   /*!< ADC single mode            */
N#define ADC_SINGLE_CYCLE_MODE   2   /*!< ADC single-cycle scan mode */
N#define ADC_CONTINUOUS_MODE     3   /*!< ADC continuous scan mode   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Trigger Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LOW_LEVEL      0   /*!< ADC external trigger condition is low level trigger    */
N#define ADC_HIGH_LEVEL     1   /*!< ADC external trigger condition is high level trigger   */
N#define ADC_FALLING_EDGE   2   /*!< ADC external trigger condition is falling edge trigger */
N#define ADC_RISING_EDGE    3   /*!< ADC external trigger condition is rising edge trigger  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Compare Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LESS_THAN          0   /*!< ADC compare condition is "less than the compare value"                */
N#define ADC_GREATER_OR_EQUAL   1   /*!< ADC compare condition is "greater than or equal to the compare value" */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Constant Definitions of ADC Channel 7 Input Source                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_CH7_EXT_INPUT_SIGNAL         0   /*!< External input signal       */
N#define ADC_CH7_INT_BANDGAP              1   /*!< Internal band-gap voltage   */
N#define ADC_CH7_INT_TEMPERATURE_SENSOR   2   /*!< Internal temperature sensor */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @details     ADC start convert
N */
N#define _ADC_START_CONVERT()                (ADC->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N * @details     ADC stop convert
N */
N#define _ADC_STOP_CONVERT()                 (ADC->ADCR &= ~ADC_ADCR_ADST_Msk)
N
N/**
N * @details     ADC convert enable
N */
N#define _ADC_CONVERT_ENABLE()               (ADC->ADCR |= ADC_ADCR_ADEN_Msk)
N
N/**
N * @details     ADC convert disable
N */
N#define _ADC_CONVERTER_DISABLE()              (ADC->ADCR &= ~ADC_ADCR_ADEN_Msk)                                   
N
N/**
N * @details     Enable external trigger  
N */
N#define _ADC_ENABLE_EXT_TRG()               (ADC->ADCR |= ADC_ADCR_TRGEN_Msk)
N
N/**
N * @details     Disable external trigger  
N */
N#define _ADC_DISABLE_EXT_TRG()              (ADC->ADCR &= ~ADC_ADCR_TRGEN_Msk)
N
N/**
N * @details     Enable ADC interrupt  
N */
N#define _ADC_ENABLE_ADC_INT()                   (ADC->ADCR |= ADC_ADCR_ADIE_Msk)
N
N/**
N * @details     Disable ADC interrupt  
N */
N#define _ADC_DISABLE_ADC_INT()                  (ADC->ADCR &= ~ADC_ADCR_ADIE_Msk)
N
N/**
N * @brief       Set ADC ADMD bit field
N *
N * @param[in]   Mode        A/D Converter Operation Mode, should be:            
N *                          -  ADC_SINGLE_MODE       : Single mode
N *                          -  ADC_SINGLE_CYCLE_MODE : Single cycle scan mode
N *                          -  ADC_CONTINUOUS_MODE   : Continuous scan mode 
N * @return      None
N *
N * @details     Set ADC A/D convert opreration mode
N */
N#define _ADC_SET_OPMODE(Mode)               (ADC->ADCR = ((ADC->ADCR & ~ADC_ADCR_ADMD_Msk) | ((Mode)<<ADC_ADCR_ADMD_Pos)))   
N
N/**
N * @brief       Get ADC ADMD bit field
N *
N * @param[in]   None
N * @return      Mode        A/D Converter Operation Mode, should be:
N *                          -  ADC_SINGLE_MODE        : Single mode
N *                          -  ADC_SINGLE_CYCLE_MODE  : Single cycle scan mode
N *                          -  ADC_CONTINUOUS_MODE    : Continuous scan mode
N *
N * @details     Get ADC convert opreration mode
N */
N#define _ADC_GET_OPMODE()                   ((ADC->ADCR & ADC_ADCR_ADMD_Msk)>>ADC_ADCR_ADMD_Pos)
N
N/**
N * @brief       Set ADC DIFFEN bit field
N *
N * @param[in]   None
N * @return      None
N *
N * @details     Configure the ADC analog input as differential input
N */
N#define _ADC_SET_DIFFERENTIAL_INPUT_MODE()           (ADC->ADCR |= ADC_ADCR_DIFFEN_Msk)
N
N/**
N * @brief       Set ADC DIFFEN bit field
N *
N * @param[in]   None
N * @return      None
N *
N * @details     Configure the ADC analog input as single-end input
N */
N#define _ADC_SET_SINGLE_END_INPUT_MODE()           (ADC->ADCR = ((ADC->ADCR & ~ADC_ADCR_DIFFEN_Msk)))
N
N/**
N * @brief       Set ADC TRGCOND bit field
N *
N * @param[in]   TrgCond     External trigger condition , should be:            
N *                          -  ADC_LOW_LEVEL    : STADC Low level active
N *                          -  ADC_HIGH_LEVEL   : STADC High level active
N *                          -  ADC_FALLING_EDGE : STADC Falling edge active
N *                          -  ADC_RISING_EDGE  : STADC Rising edge active
N * @return      None
N *
N * @details     Set ADC external trigger condition
N */
N#define _ADC_SET_TRG_COND(TrgCond)          (ADC->ADCR = ((ADC->ADCR &~ADC_ADCR_TRGCOND_Msk)|((TrgCond)<<ADC_ADCR_TRGCOND_Pos)))
N
N/**
N * @brief       Get converstion data of specified channel 
N *
N * @param[in]   Ch         ADC Channel , should be:            
N *                          -  0-7
N * @return      16-bit data 
N *
N * @details     Read RSLT bit field to get conversion data 
N */
N#define _ADC_GET_CONVERSION_DATA(Ch)        ((ADC->ADDR[(Ch)] & ADC_ADDR_RSLT_Msk)>>ADC_ADDR_RSLT_Pos)
N
N/**
N * @brief       Get data overrun flag 
N *
N * @param[in]   Ch         ADC Channel , should be:            
N *                          -  0-7
N * @retval      1   The data overrun flag of The specified channel is set.
N * @retval      0   The data overrun flag of The specified channel is cleared.
N *
N * @details     Read OVERRUN bit field to get specified channel status
N */
N#define _ADC_IS_DATA_OVERRUN(Ch)            ((ADC->ADSR & (1<<((Ch)+ADC_ADSR_OVERRUN_Pos)))?1:0)
N
N/**
N * @brief       Get data valid flag 
N *
N * @param[in]   Ch         ADC Channel , should be:            
N *                          -  0-7
N * @retval      1   The data valid flag of The specified channel is set.
N * @retval      0   The data valid flag of The specified channel is cleared.
N *
N * @details     Read VALID bit field to get specified channel status
N */
N#define _ADC_IS_DATA_VALID(Ch)              ((ADC->ADSR & (1<<((Ch)+ADC_ADSR_VALID_Pos)))?1:0)
N
N/**
N * @details     Check if ADC conversion done or not
N */
N#define _ADC_IS_COVERSION_DONE()            ((ADC->ADSR & ADC_ADSR_ADF_Msk) >> ADC_ADSR_ADF_Pos)
N
N/**
N * @details     A while loop to check if ADC conversion done or not. Exit the loop if ADC coversion is done
N */
N#define _ADC_WAIT_COVERSION_DONE()          while(!_ADC_IS_COVERSION_DONE())
N
N/**
N * @details     Enable specified comparator interrupt
N */
N#define _ADC_ENABLE_CMP_INT(Ch)         (ADC->ADCMPR[(Ch)] |= ADC_ADCMPR_CMPIE_Msk)
N
N/**
N * @details     Disable specified comparator interrupt
N */
N#define _ADC_DISABLE_CMP_INT(Ch)        (ADC->ADCMPR[(Ch)] &= ~ADC_ADCMPR_CMPIE_Msk)
N
N/**
N * @details     Enable compare function
N */
N#define _ADC_ENABLE_CMP(Ch)             (ADC->ADCMPR[(Ch)] |= ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @details     Disable compare function
N */
N#define _ADC_DISABLE_CMP(Ch)            (ADC->ADCMPR[(Ch)] &= ~ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @details     Set comparison data
N */
N#define _ADC_SET_CMP_DATA(Ch, CmpData)   (ADC->ADCMPR[(Ch)] = ((ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPD_Msk)|((CmpData)<<ADC_ADCMPR_CMPD_Pos)))
N
N/**
N * @details     Set comparator match count
N */
N#define _ADC_SET_CMP_MATCH_CNT(Ch, CmpCnt)    (ADC->ADCMPR[(Ch)] = ((ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPMATCNT_Msk) | (((CmpCnt)-1)<<ADC_ADCMPR_CMPMATCNT_Pos)))
N
N/**
N * @details     Set compare channel 
N */
N#define _ADC_SET_CMP_CHANNEL(Ch, X)      (ADC->ADCMPR[(Ch)] = (ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPCH_Msk) | ((X)<<ADC_ADCMPR_CMPCH_Pos))
N
N/**
N * @brief       Set compare condition 
N *
N * @param[in]   Ch         Comparator Channel , should be:            
N *                          -  0-1
N * @param[in]   Cond       Compare Condition , should be:            
N *                          - ADC_LESS_THAN         : The compare condition is "less than the compare value"
N *                          - ADC_GREATER_OR_EQUAL  : The compare condition is "greater than or equal to the compare value"
N * @return      None
N *
N * @details     Set the compare condition of the specified comparator
N */
N#define _ADC_SET_CMP_COND(Ch, Cond)         (ADC->ADCMPR[(Ch)] = ((ADC->ADCMPR[(Ch)] & ~ADC_ADCMPR_CMPCOND_Msk) | ((Cond)<<ADC_ADCMPR_CMPCOND_Pos)))
N
N/**
N * @brief       Set comparator 0 for compare configuration
N *
N * @param[in]   CmpCh      Compare ADC Channel , should be:            
N *                          -  0-7
N * @param[in]   CmpCond    Compare Condition , should be:            
N *                          - ADC_LESS_THAN         : The compare condition is "less than the compare value"
N *                          - ADC_GREATER_OR_EQUAL  : The compare condition is "greater than or equal to the compare value"
N * @param[in]   CmpData    Compare Data Value , should be:            
N *                          -  0-0xFFF
N * @param[in]   CmpMatchCount    
N *                         Compare match count, should be:
N *                          -  1-16
N * @return      None
N *
N * @details     Set comparator 0 parameters including compare channel, condition, data and match count.
N */
N#define _ADC_SET_CMP0(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[0] = (ADC->ADCMPR[0] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) | \
N                                                               ((CmpData)<<ADC_ADCMPR_CMPD_Pos) | \
N                                                               (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) | \
N                                                               ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) | \
N                                                               ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
X#define _ADC_SET_CMP0(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[0] = (ADC->ADCMPR[0] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) |                                                                ((CmpData)<<ADC_ADCMPR_CMPD_Pos) |                                                                (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) |                                                                ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) |                                                                ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @brief       Set comparator 1 for compare configuration
N *
N * @param[in]   CmpCh      Compare ADC Channel , should be:            
N *                          -  0-7
N * @param[in]   CmpCond    Compare Condition , should be:            
N *                          - ADC_LESS_THAN         : The compare condition is "less than the compare value"
N *                          - ADC_GREATER_OR_EQUAL  : The compare condition is "greater than or equal to the compare value"
N * @param[in]   CmpData    Compare Data Value , should be:            
N *                          -  0-0xFFF
N * @param[in]   CmpMatchCount    
N *                         Compare match count, should be:
N *                          -  1-16
N * @return      None
N *
N * @details     Set comparator 1 parameters including compare channel, condition, data and match count.
N */
N#define _ADC_SET_CMP1(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[1] = (ADC->ADCMPR[1] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) | \
N                                                               ((CmpData)<<ADC_ADCMPR_CMPD_Pos) | \
N                                                               (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) | \
N                                                               ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) | \
N                                                               ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
X#define _ADC_SET_CMP1(CmpCh, CmpCond, CmpData, CmpMatchCount)  (ADC->ADCMPR[1] = (ADC->ADCMPR[1] & ~(ADC_ADCMPR_CMPD_Msk|ADC_ADCMPR_CMPMATCNT_Msk|ADC_ADCMPR_CMPCH_Msk|ADC_ADCMPR_CMPCOND_Msk)) |                                                                ((CmpData)<<ADC_ADCMPR_CMPD_Pos) |                                                                (((CmpMatchCount)-1)<<ADC_ADCMPR_CMPMATCNT_Pos) |                                                                ((CmpCh)<<ADC_ADCMPR_CMPCH_Pos) |                                                                ((CmpCond)<<ADC_ADCMPR_CMPCOND_Pos) | ADC_ADCMPR_CMPEN_Msk)
N
N/**
N * @brief       Use bitwise to set ADC Channel
N *
N * @param[in]   Bitwise     ADC Channel configure, should be:            
N *                          -  0-0xFF
N * @return      None
N *
N * @details     The function is used to set ADC channel groups.
N *
N */
N#define _ADC_SET_CHANNEL(Bitwise)          (ADC->ADCHER |= ((ADC->ADCHER&~ADC_ADCHER_CHEN_Msk)|(Bitwise)))
N
N/**
N * @brief       Enable specified ADC channel
N *
N * @param[in]   Ch         ADC Channel , should be:            
N *                          -  0-7
N * @return      None
N *
N * @details     The function is used to enable single ADC channel.
N */
N#define _ADC_ENABLE_CHANNEL(Ch)          (ADC->ADCHER |= ((ADC->ADCHER&~ADC_ADCHER_CHEN_Msk)|(1<<(Ch))))
N
N/**
N * @brief       Disable specified ADC channel
N *
N * @param[in]   Ch         ADC Channel , should be:            
N *                          -  0-7
N * @return      None
N *
N * @details     The function is used to disable single ADC channel.
N */
N#define _ADC_DISABLE_CHANNEL(Ch)         (ADC->ADCHER &= ~(1<<(Ch)))
N
N/**
N * @brief       Select the source of the analog input channel 7
N *
N * @param[in]   Option        Analog input select, should be:            
N *                          -  ADC_CH7_EXT_INPUT_SIGNAL        : the external analog input 
N *                          -  ADC_CH7_INT_BANDGAP             : the internal bandgap voltage  
N *                          -  ADC_CH7_INT_TEMPERATURE_SENSOR  : the output of internal temperature sensor 
N * @return      None
N *
N * @details     Select the source of the analog input channel 7
N */
N#define _ADC_CONFIG_CH7(Option)              (ADC->ADCHER = (ADC->ADCHER &~(ADC_ADCHER_PRESEL_Msk))|((Option)<<ADC_ADCHER_PRESEL_Pos))
N
N/**
N * @details    Get current converse channel
N */
N#define _ADC_GET_CURRENT_COVERSION_CHANNEL()    ((ADC->ADSR & ADC_ADSR_CHANNEL_Msk) >> ADC_ADSR_CHANNEL_Pos)
N
N/**
N * @details    Check if ADC is busy or not
N */
N#define _ADC_IS_BUSY()                      ((ADC->ADSR & ADC_ADSR_BUSY_Msk) >> ADC_ADSR_BUSY_Pos)
N
N/**
N * @details    Get specified comparator channel compare flag
N */
N#define _ADC_GET_CMP_FLAG(ADCCMP_CH)        ((ADC->ADSR & (1<<(ADC_ADSR_CMPF0_Pos+(ADCCMP_CH)))) >> (ADC_ADSR_CMPF0_Pos+(ADCCMP_CH)))
N
N/**
N * @details     Enable ADC IP clock
N */
N#define _ADC_ENABLE_CLOCK()   (SYSCLK->APBCLK |= SYSCLK_APBCLK_ADC_EN_Msk) 
N
N/**
N * @details     Disable ADC IP clock
N */
N#define _ADC_DISABLE_CLOCK()  (SYSCLK->APBCLK &= ~SYSCLK_APBCLK_ADC_EN_Msk) 
N
N/**
N * @details     Set ADC clock source  
N */
N#define _ADC_SET_CLK_SRC(ClockSrc)     (SYSCLK->CLKSEL1 = (SYSCLK->CLKSEL1 &~SYSCLK_CLKSEL1_ADC_S_Msk)|((ClockSrc)<<SYSCLK_CLKSEL1_ADC_S_Pos))
N
N/**
N * @details     Set ADC clock divisor. It could be 1~256. 
N */
N#define _ADC_SET_CLK_DIV(Divisor)      (SYSCLK->CLKDIV  = (SYSCLK->CLKDIV & ~SYSCLK_CLKDIV_ADC_N_Msk)|(SYSCLK_CLKDIV_ADC(Divisor)))
N
N/**
N * @details     Get the status of the ADC interrupt flag
N */
N#define _ADC_GET_ADC_INT_FLAG()    ((ADC->ADSR & ADC_ADSR_ADF_Msk)>>ADC_ADSR_ADF_Pos)
N
N/**
N * @details     Get the status of the ADC CMP0 interrupt flag
N */
N#define _ADC_GET_CMP0_INT_FLAG()    _ADC_GET_CMP_FLAG(0)
N
N/**
N * @details     Get the status of the ADC CMP1 interrupt flag
N */
N#define _ADC_GET_CMP1_INT_FLAG()    _ADC_GET_CMP_FLAG(1)
N
N/**
N * @details     Clear the ADC interrupt flag
N */
N#define _ADC_CLEAR_ADC_INT_FLAG()   (ADC->ADSR = ADC_ADSR_ADF_Msk)
N
N/**
N * @details     Clear the ADC CMP0 interrupt flag
N */
N#define _ADC_CLEAR_CMP0_INT_FLAG()  (ADC->ADSR = ADC_ADSR_CMPF0_Msk)
N
N/**
N * @details     Clear the ADC CMP1 interrupt flag
N */
N#define _ADC_CLEAR_CMP1_INT_FLAG()  (ADC->ADSR = ADC_ADSR_CMPF1_Msk)
N
N
N/**
N * @details     ADC IP reset 
N */
N__INLINE void ADC_ResetIP()
X__inline void ADC_ResetIP()
N{
N    SYS->IPRSTC2 |= (1<<SYS_IPRSTC2_ADC_RST_Pos) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |= (1<<28) ;
N    SYS->IPRSTC2 &= ~(1<<(SYS_IPRSTC2_ADC_RST_Pos)) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(1<<(28)) ;
N}
N
N/**
N * @brief      Return the A/D conversion rate (sample/second)
N *
N * @param      None
N *
N * @return     Conversion rate
N *
N * @details    The conversion rate depends on the clock source of ADC clock.
N *             In NuMicro NUC200 Series, it only needs 21 ADC clocks to complete
N *             an A/D conversion when the ADC clock source is HCLK.
N */
Nstatic __INLINE uint32_t ADC_GetConversionRate()
Xstatic __inline uint32_t ADC_GetConversionRate()
N{
N    uint32_t u32AdcClkSrcSel;
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};    
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};    
N    
N    u32ClkTbl[1] = PllClock;
N    u32ClkTbl[2] = SystemCoreClock;
N    u32AdcClkSrcSel = ((SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_ADC_S_Msk) >> SYSCLK_CLKSEL1_ADC_S_Pos);
X    u32AdcClkSrcSel = ((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (3ul << 2)) >> 2);
N    return   ((u32ClkTbl[u32AdcClkSrcSel]) / (((SYSCLK->CLKDIV & SYSCLK_CLKDIV_ADC_N_Msk)>>SYSCLK_CLKDIV_ADC_N_Pos)+ 1) / 21);
X    return   ((u32ClkTbl[u32AdcClkSrcSel]) / (((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKDIV & (0xFFul << 16))>>16)+ 1) / 21);
N}
N
N
N/**
N  * @} End of ADC Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif
L 6297 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "FMC.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\FMC.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup FMC_FUNC FMC Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */  
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_CONFIG0_ADDR        (FMC_CONFIG_BASE)       /*!< CONFIG 0 Address */
N#define FMC_CONFIG1_ADDR        (FMC_CONFIG_BASE + 4)   /*!< CONFIG 1 Address */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4 kBytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCON constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCON_BS_LDROM     0x2     /*!< ISPCON setting to select to boot from LDROM */
N#define FMC_ISPCON_BS_APROM     0x0     /*!< ISPCON setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ        0x00     /*!< ISP Command: Read Flash       */
N#define FMC_ISPCMD_PROGRAM     0x21     /*!< ISP Command: Program Flash    */
N#define FMC_ISPCMD_PAGE_ERASE  0x22     /*!< ISP Command: Page Erase Flash */
N#define FMC_ISPCMD_READ_UID    0x04     /*!< ISP Command: Read Unique ID   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define _FMC_ENABLE_ISP()          (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)  /*!< Enable ISP Function  */
N#define _FMC_DISABLE_ISP()         (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)  /*!< Disable ISP Function */
N#define _FMC_ENABLE_LD_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)  /*!< Enable LDROM Update Function   */
N#define _FMC_DISABLE_LD_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N#define _FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk) /*!< Enable CONFIG Update Function  */
N#define _FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk) /*!< Disable CONFIG Update Function */
N#define _FMC_ENABLE_AP_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)  /*!< Enable APROM Update Function   */
N#define _FMC_DISABLE_AP_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)  /*!< Disable APROM Update Function  */
N#define _FMC_ENABLE_LOW_FREQ_OPTIMIZE_MODE()  (FMC->FATCON |=  FMC_FATCON_LFOM_Msk) /*!< Enable Flash Access Low Frequency Optimization Mode when HCLK <= 25MHz */
N#define _FMC_DISABLE_LOW_FREQ_OPTIMIZE_MODE() (FMC->FATCON &= ~FMC_FATCON_LFOM_Msk) /*!< Disable Flash Access Low Frequency Optimization Mode */
N
N#define _FMC_SELECT_NEXT_BOOT(x)   (FMC->ISPCON = (FMC->ISPCON & ~FMC_ISPCON_BS_Msk) | (x << FMC_ISPCON_BS_Pos)) /*!< Select Next Booting, x = 0 or 1 */
N#define _FMC_GET_BOOT_STATUS()     ((FMC->ISPCON & FMC_ISPCON_BS_Msk)?1:0) /*!< Get MCU Booting Status */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N * 
N * @param[in]  u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32data  32-bit Data to program
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of TRM.
N *
N * @note   
N *             Please make sure that Register Write-Protection Function has been disabled 
N *             before using this function. User can check the status of 
N *             Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE void FMC_Write(uint32_t u32addr, uint32_t u32data)
Xstatic __inline void FMC_Write(uint32_t u32addr, uint32_t u32data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x21;
N    FMC->ISPADR = u32addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;
N    FMC->ISPDAT = u32data;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = u32data;
N    FMC->ISPTRG = 0x1;  
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;  
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N}
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N * 
N * @param[in]   u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N * @note   
N *              Please make sure that Register Write-Protection Function has been disabled 
N *              before using this function. User can check the status of 
N *              Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32addr)
N{ 
N    FMC->ISPCMD = FMC_ISPCMD_READ;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x00;
N    FMC->ISPADR = u32addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N    
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N * @brief      Flash page erase
N * 
N * @param[in]  u32addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG. 
N *             The page size is 512 bytes.
N *
N * @note   
N *             Please make sure that Register Write-Protection Function has been disabled 
N *             before using this function. User can check the status of 
N *             Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE void FMC_Erase(uint32_t u32addr)
Xstatic __inline void FMC_Erase(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x22;
N    FMC->ISPADR = u32addr;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N}
N
N/**
N * @brief       Read Unique ID
N * 
N * @param[in]   u8index  UID index. 0 = UID[0:31], 1 = UID[32:63], 2 = UID[64:95]
N *
N * @return      The 32-bit unique ID data of specified UID index
N *
N * @details     To read out 96-bit Unique ID.
N *
N * @note   
N *              Please make sure that Register Write-Protection Function has been disabled 
N *              before using this function. User can check the status of 
N *              Register Write-Protection Function with DrvSYS_IsProtectedRegLocked().
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8index)
N{ 
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;
N    FMC->ISPADR = (u8index << 2);
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (u8index << 2);
N    FMC->ISPDAT = 0;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = 0;
N    FMC->ISPTRG = 0x1;
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;
N    __ISB();
X    __isb(0);
N    while (FMC->ISPTRG);
X    while (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);
N    
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N  * @} End of FMC Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif  //__FMC_H__
N
L 6298 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "GPIO.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\GPIO.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V1.00
N * $Revision: 10 $
N * $Date: 12/10/11 11:29a $
N * @brief    NUC200 Series General Purpose I/O Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup GPIO_FUNC GPIO Device Function Interface
N  * @{
N  */
N
N
N/* Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N   Example 1:
N   
N       PA0 = 1; 
N   
N   It is used to set GPIO PA.0 to high;
N   
N   Example 2:
N   
N       if (PA0)
N           PA0 = 0;
N   
N   If GPIO PA.0 pin status is high, then set GPIO PA.0 data output to low.
N */
N#define GPIO_PIN_DATA(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x40*(port))) + ((pin)<<2))))   
N#define PA0             GPIO_PIN_DATA(0, 0 ) /*!< Specify PA.0 Pin Data Input/Output */
N#define PA1             GPIO_PIN_DATA(0, 1 ) /*!< Specify PA.1 Pin Data Input/Output */
N#define PA2             GPIO_PIN_DATA(0, 2 ) /*!< Specify PA.2 Pin Data Input/Output */
N#define PA3             GPIO_PIN_DATA(0, 3 ) /*!< Specify PA.3 Pin Data Input/Output */
N#define PA4             GPIO_PIN_DATA(0, 4 ) /*!< Specify PA.4 Pin Data Input/Output */
N#define PA5             GPIO_PIN_DATA(0, 5 ) /*!< Specify PA.5 Pin Data Input/Output */
N#define PA6             GPIO_PIN_DATA(0, 6 ) /*!< Specify PA.6 Pin Data Input/Output */
N#define PA7             GPIO_PIN_DATA(0, 7 ) /*!< Specify PA.7 Pin Data Input/Output */
N#define PA8             GPIO_PIN_DATA(0, 8 ) /*!< Specify PA.8 Pin Data Input/Output */
N#define PA9             GPIO_PIN_DATA(0, 9 ) /*!< Specify PA.9 Pin Data Input/Output */
N#define PA10            GPIO_PIN_DATA(0, 10) /*!< Specify PA.10 Pin Data Input/Output */
N#define PA11            GPIO_PIN_DATA(0, 11) /*!< Specify PA.11 Pin Data Input/Output */
N#define PA12            GPIO_PIN_DATA(0, 12) /*!< Specify PA.12 Pin Data Input/Output */
N#define PA13            GPIO_PIN_DATA(0, 13) /*!< Specify PA.13 Pin Data Input/Output */
N#define PA14            GPIO_PIN_DATA(0, 14) /*!< Specify PA.14 Pin Data Input/Output */
N#define PA15            GPIO_PIN_DATA(0, 15) /*!< Specify PA.15 Pin Data Input/Output */
N#define PB0             GPIO_PIN_DATA(1, 0 ) /*!< Specify PB.0 Pin Data Input/Output */
N#define PB1             GPIO_PIN_DATA(1, 1 ) /*!< Specify PB.1 Pin Data Input/Output */
N#define PB2             GPIO_PIN_DATA(1, 2 ) /*!< Specify PB.2 Pin Data Input/Output */
N#define PB3             GPIO_PIN_DATA(1, 3 ) /*!< Specify PB.3 Pin Data Input/Output */
N#define PB4             GPIO_PIN_DATA(1, 4 ) /*!< Specify PB.4 Pin Data Input/Output */
N#define PB5             GPIO_PIN_DATA(1, 5 ) /*!< Specify PB.5 Pin Data Input/Output */
N#define PB6             GPIO_PIN_DATA(1, 6 ) /*!< Specify PB.6 Pin Data Input/Output */
N#define PB7             GPIO_PIN_DATA(1, 7 ) /*!< Specify PB.7 Pin Data Input/Output */
N#define PB8             GPIO_PIN_DATA(1, 8 ) /*!< Specify PB.8 Pin Data Input/Output */
N#define PB9             GPIO_PIN_DATA(1, 9 ) /*!< Specify PB.9 Pin Data Input/Output */
N#define PB10            GPIO_PIN_DATA(1, 10) /*!< Specify PB.10 Pin Data Input/Output */
N#define PB11            GPIO_PIN_DATA(1, 11) /*!< Specify PB.11 Pin Data Input/Output */
N#define PB12            GPIO_PIN_DATA(1, 12) /*!< Specify PB.12 Pin Data Input/Output */
N#define PB13            GPIO_PIN_DATA(1, 13) /*!< Specify PB.13 Pin Data Input/Output */
N#define PB14            GPIO_PIN_DATA(1, 14) /*!< Specify PB.14 Pin Data Input/Output */
N#define PB15            GPIO_PIN_DATA(1, 15) /*!< Specify PB.15 Pin Data Input/Output */
N#define PC0             GPIO_PIN_DATA(2, 0 ) /*!< Specify PC.0 Pin Data Input/Output */
N#define PC1             GPIO_PIN_DATA(2, 1 ) /*!< Specify PC.1 Pin Data Input/Output */
N#define PC2             GPIO_PIN_DATA(2, 2 ) /*!< Specify PC.2 Pin Data Input/Output */
N#define PC3             GPIO_PIN_DATA(2, 3 ) /*!< Specify PC.3 Pin Data Input/Output */
N#define PC4             GPIO_PIN_DATA(2, 4 ) /*!< Specify PC.4 Pin Data Input/Output */
N#define PC5             GPIO_PIN_DATA(2, 5 ) /*!< Specify PC.5 Pin Data Input/Output */
N#define PC6             GPIO_PIN_DATA(2, 6 ) /*!< Specify PC.6 Pin Data Input/Output */
N#define PC7             GPIO_PIN_DATA(2, 7 ) /*!< Specify PC.7 Pin Data Input/Output */
N#define PC8             GPIO_PIN_DATA(2, 8 ) /*!< Specify PC.8 Pin Data Input/Output */
N#define PC9             GPIO_PIN_DATA(2, 9 ) /*!< Specify PC.9 Pin Data Input/Output */
N#define PC10            GPIO_PIN_DATA(2, 10) /*!< Specify PC.10 Pin Data Input/Output */
N#define PC11            GPIO_PIN_DATA(2, 11) /*!< Specify PC.11 Pin Data Input/Output */
N#define PC12            GPIO_PIN_DATA(2, 12) /*!< Specify PC.12 Pin Data Input/Output */
N#define PC13            GPIO_PIN_DATA(2, 13) /*!< Specify PC.13 Pin Data Input/Output */
N#define PC14            GPIO_PIN_DATA(2, 14) /*!< Specify PC.14 Pin Data Input/Output */
N#define PC15            GPIO_PIN_DATA(2, 15) /*!< Specify PC.15 Pin Data Input/Output */
N#define PD0             GPIO_PIN_DATA(3, 0 ) /*!< Specify PD.0 Pin Data Input/Output */
N#define PD1             GPIO_PIN_DATA(3, 1 ) /*!< Specify PD.1 Pin Data Input/Output */
N#define PD2             GPIO_PIN_DATA(3, 2 ) /*!< Specify PD.2 Pin Data Input/Output */
N#define PD3             GPIO_PIN_DATA(3, 3 ) /*!< Specify PD.3 Pin Data Input/Output */
N#define PD4             GPIO_PIN_DATA(3, 4 ) /*!< Specify PD.4 Pin Data Input/Output */
N#define PD5             GPIO_PIN_DATA(3, 5 ) /*!< Specify PD.5 Pin Data Input/Output */
N#define PD6             GPIO_PIN_DATA(3, 6 ) /*!< Specify PD.6 Pin Data Input/Output */
N#define PD7             GPIO_PIN_DATA(3, 7 ) /*!< Specify PD.7 Pin Data Input/Output */
N#define PD8             GPIO_PIN_DATA(3, 8 ) /*!< Specify PD.8 Pin Data Input/Output */
N#define PD9             GPIO_PIN_DATA(3, 9 ) /*!< Specify PD.9 Pin Data Input/Output */
N#define PD10            GPIO_PIN_DATA(3, 10) /*!< Specify PD.10 Pin Data Input/Output */
N#define PD11            GPIO_PIN_DATA(3, 11) /*!< Specify PD.11 Pin Data Input/Output */
N#define PD12            GPIO_PIN_DATA(3, 12) /*!< Specify PD.12 Pin Data Input/Output */
N#define PD13            GPIO_PIN_DATA(3, 13) /*!< Specify PD.13 Pin Data Input/Output */
N#define PD14            GPIO_PIN_DATA(3, 14) /*!< Specify PD.14 Pin Data Input/Output */
N#define PD15            GPIO_PIN_DATA(3, 15) /*!< Specify PD.15 Pin Data Input/Output */
N#define PE0             GPIO_PIN_DATA(4, 0 ) /*!< Specify PE.0 Pin Data Input/Output */
N#define PE1             GPIO_PIN_DATA(4, 1 ) /*!< Specify PE.1 Pin Data Input/Output */
N#define PE2             GPIO_PIN_DATA(4, 2 ) /*!< Specify PE.2 Pin Data Input/Output */
N#define PE3             GPIO_PIN_DATA(4, 3 ) /*!< Specify PE.3 Pin Data Input/Output */
N#define PE4             GPIO_PIN_DATA(4, 4 ) /*!< Specify PE.4 Pin Data Input/Output */
N#define PE5             GPIO_PIN_DATA(4, 5 ) /*!< Specify PE.5 Pin Data Input/Output */
N#define PE6             GPIO_PIN_DATA(4, 6 ) /*!< Specify PE.6 Pin Data Input/Output */
N#define PE7             GPIO_PIN_DATA(4, 7 ) /*!< Specify PE.7 Pin Data Input/Output */
N#define PE8             GPIO_PIN_DATA(4, 8 ) /*!< Specify PE.8 Pin Data Input/Output */
N#define PE9             GPIO_PIN_DATA(4, 9 ) /*!< Specify PE.9 Pin Data Input/Output */
N#define PE10            GPIO_PIN_DATA(4, 10) /*!< Specify PE.10 Pin Data Input/Output */
N#define PE11            GPIO_PIN_DATA(4, 11) /*!< Specify PE.11 Pin Data Input/Output */
N#define PE12            GPIO_PIN_DATA(4, 12) /*!< Specify PE.12 Pin Data Input/Output */
N#define PE13            GPIO_PIN_DATA(4, 13) /*!< Specify PE.13 Pin Data Input/Output */
N#define PE14            GPIO_PIN_DATA(4, 14) /*!< Specify PE.14 Pin Data Input/Output */
N#define PE15            GPIO_PIN_DATA(4, 15) /*!< Specify PE.15 Pin Data Input/Output */
N#define PF0             GPIO_PIN_DATA(5, 0 ) /*!< Specify PF.0 Pin Data Input/Output */
N#define PF1             GPIO_PIN_DATA(5, 1 ) /*!< Specify PF.1 Pin Data Input/Output */
N#define PF2             GPIO_PIN_DATA(5, 2 ) /*!< Specify PF.2 Pin Data Input/Output */
N#define PF3             GPIO_PIN_DATA(5, 3 ) /*!< Specify PF.3 Pin Data Input/Output */
N        
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT              0x0UL                  /*!< Input Mode */
N#define GPIO_PMD_OUTPUT             0x1UL                  /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN         0x2UL                  /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI              0x3UL                  /*!< Quasi-bidirectional Mode */
N#define GPIO_PMD_MODE(pin, mode)    ((mode) << ((pin)<<1)) /*!< Generate the PMD mode setting for each pin  */
N
N#define GPIO_PMD_PMD0_INPUT         0x00000000UL /*!< PMD Setting of Pin 0 for Input Mode */
N#define GPIO_PMD_PMD0_OUTPUT        0x00000001UL /*!< PMD Setting of Pin 0 for Output Mode */
N#define GPIO_PMD_PMD0_OPEN_DRAIN    0x00000002UL /*!< PMD Setting of Pin 0 for Open-Drain Mode */
N#define GPIO_PMD_PMD0_QUASI         0x00000003UL /*!< PMD Setting of Pin 0 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD1_INPUT         0x00000000UL /*!< PMD Setting of Pin 1 for Input Mode */
N#define GPIO_PMD_PMD1_OUTPUT        0x00000004UL /*!< PMD Setting of Pin 1 for Output Mode */
N#define GPIO_PMD_PMD1_OPEN_DRAIN    0x00000008UL /*!< PMD Setting of Pin 1 for Open-Drain Mode */
N#define GPIO_PMD_PMD1_QUASI         0x0000000CUL /*!< PMD Setting of Pin 1 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD2_INPUT         0x00000000UL /*!< PMD Setting of Pin 2 for Input Mode */
N#define GPIO_PMD_PMD2_OUTPUT        0x00000010UL /*!< PMD Setting of Pin 2 for Output Mode */
N#define GPIO_PMD_PMD2_OPEN_DRAIN    0x00000020UL /*!< PMD Setting of Pin 2 for Open-Drain Mode */
N#define GPIO_PMD_PMD2_QUASI         0x00000030UL /*!< PMD Setting of Pin 2 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD3_INPUT         0x00000000UL /*!< PMD Setting of Pin 3 for Input Mode */
N#define GPIO_PMD_PMD3_OUTPUT        0x00000040UL /*!< PMD Setting of Pin 3 for Output Mode */
N#define GPIO_PMD_PMD3_OPEN_DRAIN    0x00000080UL /*!< PMD Setting of Pin 3 for Open-Drain Mode */
N#define GPIO_PMD_PMD3_QUASI         0x000000C0UL /*!< PMD Setting of Pin 3 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD4_INPUT         0x00000000UL /*!< PMD Setting of Pin 4 for Input Mode */
N#define GPIO_PMD_PMD4_OUTPUT        0x00000100UL /*!< PMD Setting of Pin 4 for Output Mode */
N#define GPIO_PMD_PMD4_OPEN_DRAIN    0x00000200UL /*!< PMD Setting of Pin 4 for Open-Drain Mode */
N#define GPIO_PMD_PMD4_QUASI         0x00000300UL /*!< PMD Setting of Pin 4 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD5_INPUT         0x00000000UL /*!< PMD Setting of Pin 5 for Input Mode */
N#define GPIO_PMD_PMD5_OUTPUT        0x00000400UL /*!< PMD Setting of Pin 5 for Output Mode */
N#define GPIO_PMD_PMD5_OPEN_DRAIN    0x00000800UL /*!< PMD Setting of Pin 5 for Open-Drain Mode */
N#define GPIO_PMD_PMD5_QUASI         0x00000C00UL /*!< PMD Setting of Pin 5 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD6_INPUT         0x00000000UL /*!< PMD Setting of Pin 6 for Input Mode */
N#define GPIO_PMD_PMD6_OUTPUT        0x00001000UL /*!< PMD Setting of Pin 6 for Output Mode */
N#define GPIO_PMD_PMD6_OPEN_DRAIN    0x00002000UL /*!< PMD Setting of Pin 6 for Open-Drain Mode */
N#define GPIO_PMD_PMD6_QUASI         0x00003000UL /*!< PMD Setting of Pin 6 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD7_INPUT         0x00000000UL /*!< PMD Setting of Pin 7 for Input Mode */
N#define GPIO_PMD_PMD7_OUTPUT        0x00004000UL /*!< PMD Setting of Pin 7 for Output Mode */
N#define GPIO_PMD_PMD7_OPEN_DRAIN    0x00008000UL /*!< PMD Setting of Pin 7 for Open-Drain Mode */
N#define GPIO_PMD_PMD7_QUASI         0x0000C000UL /*!< PMD Setting of Pin 7 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD8_INPUT         0x00000000UL /*!< PMD Setting of Pin 8 for Input Mode */
N#define GPIO_PMD_PMD8_OUTPUT        0x00010000UL /*!< PMD Setting of Pin 8 for Output Mode */
N#define GPIO_PMD_PMD8_OPEN_DRAIN    0x00020000UL /*!< PMD Setting of Pin 8 for Open-Drain Mode */
N#define GPIO_PMD_PMD8_QUASI         0x00030000UL /*!< PMD Setting of Pin 8 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD9_INPUT         0x00000000UL /*!< PMD Setting of Pin 9 for Input Mode */
N#define GPIO_PMD_PMD9_OUTPUT        0x00040000UL /*!< PMD Setting of Pin 9 for Output Mode */
N#define GPIO_PMD_PMD9_OPEN_DRAIN    0x00080000UL /*!< PMD Setting of Pin 9 for Open-Drain Mode */
N#define GPIO_PMD_PMD9_QUASI         0x000C0000UL /*!< PMD Setting of Pin 9 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD10_INPUT        0x00000000UL /*!< PMD Setting of Pin 10 for Input Mode */
N#define GPIO_PMD_PMD10_OUTPUT       0x00100000UL /*!< PMD Setting of Pin 10 for Output Mode */
N#define GPIO_PMD_PMD10_OPEN_DRAIN   0x00200000UL /*!< PMD Setting of Pin 10 for Open-Drain Mode */
N#define GPIO_PMD_PMD10_QUASI        0x00300000UL /*!< PMD Setting of Pin 10 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD11_INPUT        0x00000000UL /*!< PMD Setting of Pin 11 for Input Mode */
N#define GPIO_PMD_PMD11_OUTPUT       0x00400000UL /*!< PMD Setting of Pin 11 for Output Mode */
N#define GPIO_PMD_PMD11_OPEN_DRAIN   0x00800000UL /*!< PMD Setting of Pin 11 for Open-Drain Mode */
N#define GPIO_PMD_PMD11_QUASI        0x00C00000UL /*!< PMD Setting of Pin 11 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD12_INPUT        0x00000000UL /*!< PMD Setting of Pin 12 for Input Mode */
N#define GPIO_PMD_PMD12_OUTPUT       0x01000000UL /*!< PMD Setting of Pin 12 for Output Mode */
N#define GPIO_PMD_PMD12_OPEN_DRAIN   0x02000000UL /*!< PMD Setting of Pin 12 for Open-Drain Mode */
N#define GPIO_PMD_PMD12_QUASI        0x03000000UL /*!< PMD Setting of Pin 12 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD13_INPUT        0x00000000UL /*!< PMD Setting of Pin 13 for Input Mode */
N#define GPIO_PMD_PMD13_OUTPUT       0x04000000UL /*!< PMD Setting of Pin 13 for Output Mode */
N#define GPIO_PMD_PMD13_OPEN_DRAIN   0x08000000UL /*!< PMD Setting of Pin 13 for Open-Drain Mode */
N#define GPIO_PMD_PMD13_QUASI        0x0C000000UL /*!< PMD Setting of Pin 13 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD14_INPUT        0x00000000UL /*!< PMD Setting of Pin 14 for Input Mode */
N#define GPIO_PMD_PMD14_OUTPUT       0x10000000UL /*!< PMD Setting of Pin 14 for Output Mode */
N#define GPIO_PMD_PMD14_OPEN_DRAIN   0x20000000UL /*!< PMD Setting of Pin 14 for Open-Drain Mode */
N#define GPIO_PMD_PMD14_QUASI        0x30000000UL /*!< PMD Setting of Pin 14 for Quasi-bidirectional Mode */
N#define GPIO_PMD_PMD15_INPUT        0x00000000UL /*!< PMD Setting of Pin 15 for Input Mode */
N#define GPIO_PMD_PMD15_OUTPUT       0x40000000UL /*!< PMD Setting of Pin 15 for Output Mode */
N#define GPIO_PMD_PMD15_OPEN_DRAIN   0x80000000UL /*!< PMD Setting of Pin 15 for Open-Drain Mode */
N#define GPIO_PMD_PMD15_QUASI        0xC0000000UL /*!< PMD Setting of Pin 15 for Quasi-bidirectional Mode */
N                                            
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE               0UL               /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL              1UL               /*!< IMD Setting for Edge Level Mode */
N#define GPIO_IMD_MODE(pin, mode)    ((mode) << (pin)) /*!< Generate IMD Mode Setting for Pin */
N                                                        
N#define GPIO_IMD_IMD0_EDGE          0x0000UL /*!< IMD Setting of Pin 0 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD1_EDGE          0x0000UL /*!< IMD Setting of Pin 1 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD2_EDGE          0x0000UL /*!< IMD Setting of Pin 2 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD3_EDGE          0x0000UL /*!< IMD Setting of Pin 3 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD4_EDGE          0x0000UL /*!< IMD Setting of Pin 4 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD5_EDGE          0x0000UL /*!< IMD Setting of Pin 5 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD6_EDGE          0x0000UL /*!< IMD Setting of Pin 6 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD7_EDGE          0x0000UL /*!< IMD Setting of Pin 7 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD8_EDGE          0x0000UL /*!< IMD Setting of Pin 8 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD9_EDGE          0x0000UL /*!< IMD Setting of Pin 9 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD10_EDGE         0x0000UL /*!< IMD Setting of Pin 10 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD11_EDGE         0x0000UL /*!< IMD Setting of Pin 11 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD12_EDGE         0x0000UL /*!< IMD Setting of Pin 12 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD13_EDGE         0x0000UL /*!< IMD Setting of Pin 13 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD14_EDGE         0x0000UL /*!< IMD Setting of Pin 14 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD15_EDGE         0x0000UL /*!< IMD Setting of Pin 15 for Edge Trigger Mode */ 
N#define GPIO_IMD_IMD0_LEVEL         0x0001UL /*!< IMD Setting of Pin 0 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD1_LEVEL         0x0002UL /*!< IMD Setting of Pin 1 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD2_LEVEL         0x0004UL /*!< IMD Setting of Pin 2 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD3_LEVEL         0x0008UL /*!< IMD Setting of Pin 3 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD4_LEVEL         0x0010UL /*!< IMD Setting of Pin 4 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD5_LEVEL         0x0020UL /*!< IMD Setting of Pin 5 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD6_LEVEL         0x0040UL /*!< IMD Setting of Pin 6 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD7_LEVEL         0x0080UL /*!< IMD Setting of Pin 7 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD8_LEVEL         0x0100UL /*!< IMD Setting of Pin 8 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD9_LEVEL         0x0200UL /*!< IMD Setting of Pin 9 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD10_LEVEL        0x0400UL /*!< IMD Setting of Pin 10 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD11_LEVEL        0x0800UL /*!< IMD Setting of Pin 11 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD12_LEVEL        0x1000UL /*!< IMD Setting of Pin 12 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD13_LEVEL        0x2000UL /*!< IMD Setting of Pin 13 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD14_LEVEL        0x4000UL /*!< IMD Setting of Pin 14 for Level Trigger Mode */ 
N#define GPIO_IMD_IMD15_LEVEL        0x8000UL /*!< IMD Setting of Pin 15 for Level Trigger Mode */ 
N
N                                    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IEN Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IEN_IF_EN(pin)         (1UL << (pin))      /*!< Generate IEN Setting of Specified Pin for Enable Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IR_EN(pin)         (1UL << ((pin)+16)) /*!< Generate IEN Setting of Specified Pin for Enable Rising/High Level Interrupt */ 
N
N#define GPIO_IEN_IF_EN0             0x00000001UL /*!< IEN Setting of Pin 0 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN1             0x00000002UL /*!< IEN Setting of Pin 1 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN2             0x00000004UL /*!< IEN Setting of Pin 2 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN3             0x00000008UL /*!< IEN Setting of Pin 3 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN4             0x00000010UL /*!< IEN Setting of Pin 4 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN5             0x00000020UL /*!< IEN Setting of Pin 5 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN6             0x00000040UL /*!< IEN Setting of Pin 6 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN7             0x00000080UL /*!< IEN Setting of Pin 7 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN8             0x00000100UL /*!< IEN Setting of Pin 8 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN9             0x00000200UL /*!< IEN Setting of Pin 9 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN10            0x00000400UL /*!< IEN Setting of Pin 10 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN11            0x00000800UL /*!< IEN Setting of Pin 11 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN12            0x00001000UL /*!< IEN Setting of Pin 12 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN13            0x00002000UL /*!< IEN Setting of Pin 13 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN14            0x00004000UL /*!< IEN Setting of Pin 14 for Eanble Falling/Low Level Interrupt */ 
N#define GPIO_IEN_IF_EN15            0x00008000UL /*!< IEN Setting of Pin 15 for Eanble Falling/Low Level Interrupt */ 
N                                    
N#define GPIO_IEN_IR_EN0             0x00010000UL /*!< IEN Setting of Pin 0 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN1             0x00020000UL /*!< IEN Setting of Pin 1 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN2             0x00040000UL /*!< IEN Setting of Pin 2 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN3             0x00080000UL /*!< IEN Setting of Pin 3 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN4             0x00100000UL /*!< IEN Setting of Pin 4 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN5             0x00200000UL /*!< IEN Setting of Pin 5 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN6             0x00400000UL /*!< IEN Setting of Pin 6 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN7             0x00800000UL /*!< IEN Setting of Pin 7 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN8             0x01000000UL /*!< IEN Setting of Pin 8 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN9             0x02000000UL /*!< IEN Setting of Pin 9 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN10            0x04000000UL /*!< IEN Setting of Pin 10 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN11            0x08000000UL /*!< IEN Setting of Pin 11 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN12            0x10000000UL /*!< IEN Setting of Pin 12 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN13            0x20000000UL /*!< IEN Setting of Pin 13 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN14            0x40000000UL /*!< IEN Setting of Pin 14 for Eanble Rising/High Level Interrupt */ 
N#define GPIO_IEN_IR_EN15            0x80000000UL /*!< IEN Setting of Pin 15 for Eanble Rising/High Level Interrupt */ 
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISRC Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_ISRC_ISRC0             0x0001UL /*!< ISRC Setting of Pin 0 for Indicates Pin 0 generate an interrupt */ 
N#define GPIO_ISRC_ISRC1             0x0002UL /*!< ISRC Setting of Pin 1 for Indicates Pin 1 generate an interrupt */ 
N#define GPIO_ISRC_ISRC2             0x0004UL /*!< ISRC Setting of Pin 2 for Indicates Pin 2 generate an interrupt */ 
N#define GPIO_ISRC_ISRC3             0x0008UL /*!< ISRC Setting of Pin 3 for Indicates Pin 3 generate an interrupt */ 
N#define GPIO_ISRC_ISRC4             0x0010UL /*!< ISRC Setting of Pin 4 for Indicates Pin 4 generate an interrupt */
N#define GPIO_ISRC_ISRC5             0x0020UL /*!< ISRC Setting of Pin 5 for Indicates Pin 5 generate an interrupt */ 
N#define GPIO_ISRC_ISRC6             0x0040UL /*!< ISRC Setting of Pin 6 for Indicates Pin 6 generate an interrupt */ 
N#define GPIO_ISRC_ISRC7             0x0080UL /*!< ISRC Setting of Pin 7 for Indicates Pin 7 generate an interrupt */ 
N#define GPIO_ISRC_ISRC8             0x0100UL /*!< ISRC Setting of Pin 8 for Indicates Pin 0 generate an interrupt */ 
N#define GPIO_ISRC_ISRC9             0x0200UL /*!< ISRC Setting of Pin 9 for Indicates Pin 1 generate an interrupt */ 
N#define GPIO_ISRC_ISRC10            0x0400UL /*!< ISRC Setting of Pin 10 for Indicates Pin 2 generate an interrupt */ 
N#define GPIO_ISRC_ISRC11            0x0800UL /*!< ISRC Setting of Pin 11 for Indicates Pin 3 generate an interrupt */ 
N#define GPIO_ISRC_ISRC12            0x1000UL /*!< ISRC Setting of Pin 12 for Indicates Pin 4 generate an interrupt */
N#define GPIO_ISRC_ISRC13            0x2000UL /*!< ISRC Setting of Pin 13 for Indicates Pin 5 generate an interrupt */ 
N#define GPIO_ISRC_ISRC14            0x4000UL /*!< ISRC Setting of Pin 14 for Indicates Pin 6 generate an interrupt */ 
N#define GPIO_ISRC_ISRC15            0x8000UL /*!< ISRC Setting of Pin 15 for Indicates Pin 7 generate an interrupt */ 
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBNCECON_ICLK_ON           0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */ 
N#define GPIO_DBNCECON_ICLK_OFF          0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */ 
N
N#define GPIO_DBNCECON_DBCLKSRC_IRC10K   0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */ 
N#define GPIO_DBNCECON_DBCLKSRC_HCLK     0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the internal HCLK */ 
N
N#define GPIO_DBNCECON_DBCLKSEL_1        0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2        0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4        0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8        0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16       0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32       0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_64       0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_128      0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_256      0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_512      0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_1024     0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2048     0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4096     0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8192     0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16384    0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32768    0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBEN Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBEN_ENABLE(pin)       (1UL << (pin)) /*!< DBEN setting for enable specified pin de-bounce function */      
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DMASK Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DMASK_ENABLE(pin)      (1UL << (pin)) /*!< DMASK setting for mask specified pin DOUT function */      
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  OFFD Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_OFFD_ENABLE(pin)       (1UL << ((pin)+16)) /*!< OFFD setting for disable specified pin I/O digital input path */      
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING             0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING            0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE          0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH               0x01010000UL /*!< Interrupt enable by Level-High */    
N#define GPIO_INT_LOW                0x01000001UL /*!< Interrupt enable by Level-Level */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Macro Definitions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief       Set GPIO Pin Mode
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 15.
N * @param[in]   mode        The pin mode of specified GPIO pin. It could be GPIO_PMD_INPUT, GPIO_PMD_OUTPUT, GPIO_PMD_OPEN_DRAIN or GPIO_PMD_QUASI.
N *
N * @return      None
N *
N * @details     Set the pin mode of specified GPIO pin.
N */
N#define _GPIO_SET_PIN_MODE(PORT, pin, mode)     ((PORT)->PMD = ((PORT)->PMD & ~GPIO_PMD_MODE(pin, GPIO_PMD_QUASI)) | GPIO_PMD_MODE(pin, mode))
N
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 15.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define _GPIO_ENABLE_DIGITAL_PATH(PORT, pin)    ((PORT)->OFFD &= ~GPIO_OFFD_ENABLE(pin))
N
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 15.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define _GPIO_DISABLE_DIGITAL_PATH(PORT, pin)   ((PORT)->OFFD |= GPIO_OFFD_ENABLE(pin))
N
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 15.
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define _GPIO_ENABLE_DEBOUNCE(PORT, pin)         ((PORT)->DBEN |= GPIO_DBEN_ENABLE(pin))
N
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 15.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define _GPIO_DISABLE_DEBOUNCE(PORT, pin)       ((PORT)->DBEN &= ~GPIO_DBEN_ENABLE(pin))
N
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   clksrc      The de-bounce counter clock source. It could be GPIO_DBNCECON_DBCLKSRC_HCLK or GPIO_DBNCECON_DBCLKSRC_IRC10K.
N * @param[in]   clksel      The de-bounce sampling cycle selectionn. It could be \n
N *                              GPIO_DBNCECON_DBCLKSEL_1, GPIO_DBNCECON_DBCLKSEL_2, GPIO_DBNCECON_DBCLKSEL_4, GPIO_DBNCECON_DBCLKSEL_8, \n
N *                              GPIO_DBNCECON_DBCLKSEL_16, GPIO_DBNCECON_DBCLKSEL_32, GPIO_DBNCECON_DBCLKSEL_64, GPIO_DBNCECON_DBCLKSEL_128, \n
N *                              GPIO_DBNCECON_DBCLKSEL_256, GPIO_DBNCECON_DBCLKSEL_512, GPIO_DBNCECON_DBCLKSEL_1024, GPIO_DBNCECON_DBCLKSEL_2048, \n
N *                              GPIO_DBNCECON_DBCLKSEL_4096, GPIO_DBNCECON_DBCLKSEL_8192, GPIO_DBNCECON_DBCLKSEL_16384, GPIO_DBNCECON_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBNCECON_DBCLKSRC_IRC10K, GPIO_DBNCECON_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *              and system will sampling interrupt input once per 1600 us.
N */
N#define _GPIO_SET_DEBOUNCE_TIME(clksrc, clksel)  (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | clksrc | clksel))
N
N
N/**
N * @brief       Get GPIO Pin Interrupt Status
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 15.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define _GPIO_GET_INT_STATUS(PORT, pin)          ((((PORT)->ISRC & (1<<pin)) == (1<<pin))? 1:0)
N
N
N/**
N * @brief       Clear GPIO Pin Interrupt Status
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   pin         The pin of specified GPIO port. It could be 0 ~ 15.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define _GPIO_CLEAR_INT_STATUS(PORT, pin)          ((PORT)->ISRC = (1<<pin))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief       Enable GPIO interrupt
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 15.
N * @param[in]   u32Attribs  The interrupt attribute of specified GPIO pin. It could be \n
N *                          GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
Nstatic __INLINE void GPIO_EnableInt(GPIO_T *PORT, uint32_t u32Pin, uint32_t u32IntAttribs)
Xstatic __inline void GPIO_EnableInt(GPIO_T *PORT, uint32_t u32Pin, uint32_t u32IntAttribs)
N{
N    PORT->IMD |= (_GET_BYTE3(u32IntAttribs) << u32Pin);
X    PORT->IMD |= (((u32IntAttribs & (0xFF000000)) >> 24) << u32Pin);
N    PORT->IEN |= ((u32IntAttribs & 0xFFFFFFUL) << u32Pin);
N}
N
N
N/**
N * @brief       Disable GPIO interrupt
N *
N * @param[in]   PORT        GPIO port. It could be PA, PB, PC, PD, PE and PF.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 15.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
Nstatic __INLINE void GPIO_DisableInt(GPIO_T *PORT, uint32_t u32Pin)
Xstatic __inline void GPIO_DisableInt(GPIO_T *PORT, uint32_t u32Pin)
N{
N    PORT->IMD &= ~((BIT0) << u32Pin);
X    PORT->IMD &= ~((0x00000001) << u32Pin);
N    PORT->IEN &= ~((0x00010001UL) << u32Pin);
N}
N
N
N
N/**
N  * @} End of GPIO Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N#endif  //__GPIO_H__
L 6299 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "I2C.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\I2C.h" 1
N/**************************************************************************//**
N * @file     I2C.h   
N * @version  V2.1
N * $Revision: 6 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series I2C Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup I2C_FUNC I2C Device Function Interface
N  * @{
N  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CON constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CON_STA_STO_SI        0x38UL /*!< I2CON setting for I2C control bits. It would set STA, STO and SI bits     */
N#define I2C_I2CON_STA_STO_SI_AA     0x3CUL /*!< I2CON setting for I2C control bits. It would set STA, STO, SI and AA bits */
N#define I2C_I2CON_STA_SI            0x28UL /*!< I2CON setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_I2CON_STA_SI_AA         0x2CUL /*!< I2CON setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_I2CON_STO_SI            0x18UL /*!< I2CON setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_I2CON_STO_SI_AA         0x1CUL /*!< I2CON setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_I2CON_SI                0x08UL /*!< I2CON setting for I2C control bits. It would set SI bit                   */
N#define I2C_I2CON_SI_AA             0x0CUL /*!< I2CON setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_I2CON_STA               0x20UL /*!< I2CON setting for I2C control bits. It would set STA bit                  */
N#define I2C_I2CON_AA                0x04UL /*!< I2CON setting for I2C control bits. It would set AA bit                   */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CLK constant definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CLK_DIV4(x)    ((x)-1)    /*!< I2CLK setting for I2C clock divide. I2C clock = APBCLK / (x*4). 5 <= x <= 256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macro                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Generate START signal to I2C bus
N *
N * @param[in]  port    I2C port 
N *
N * @return     None
N *
N * @details    This macro is used to generate START signal to specified I2C port 
N */
N#define _I2C_START(port) _I2C_SET_CONTROL_BITS(port, I2C_I2CON_STA_SI)
N
N/**
N * @brief      Waiting for I2C action done
N *
N * @param[in]  port    I2C port 
N *
N * @return     None
N *
N * @details    This function is used to wait I2C action done by polling SI bit of I2CON. 
N */
N#define _I2C_WAIT_READY(port) while(((port)->I2CON & I2C_I2CON_SI_Msk) == 0)
N
N/**
N * @brief      Generate STOP signal to I2C bus
N *
N * @param[in]  port    I2C port 
N *
N * @return     None
N *
N * @details    This macro is used to generate STOP signal to specified I2C port  
N */
N#define _I2C_STOP(port) _I2C_SET_CONTROL_BITS(port, I2C_I2CON_STO_SI)
N
N/**
N * @brief      Send a byte to I2C bus
N *
N * @param[in]  port    I2C port 
N * @param[in]  u8Data  The data to send to I2C bus. 
N *
N * @return     None
N *
N * @details    This macro is used to write a byte to specified I2C port  
N */
N#define _I2C_WRITE(port, u8Data) ((port)->I2CDAT = (u8Data));((port)->I2CON = I2C_I2CON_ENS1_Msk | I2C_I2CON_SI_Msk)
N
N/**
N * @brief      Read a byte from I2C bus and return ACK
N *
N * @param[in]  port    I2C port 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This macro is used to read a byte from specified I2C port and return ACK
N */
N#define _I2C_READ_ACK(port)         I2C_ReadAck(port)
N
N/**
N * @brief      Read a byte from I2C bus and return NAK
N *
N * @param[in]  port    I2C port 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This macro is used to read a byte from specified I2C port and return NAK
N */
N#define _I2C_READ_NAK(port)     I2C_ReadNak(port)
N
N
N/**
N * @brief      Set I2C Control Bits
N *
N * @param[in]  port    I2C port
N * @param[in]  u8Ctrl  I2C Control Bit. Including
N *                     -I2C_I2CON_STA_STO_SI   : Set STA, STO and SI bits
N *                     -I2C_I2CON_STA_STO_SI_AA: Set STA, STO, SI and AA bits 
N *                     -I2C_I2CON_STA_SI       : Set STA and SI bits      
N *                     -I2C_I2CON_STA_SI_AA    : Set STA, SI and AA bits
N *                     -I2C_I2CON_STO_SI       : Set STO and SI bits        
N *                     -I2C_I2CON_STO_SI_AA    : Set STO, SI and AA bits    
N *                     -I2C_I2CON_SI           : Set SI bit               
N *                     -I2C_I2CON_SI_AA        : Set SI and AA bits
N *                     -I2C_I2CON_STA          : Set STA bit               
N *                     -I2C_I2CON_AA           : Set AA bit
N *
N * @return     None
N *
N * @details    To set I2C control bits include STA, STO, SI and AA in I2C CONTROL REGISTER (I2CON)
N *
N * @note
N *             This function will enable EI bit. If user does not need to use interrupt, 
N *             user can disable corresponding NVIC bit of I2C.
N */
N#define _I2C_SET_CONTROL_BITS(port, u8Ctrl)     ((port)->I2CON = I2C_I2CON_EI_Msk | I2C_I2CON_ENS1_Msk | (u8Ctrl))
N
N/**
N * @brief      Get I2C Bus Clock 
N *
N * @param[in]  port    I2C port 
N *
N * @return     The actual I2C Bus clock in Hz
N *
N * @details    To get the actual I2C Bus Clock frequency.
N */
N#define _I2C_GET_BUS_CLOCK(port)         (SystemCoreClock/((((port)->I2CLK)+1)<<2))       
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR0
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR0). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_0(port, u8SlaveAddr)    ((port)->I2CADDR0 = ((port)->I2CADDR0 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR1
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR1). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_1(port, u8SlaveAddr)    ((port)->I2CADDR1 = ((port)->I2CADDR1 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR2
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address 
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR2). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_2(port, u8SlaveAddr)    ((port)->I2CADDR2 = ((port)->I2CADDR2 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N/**
N * @brief      Set 7-bit Slave Address of I2CADDR3
N *
N * @param[in]  port         I2C port 
N * @param[in]  u8SlaveAddr  7-bit slave address
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses in I2C SLAVE ADDRESS REGISTER (I2CADDR3). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_3(port, u8SlaveAddr)    ((port)->I2CADDR3 = ((port)->I2CADDR3 & ~I2C_I2CADDR_I2CADDR_Msk) | ((u8SlaveAddr) << I2C_I2CADDR_I2CADDR_Pos))     
N
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM0
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR0
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM0). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_0(port, u8SlaAddrMsk)    ((port)->I2CADM0 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)     
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM1
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR1
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM1). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_1(port, u8SlaAddrMsk)    ((port)->I2CADM1 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)     
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM2
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR2
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM2). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_2(port, u8SlaAddrMsk)    ((port)->I2CADM2 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)     
N
N/**
N * @brief      Set 7-bit Slave Address Mask in I2CADM3
N *
N * @param[in]  port          I2C port 
N * @param[in]  u8SlaAddrMsk  7-bit data to mask the corresponding slave address bit(s) of I2CADDR3
N *
N * @return     None
N *
N * @details    This function is used to set 7-bit slave addresses mask in I2C SLAVE ADDRESS MASK REGISTER (I2CADM3). 
N */
N#define _I2C_SET_SLAVE_ADDRESS_MASK_3(port, u8SlaAddrMsk)    ((port)->I2CADM3 = (u8SlaAddrMsk) << I2C_I2CADM_I2CADM_Pos)    
N
N
N#define _I2C_ENABLE_TIMEOUT_COUNTER(port)  ((port)->I2CTOC |=  I2C_I2CTOC_ENTI_Msk) /*!< Enable 14-bit Time-out Counter  */
N#define _I2C_DISABLE_TIMEOUT_COUNTER(port) ((port)->I2CTOC &= ~I2C_I2CTOC_ENTI_Msk) /*!< Disable 14-bit Time-out Counter */
N#define _I2C_ENABLE_GENERAL_CALL(port)    ((port)->I2CADDR0 |=  I2C_I2CADDR_GC_Msk) /*!< Enable General Call Mode  */
N#define _I2C_DISABLE_GENERAL_CALL(port)   ((port)->I2CADDR0 &= ~I2C_I2CADDR_GC_Msk) /*!< Disable General Call Mode */
N
N/**
N * @brief      Read a byte from I2C bus and return ACK
N *
N * @param[in]  port    I2C port. 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This function is used to read a byte from specified I2C port and return ACK
N */
Nstatic __INLINE uint8_t I2C_ReadAck(I2C_T *port)
Xstatic __inline uint8_t I2C_ReadAck(I2C_T *port)
N{
N    (port)->I2CDAT= 0xFF;
N    (port)->I2CON = I2C_I2CON_ENS1_Msk | I2C_I2CON_SI_Msk | I2C_I2CON_AA_Msk;
X    (port)->I2CON = (1ul << 6) | (1ul << 3) | (1ul << 2);
N    _I2C_WAIT_READY(port);
X    while(((port)->I2CON & (1ul << 3)) == 0);
N    return (port)->I2CDAT;
N}
N
N/**
N * @brief      Read a byte from I2C bus and return NAK
N *
N * @param[in]  port    I2C port. 
N *
N * @return     The byte got form I2C bus
N *
N * @details    This function is used to read a byte from specified I2C port and return NAK
N */
Nstatic __INLINE uint8_t I2C_ReadNak(I2C_T *port)
Xstatic __inline uint8_t I2C_ReadNak(I2C_T *port)
N{
N    (port)->I2CDAT= 0xFF;
N    (port)->I2CON = I2C_I2CON_ENS1_Msk | I2C_I2CON_SI_Msk;
X    (port)->I2CON = (1ul << 6) | (1ul << 3);
N    _I2C_WAIT_READY(port);
X    while(((port)->I2CON & (1ul << 3)) == 0);
N    return (port)->I2CDAT;
N}
N
N
N/**
N * @brief      Set I2C Clock Divider
N *
N * @param[in]  tI2C         I2C port 
N * @param[in]  u32BusClock  The target I2C Bus Clock in Hz
N *
N * @return     None
N *                                
N * @details    To set proper clock divider in I2C CLOCK DIVIDED REGISTER (I2CLK) 
N *             according to the target I2C Bus Clock. I2C bus clock = PCLK / (4x(divider+1)).
N *
N * @note
N *             The maximum of I2C bus clock is 1 MHz and the minimum of the divider is 4.
N */
Nstatic __INLINE void I2C_SetBusClockFreq(I2C_T * tI2C, uint32_t u32BusClock)
Xstatic __inline void I2C_SetBusClockFreq(I2C_T * tI2C, uint32_t u32BusClock)
N{
N    uint32_t u32divider;     
N 
N    u32divider = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1);
N                        
N    tI2C->I2CLK = (u32divider & ~0xFF)? 0xFF:((u32divider & ~0x03)? u32divider: 4);
N}
N
N
N/**
N  * @} End of I2C Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N#endif
N
L 6300 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "PWM.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\PWM.h" 1
N/**************************************************************************//**
N * @file     PWM.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 12/08/07 5:37p $
N * @brief    NUC200 Series PWM Generator and Capture Timer Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N *
N ******************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__    
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Includes of system headers                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup PWM_FUNC PWM Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PPR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_PPR_CP01(x)     (((x)-1) << PWM_PPR_CP01_Pos) /*!< PPR setting for PWM01 clock prescale. x = 2 ~ 256 */
N#define PWM_PPR_CP23(x)     (((x)-1) << PWM_PPR_CP23_Pos) /*!< PPR setting for PWM23 clock prescale. x = 2 ~ 256 */
N#define PWM_PPR_DZI01(x)    ((x)<< PWM_PPR_DZI01_Pos)  /*!< PPR setting for PWM01 dead zone. x = 0 ~ 255 */
N#define PWM_PPR_DZI23(x)    ((x)<< PWM_PPR_DZI23_Pos)  /*!< PPR setting for PWM01 dead zone. x = 0 ~ 255 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CSR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CSR_DIV1    4         /*!< CSR setting for PWM Timer clock source divided by 1 */
N#define PWM_CSR_DIV2    0         /*!< CSR setting for PWM Timer clock source divided by 2 */
N#define PWM_CSR_DIV4    1         /*!< CSR setting for PWM Timer clock source divided by 4 */
N#define PWM_CSR_DIV8    2         /*!< CSR setting for PWM Timer clock source divided by 8 */
N#define PWM_CSR_DIV16   3         /*!< CSR setting for PWM Timer clock source divided by 16 */
N
N#define PWM_CSR_CSR0(x)     ((x) << PWM_CSR_CSR0_Pos) /*!< CSR setting for CSR0 */
N#define PWM_CSR_CSR1(x)     ((x) << PWM_CSR_CSR1_Pos) /*!< CSR setting for CSR1 */
N#define PWM_CSR_CSR2(x)     ((x) << PWM_CSR_CSR2_Pos) /*!< CSR setting for CSR2 */
N#define PWM_CSR_CSR3(x)     ((x) << PWM_CSR_CSR3_Pos) /*!< CSR setting for CSR3 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PCR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_PCR_CH0EN_ENABLE    (1UL << PWM_PCR_CH0EN_Pos) /*!< PCR setting for channel 0 Timer Enable */
N#define PWM_PCR_CH1EN_ENABLE    (1UL << PWM_PCR_CH1EN_Pos) /*!< PCR setting for channel 1 Timer Enable */
N#define PWM_PCR_CH2EN_ENABLE    (1UL << PWM_PCR_CH2EN_Pos) /*!< PCR setting for channel 2 Timer Enable */
N#define PWM_PCR_CH3EN_ENABLE    (1UL << PWM_PCR_CH3EN_Pos) /*!< PCR setting for channel 3 Timer Enable */
N#define PWM_PCR_CH0INV_ENABLE   (1UL << PWM_PCR_CH0INV_Pos) /*!< PCR setting for channel 0 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH1INV_ENABLE   (1UL << PWM_PCR_CH1INV_Pos) /*!< PCR setting for channel 1 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH2INV_ENABLE   (1UL << PWM_PCR_CH2INV_Pos) /*!< PCR setting for channel 2 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH3INV_ENABLE   (1UL << PWM_PCR_CH3INV_Pos) /*!< PCR setting for channel 3 PWM-Timer Output Inverter Enable */
N#define PWM_PCR_CH0MOD_AUTO_RELOAD (1UL << PWM_PCR_CH0MOD_Pos) /*!< PCR setting for channel 0 Timer auto-reload mode */
N#define PWM_PCR_CH1MOD_AUTO_RELOAD (1UL << PWM_PCR_CH1MOD_Pos) /*!< PCR setting for channel 1 Timer auto-reload mode */
N#define PWM_PCR_CH2MOD_AUTO_RELOAD (1UL << PWM_PCR_CH2MOD_Pos) /*!< PCR setting for channel 2 Timer auto-reload mode */
N#define PWM_PCR_CH3MOD_AUTO_RELOAD (1UL << PWM_PCR_CH3MOD_Pos) /*!< PCR setting for channel 3 Timer auto-reload mode */
N#define PWM_PCR_CH0MOD_ONE_SHOT    0                           /*!< PCR setting for channel 0 Timer one-shot mode */
N#define PWM_PCR_CH1MOD_ONE_SHOT    0                           /*!< PCR setting for channel 1 Timer one-shot mode */
N#define PWM_PCR_CH2MOD_ONE_SHOT    0                           /*!< PCR setting for channel 2 Timer one-shot mode */
N#define PWM_PCR_CH3MOD_ONE_SHOT    0                           /*!< PCR setting for channel 3 Timer one-shot mode */
N#define PWM_PCR_DZEN01_ENABLE   (1UL << PWM_PCR_DZEN01_Pos) /*!< PCR setting for Dead-Zone 0 Generator Enable/ */
N#define PWM_PCR_DZEN23_ENABLE   (1UL << PWM_PCR_DZEN23_Pos) /*!< PCR setting for Dead-Zone 2 Generator Enable/ */
N#define PWM_PCR_PWM01TYPE_EDGE_ALIGNED      0                               /*!< PCR setting for PWM01 Edge-aligned type */
N#define PWM_PCR_PWM01TYPE_CENTER_ALIGNED    (1UL << PWM_PCR_PWM01TYPE_Pos)  /*!< PCR setting for PWM01 Center-aligned type */
N#define PWM_PCR_PWM23TYPE_EDGE_ALIGNED      0                               /*!< PCR setting for PWM23 Edge-aligned type */
N#define PWM_PCR_PWM23TYPE_CENTER_ALIGNED    (1UL << PWM_PCR_PWM23TYPE_Pos)  /*!< PCR setting for PWM23 Center-aligned type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PIER constants definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_PIER_PWMIE0_ENABLE  (1UL << PWM_PIER_PWMIE0_Pos) /*!< PIER setting for channel 0 Timer period Interrupt Enable */
N#define PWM_PIER_PWMIE1_ENABLE  (1UL << PWM_PIER_PWMIE1_Pos) /*!< PIER setting for channel 1 Timer period Interrupt Enable */
N#define PWM_PIER_PWMIE2_ENABLE  (1UL << PWM_PIER_PWMIE2_Pos) /*!< PIER setting for channel 2 Timer period Interrupt Enable */
N#define PWM_PIER_PWMIE3_ENABLE  (1UL << PWM_PIER_PWMIE3_Pos) /*!< PIER setting for channel 3 Timer period Interrupt Enable */
N#define PWM_PIER_PWMDIE0_ENABLE (1UL << PWM_PIER_PWMDIE0_Pos) /*!< PIER setting for channel 0 Timer duty Interrupt Enable */
N#define PWM_PIER_PWMDIE1_ENABLE (1UL << PWM_PIER_PWMDIE1_Pos) /*!< PIER setting for channel 1 Timer duty Interrupt Enable */
N#define PWM_PIER_PWMDIE2_ENABLE (1UL << PWM_PIER_PWMDIE2_Pos) /*!< PIER setting for channel 2 Timer duty Interrupt Enable */
N#define PWM_PIER_PWMDIE3_ENABLE (1UL << PWM_PIER_PWMDIE3_Pos) /*!< PIER setting for channel 3 Timer duty Interrupt Enable */
N#define PWM_PIER_INT01TYPE_PERIOD_COUNTER_MATCH_CNR (1UL << PWM_PIER_INT01TYPE_Pos) /*!< PIER setting for channel 0/1 Timer interrupt type to counter matches CNR */
N#define PWM_PIER_INT01TYPE_PERIOD_COUNTER_UNDERFLOW (1UL << PWM_PIER_INT01TYPE_Pos) /*!< PIER setting for channel 0/1 Timer interrupt type to counter underflow */
N#define PWM_PIER_INT23TYPE_PERIOD_COUNTER_MATCH_CNR (1UL << PWM_PIER_INT23TYPE_Pos) /*!< PIER setting for channel 2/3 Timer interrupt type to counter matches CNR */
N#define PWM_PIER_INT23TYPE_PERIOD_COUNTER_UNDERFLOW (1UL << PWM_PIER_INT23TYPE_Pos) /*!< PIER setting for channel 2/3 Timer interrupt type to counter underflow */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CCR0/CCR2 constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CCR0_INV0_ENABLE  (1UL << PWM_CCR0_INV0_Pos) /*!< CCR0 setting for Channel 0 Capture Inverter enable */
N#define PWM_CCR0_INV1_ENABLE  (1UL << PWM_CCR0_INV1_Pos) /*!< CCR0 setting for Channel 1 Capture Inverter enable */
N#define PWM_CCR2_INV2_ENABLE  (1UL << PWM_CCR2_INV2_Pos) /*!< CCR2 setting for Channel 2 Capture Inverter enable */
N#define PWM_CCR2_INV3_ENABLE  (1UL << PWM_CCR2_INV3_Pos) /*!< CCR2 setting for Channel 3 Capture Inverter enable */
N
N#define PWM_CCR0_CRL_IE0_ENABLE  (1UL << PWM_CCR0_CRL_IE0_Pos) /*!< CCR0 setting for Channel 0 Capture Rising Latch Interrupt Enable */
N#define PWM_CCR0_CRL_IE1_ENABLE  (1UL << PWM_CCR0_CRL_IE1_Pos) /*!< CCR0 setting for Channel 1 Capture Rising Latch Interrupt Enable */
N#define PWM_CCR2_CRL_IE2_ENABLE  (1UL << PWM_CCR2_CRL_IE2_Pos) /*!< CCR2 setting for Channel 2 Capture Rising Latch Interrupt Enable */
N#define PWM_CCR2_CRL_IE3_ENABLE  (1UL << PWM_CCR2_CRL_IE3_Pos) /*!< CCR2 setting for Channel 3 Capture Rising Latch Interrupt Enable */
N
N#define PWM_CCR0_CFL_IE0_ENABLE  (1UL << PWM_CCR0_CFL_IE0_Pos) /*!< CCR0 setting for Channel 0 Capture Falling Latch Interrupt Enable */
N#define PWM_CCR0_CFL_IE1_ENABLE  (1UL << PWM_CCR0_CFL_IE1_Pos) /*!< CCR0 setting for Channel 1 Capture Falling Latch Interrupt Enable */
N#define PWM_CCR2_CFL_IE2_ENABLE  (1UL << PWM_CCR2_CFL_IE2_Pos) /*!< CCR2 setting for Channel 2 Capture Falling Latch Interrupt Enable */
N#define PWM_CCR2_CFL_IE3_ENABLE  (1UL << PWM_CCR2_CFL_IE3_Pos) /*!< CCR2 setting for Channel 3 Capture Falling Latch Interrupt Enable */
N
N#define PWM_CCR0_CAPCH0EN_ENABLE  (1UL << PWM_CCR0_CAPCH0EN_Pos) /*!< CCR0 setting for Channel 0 Capture Function Enable */
N#define PWM_CCR0_CAPCH1EN_ENABLE  (1UL << PWM_CCR0_CAPCH1EN_Pos) /*!< CCR0 setting for Channel 1 Capture Function Enable */
N#define PWM_CCR2_CAPCH2EN_ENABLE  (1UL << PWM_CCR2_CAPCH2EN_Pos) /*!< CCR2 setting for Channel 2 Capture Function Enable */
N#define PWM_CCR2_CAPCH3EN_ENABLE  (1UL << PWM_CCR2_CAPCH3EN_Pos) /*!< CCR2 setting for Channel 3 Capture Function Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAPENR constants definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CAPENR_CINEN0_ENABLE  (1UL << PWM_CAPENR_CINEN0_Pos) /*!< CAPENR setting for Channel 0 Capture Input Enable */
N#define PWM_CAPENR_CINEN1_ENABLE  (1UL << PWM_CAPENR_CINEN1_Pos) /*!< CAPENR setting for Channel 1 Capture Input Enable */
N#define PWM_CAPENR_CINEN2_ENABLE  (1UL << PWM_CAPENR_CINEN2_Pos) /*!< CAPENR setting for Channel 2 Capture Input Enable */
N#define PWM_CAPENR_CINEN3_ENABLE  (1UL << PWM_CAPENR_CINEN3_Pos) /*!< CAPENR setting for Channel 3 Capture Input Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  POE constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_POE_POE0_ENABLE  (1UL << PWM_POE_POE0_Pos) /*!< POE setting for Channel 0 PWM Output Enable */
N#define PWM_POE_POE1_ENABLE  (1UL << PWM_POE_POE1_Pos) /*!< POE setting for Channel 1 PWM Output Enable */
N#define PWM_POE_POE2_ENABLE  (1UL << PWM_POE_POE2_Pos) /*!< POE setting for Channel 2 PWM Output Enable */
N#define PWM_POE_POE3_ENABLE  (1UL << PWM_POE_POE3_Pos) /*!< POE setting for Channel 3 PWM Output Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  TCON constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_TCON_PWM0TEN_ENABLE  (1UL << PWM_TCON_PWM0TEN_Pos) /*!< TCON setting for Channel 0 PWM trigger ADC Enable in Center-Aligned Trigger */
N#define PWM_TCON_PWM1TEN_ENABLE  (1UL << PWM_TCON_PWM1TEN_Pos) /*!< TCON setting for Channel 1 PWM trigger ADC Enable in Center-Aligned Trigger */
N#define PWM_TCON_PWM2TEN_ENABLE  (1UL << PWM_TCON_PWM2TEN_Pos) /*!< TCON setting for Channel 2 PWM trigger ADC Enable in Center-Aligned Trigger */
N#define PWM_TCON_PWM3TEN_ENABLE  (1UL << PWM_TCON_PWM3TEN_Pos) /*!< TCON setting for Channel 3 PWM trigger ADC Enable in Center-Aligned Trigger */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWM Group channel numebr constants definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CH0     0x0            /*!< PWM Group A/B channel 0 */
N#define PWM_CH1     0x1            /*!< PWM Group A/B channel 1 */
N#define PWM_CH2     0x2            /*!< PWM Group A/B channel 2 */
N#define PWM_CH3     0x3            /*!< PWM Group A/B channel 3 */
N
N#define PWM_CCR_MASK    0x000F000F          /*!< PWM CCR0/CCR2 bit0~3 and bit16~19 mask */ 
N
N
N/**
N * @brief      Set timer pre-scale for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @param[in]  u32Prescaler   PWM timer prescaler value(0 ~ 0xFF)
N *
N * @return     None
N *
N * @details    This function is used to set timer pre-scale for specified channel
N *
N * @note       - If u32Prescaler = 0, corresponding PWM-timer will be stopped
N *             - If u32Prescaler = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N 
N */
N#define _PWM_SET_TIMER_PRESCALE(PWM,u32Ch,u32Prescaler)\
N{\
N    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_CP01_Msk<<(((u32Ch)/2)*8))\
N                                 |((u32Prescaler)<<(PWM_PPR_CP01_Pos+(((u32Ch)/2)*8)));\
N}
X#define _PWM_SET_TIMER_PRESCALE(PWM,u32Ch,u32Prescaler){    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_CP01_Msk<<(((u32Ch)/2)*8))                                 |((u32Prescaler)<<(PWM_PPR_CP01_Pos+(((u32Ch)/2)*8)));}
N
N
N
N
N/**
N * @brief      Get timer pre-scale for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @return     Pre-scaler value (0~0xFF)
N *
N * @details    This function is used to get timer pre-scale for specified channel
N *
N * @note       - If retuened Pre-scaler value = 0, it means corresponding PWM-timer stop
N *             - If retuened Pre-scaler value = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N */
N#define _PWM_GET_TIMER_PRESCALE(PWM,u32Ch) (((PWM)->PPR&(PWM_PPR_CP01_Msk<<(((u32Ch)/2)*8)))>>(PWM_PPR_CP01_Pos+(((u32Ch)/2)*8)))
N
N
N
N
N/**
N * @brief      Set PWM dead-zone length for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH2   
N * @param[in]  u32DeadZoneLen PWM dead-zone length (0 - 0xFF)
N *
N * @return     None
N *
N * @details    This function is used to set PWM dead-zone length for specified channel.\n
N *             The unit time of dead zone length = [(prescale+1)*(clock source divider)]/PWMxy_CLK ,\n
N *             where xy, could be 01, 23 depends on selected PWM channel for PWM group A/B.
N *
N * @note       - Channel 0 and channel 1 are complementary pair and share the same dead-zone length.
N *             - Channel 2 and channel 3 are complementary pair and share the same dead-zone length. 
N *
N */
N#define _PWM_SET_PWM_DEADZONE_LENGTH(PWM,u32Ch,u32DeadZoneLen)\
N{\
N    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_DZI01_Msk<<(((u32Ch)/2)*8))\
N                                 |((u32DeadZoneLen)<<(PWM_PPR_DZI01_Pos+(((u32Ch)/2)*8)));\
N}
X#define _PWM_SET_PWM_DEADZONE_LENGTH(PWM,u32Ch,u32DeadZoneLen){    (PWM)->PPR = (PWM)->PPR&~(PWM_PPR_DZI01_Msk<<(((u32Ch)/2)*8))                                 |((u32DeadZoneLen)<<(PWM_PPR_DZI01_Pos+(((u32Ch)/2)*8)));}
N
N
N
N/**
N * @brief       Get PWM dead-zone length for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH2   
N *
N * @return     Specified channel PWM dead-zone length (0 - 0xFF)
N *
N * @details    This function is used to get PWM dead-zone length for specified channel.
N *
N *             The unit time of dead zone length = [(prescale+1)*(clock source divider)]/PWMxy_CLK , \n
N *             where xy, could be 01, 23, depends on selected PWM channel for PWM group A/B..
N *
N * @note       - Channel 0 and channel 1 are complementary pair and share the same dead-zone length.
N *             - Channel 2 and channel 3 are complementary pair and share the same dead-zone length.  
N */
N#define _PWM_GET_PWM_DEADZONE_LENGTH(PWM,u32Ch) (((PWM)->PPR&(PWM_PPR_DZI01_Msk<<(((u32Ch)/2)*8)))>>(PWM_PPR_DZI01_Pos+(((u32Ch)/2)*8)))
N
N
N
N
N/**
N * @brief       Set Timer clock source divider selection for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @param[in]  u32ClockDivSel Timer clock source divider selection
N *                            - PWM_CSR_DIV1 (4)
N *                            - PWM_CSR_DIV2 (0) 
N *                            - PWM_CSR_DIV4 (1) 
N *                            - PWM_CSR_DIV8 (2) 
N *                            - PWM_CSR_DIV16(3)   
N *
N * @return     None
N *
N * @details    This function is used to set Timer clock source divider selection for specified channel
N *
N */
N#define _PWM_SET_TIMER_CLOCK_DIV(PWM,u32Ch,u32ClockDivSel)\
N{\
N    (PWM)->CSR = (PWM)->CSR&~(PWM_CSR_CSR0_Msk<<((u32Ch)*4))\
N                                 |((u32ClockDivSel)<<(PWM_CSR_CSR0_Pos+((u32Ch)*4)));\
N}
X#define _PWM_SET_TIMER_CLOCK_DIV(PWM,u32Ch,u32ClockDivSel){    (PWM)->CSR = (PWM)->CSR&~(PWM_CSR_CSR0_Msk<<((u32Ch)*4))                                 |((u32ClockDivSel)<<(PWM_CSR_CSR0_Pos+((u32Ch)*4)));}
N
N
N/**
N * @brief      Get timer clock source divider selection for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3     
N * @retval     4              Input clock divided by 1
N * @retval     0              Input clock divided by 2
N * @retval     1              Input clock divided by 4
N * @retval     2              Input clock divided by 8
N * @retval     3              Input clock divided by 16    
N *
N * @details    This function is used to get timer clock source divider selection for specified channel
N *
N */
N#define _PWM_GET_TIMER_CLOCK_DIV(PWM,u32Ch) (((PWM)->CSR&(PWM_CSR_CSR0_Msk<<((u32Ch)*4)))>>(PWM_CSR_CSR0_Pos+((u32Ch)*4)))
N
N
N
N
N/**
N * @brief      Enable timer for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable timer for specified channel
N *
N */
N#define _PWM_ENABLE_TIMER(PWM,u32Ch) (PWM)->PCR|= (PWM_PCR_CH0EN_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Disable timer for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable timer for specified channel
N *
N */
N#define _PWM_DISABLE_TIMER(PWM,u32Ch) (PWM)->PCR&= ~(PWM_PCR_CH0EN_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Enable PWM output polar inverse for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable PWM output polar inverse for specified channel
N *
N */
N#define _PWM_ENABLE_PWM_POLAR_INV(PWM,u32Ch) (PWM)->PCR|= (PWM_PCR_CH0PINV_Msk<<((u32Ch)*8))
N
N
N
N/**
N * @brief      Disable PWM output polar inverse for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable PWM output polar inverse for specified channel
N *
N */
N#define _PWM_DISABLE_PWM_POLAR_INV(PWM,u32Ch) (PWM)->PCR&= ~(PWM_PCR_CH0PINV_Msk<<((u32Ch)*8))
N
N
N
N/**
N * @brief      Enable PWM output inveter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable PWM output inveter for specified channel
N *
N */
N#define _PWM_ENABLE_PWM_INV(PWM,u32Ch) (PWM)->PCR|= (PWM_PCR_CH0INV_Msk<<((u32Ch)*8))
N
N
N
N/**
N * @brief      Disable PWM output inveter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable PWM output inveter for specified channel
N *
N */
N#define _PWM_DISABLE_PWM_INV(PWM,u32Ch) (PWM)->PCR&= ~(PWM_PCR_CH0INV_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Set timer auto-reolad mode for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer auto-reolad mode for specified channel
N *
N * @note       If user changes timer mode from auto-reload to one-shot or from one-shot to auto-reload mode,\n
N *             it will cause CNR0 and CMR0 be clear.
N *
N */
N#define _PWM_SET_TIMER_AUTO_RELOAD_MODE(PWM,u32Ch) (PWM)->PCR |= (PWM_PCR_CH0MOD_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Set timer One-shot mode for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer One-shot mode for specified channel
N *
N * @note       - If user changes timer mode from auto-reload to one-shot or from one-shot to auto-reload mode,\n
N *             it will cause CNR0 and CMR0 be clear.
N *             - After PWM waveform generated once in PWM one-shot mode, CNR and CMR settings will be cleared and\n
N *               PWM-Timer will stop automatically.
N *               The following procedure is recommended for re-starting PWM single-shot waveform.
N *               Step 1: Setup comparator register (CMR) for setting PWM duty.
N *               Step 2: Setup PWM down-counter register (CNR) for setting PWM period. After setup CNR, PWM wave will be generated once again.
N *
N */
N#define _PWM_SET_TIMER_ONE_SHOT_MODE(PWM,u32Ch) (PWM)->PCR &= ~(PWM_PCR_CH0MOD_Msk<<((u32Ch)*8))
N
N
N
N
N/**
N * @brief      Enable PWM Dead-Zone generator for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH2   
N * @return     None
N *
N * @details    This function is used to enable PWM Dead-Zone generator for specified channel pair
N *
N * @note       - When Channel 0 Dead-Zone Generator is enabled, channel 0 and channel 1 becomes a complementary pair.  
N *             - When Channel 2 Dead-Zone Generator is enabled, channel 2 and channel 3 becomes a complementary pair.  
N *
N */
N#define _PWM_ENABLE_PWM_DEADZONE(PWM,u32Ch) (PWM)->PCR|=(PWM_PCR_DZEN01_Msk<<((u32Ch)/2))
N
N
N
N
N/**
N * @brief      Disable PWM Dead-Zone generator for specified channel pair
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable PWM Dead-Zone generator for specified channel pair
N *
N */
N#define _PWM_DISABLE_PWM_DEADZONE(PWM,u32Ch) (PWM)->PCR&=~(PWM_PCR_DZEN01_Msk<<((u32Ch)/2))
N
N
N
N/**
N * @brief      Set timer edge-aligned type for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer edge-aligned type for specified channel
N *
N *
N */
N#define _PWM_SET_TIMER_EDGE_ALIGNED_TYPE(PWM,u32Ch) (PWM)->PCR &= ~(PWM_PCR_PWM01TYPE_Msk<<((u32Ch)/2))
N
N
N
N
N/**
N * @brief      Set timer center-aligned type for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer center-aligned type for specified channel
N *
N *
N */
N#define _PWM_SET_TIMER_CENTER_ALIGNED_TYPE(PWM,u32Ch) (PWM)->PCR |= (PWM_PCR_PWM01TYPE_Msk<<((u32Ch)/2))
N
N
N
N
N/**
N * @brief      Set timer loaded value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3  
N * @param[in]  u32LoadedVal   Timer loaded value(0~0xFFFF)
N *     
N * @return     None
N *
N * @details    This function is used to set timer loaded value(CNR) for specified channel.\n
N *             Loaded value determines the PWM period.
N *
N * @note       - If u32LoadedVal=0, PWM timer counter will stop.   
N *
N */
N#define _PWM_SET_TIMER_LOADED_VALUE(PWM,u32Ch,u32LoadedVal)\
N{\
N     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CNR0) + (u32Ch)*12))) = (u32LoadedVal));\
N}
X#define _PWM_SET_TIMER_LOADED_VALUE(PWM,u32Ch,u32LoadedVal){     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CNR0) + (u32Ch)*12))) = (u32LoadedVal));}
N
N
N
N/**
N * @brief      Get timer loaded value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     Timer loaded value (0 - 0xFFFF)
N *
N * @details    This function is used to get timer loaded value for specified channel
N *
N */
N#define _PWM_GET_TIMER_LOADED_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CNR0) + (u32Ch)*12))))
N
N
N
N
N/**
N * @brief      Set PWM Comparator value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3  
N * @param[in]  u32Compatator  PWM Comparator value (0 - 0xFFFF)
N *  
N * @return     None
N *
N * @details    This function is used to set PWM Comparator value for specified channel
N *
N */
N#define _PWM_SET_PWM_COMP_VALUE(PWM,u32Ch,u32Compatator)\
N{\
N     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CMR0) + (u32Ch)*12))) = (u32Compatator));\
N}
X#define _PWM_SET_PWM_COMP_VALUE(PWM,u32Ch,u32Compatator){     (*((__IO uint32_t *) (((uint32_t)&((PWM)->CMR0) + (u32Ch)*12))) = (u32Compatator));}
N
N
N
N/**
N * @brief      Get PWM Comparator value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     PWM Comparator value (0 - 0xFFFF)
N *
N * @details    This function is used to get PWM Comparator value for specified channel
N *
N */
N#define _PWM_GET_PWM_COMP_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CMR0) + (u32Ch)*12))))
N
N
N
N
N/**
N * @brief      Get timer current counter value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3 
N * @return     Timer current counter value (0 - 0xFFFF)      
N *
N * @details    This function is used to get timer current counter value(PDR) for specified channel.\n
N *             User can monitor PDR to know the current value in 16-bit counter.
N *
N */
N#define _PWM_GET_TIMER_CURRENT_COUNTER_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->PDR0)) + (u32Ch)*12)))
N
N
N
N
N/**
N * @brief      Enable timer period interrupt for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable timer period interrupt for specified channel
N *
N */
N#define _PWM_ENABLE_TIMER_PERIOD_INT(PWM,u32Ch) ((PWM)->PIER|= (PWM_PIER_PWMIE0_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief       Disable timer period interrupt for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable timer period interrupt for specified channel
N *
N */
N#define _PWM_DISABLE_TIMER_PERIOD_INT(PWM,u32Ch) ((PWM)->PIER&= ~(PWM_PIER_PWMIE0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief      Enable timer duty interrupt for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable timer duty interrupt for specified channel
N *
N */
N#define _PWM_ENABLE_TIMER_DUTY_INT(PWM,u32Ch) ((PWM)->PIER|= (PWM_PIER_PWMDIE0_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief       Disable timer duty interrupt for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable timer duty interrupt for specified channel
N *
N */
N#define _PWM_DISABLE_TIMER_DUTY_INT(PWM,u32Ch) ((PWM)->PIER&= ~(PWM_PIER_PWMDIE0_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief      Set timer interrupt period type interrupt to counter matches to CNR for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer interrupt period type interrupt to counter matches to CNR for specified channel
N *
N * @note       This bit is effective when timer in center aligned type only.
N *             
N */
N#define _PWM_SET_TIMER_PERIOD_INTTYPE_MATCH_CNR(PWM,u32Ch) ((PWM)->PIER|= (PWM_PIER_INT01TYPE_Msk<<((u32Ch)/2)))
N
N
N
N
N/**
N * @brief      Set timer interrupt period type interrupt to counter underflow for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to set timer interrupt period type interrupt to counter matches to CNR for specified channel
N *
N * @note       This function is effective when timer in center aligned type only.
N * 
N */
N#define _PWM_SET_TIMER_PERIOD_INTTYPE_UNDERFLOW(PWM,u32Ch) ((PWM)->PIER&= ~(PWM_PIER_INT01TYPE_Msk<<((u32Ch)/2)))
N
N
N
N
N/**
N * @brief       Get timer period interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @retval      0             The specified channel timer period interrupt flag is not set 
N * @retval      1             The specified channel timer period interrupt flag is set
N *
N * @details    This function is used to get timer period interrupt flag for specified channel
N *
N */
N#define _PWM_GET_TIMER_PERIOD_INT_FLAG(PWM,u32Ch) (((PWM)->PIIR&(PWM_PIIR_PWMIF0_Msk<<(u32Ch)))?1:0)
N
N
N
N
N/**
N * @brief      Clear timer period interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to clear timer period interrupt flag for specified channel
N *
N */
N#define _PWM_CLEAR_TIMER_PERIOD_INT_FLAG(PWM,u32Ch) ((PWM)->PIIR = (PWM_PIIR_PWMIF0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief       Get timer duty interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @retval      0             The specified channel timer duty interrupt flag is not set 
N * @retval      1             The specified channel timer duty interrupt flag is set
N *
N * @details    This function is used to get timer duty interrupt flag for specified channel
N *
N */
N#define _PWM_GET_TIMER_DUTY_INT_FLAG(PWM,u32Ch) (((PWM)->PIIR&(PWM_PIIR_PWMDIF0_Msk<<(u32Ch)))?1:0)
N
N
N/**
N * @brief      Clear timer duty interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to clear timer duty interrupt flag for specified channel
N *
N */
N#define _PWM_CLEAR_TIMER_DUTY_INT_FLAG(PWM,u32Ch) ((PWM)->PIIR = (PWM_PIIR_PWMDIF0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief      Enable capture input inverter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable capture input inverter for specified channel
N *
N * @note       PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_ENABLE_CAP_INV(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_INV(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief      Disable capture input inverter for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable capture input inverter for specified channel
N *
N * @note       PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_DISABLE_CAP_INV(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_INV(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_INV0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_INV2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Enable capture rising latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable capture rising latch interrupt for specified channel
N *
N * @note       PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_ENABLE_CAP_RISING_INT(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_RISING_INT(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Disable capture rising latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture rising latch interrupt for specified channel
N *
N * @note       PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_DISABLE_CAP_RISING_INT(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_RISING_INT(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CRL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CRL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Enable capture falling latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable capture falling latch interrupt for specified channel
N *
N * @note       PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_ENABLE_CAP_FALLING_INT(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_FALLING_INT(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Disable capture falling latch interrupt for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture falling latch interrupt for specified channel
N *
N * @note       PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_DISABLE_CAP_FALLING_INT(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_FALLING_INT(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CFL_IE0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CFL_IE2_Msk<<(((u32Ch)%2)*16)));}
N
N
N/**
N * @brief       Enable capture function for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable capture function for specified channel
N *
N * @note        - When capture function enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch). 
N *              - PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_ENABLE_CAP_FUNC(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_ENABLE_CAP_FUNC(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Disable capture function for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture function for specified channel
N *
N * @note        - When capture function disabled, Capture does not update CRLR and CFLR, and disable specified channel Interrupt.
N *              - PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *
N */
N#define _PWM_DISABLE_CAP_FUNC(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_DISABLE_CAP_FUNC(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = ((PWM)->CCR0&PWM_CCR_MASK)&~(PWM_CCR0_CAPCH0EN_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = ((PWM)->CCR2&PWM_CCR_MASK)&~(PWM_CCR2_CAPCH2EN_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Get capture interrupt flag for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @retval      0             The specified channel capture interrupt flag is not set 
N * @retval      1             The specified channel capture interrupt flag is set
N *
N * @details     This function is used to get capture interrupt flag for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_INT_FLAG(PWM,u32Ch) ((u32Ch)<2)?\
N        (((PWM)->CCR0&(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16)))?1:0):\
N        (((PWM)->CCR2&(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)))?1:0)
X#define _PWM_GET_CAP_INT_FLAG(PWM,u32Ch) ((u32Ch)<2)?        (((PWM)->CCR0&(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16)))?1:0):        (((PWM)->CCR2&(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)))?1:0)
N
N/**
N * @brief      Clear capture interrupt flag for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to clear capture interrupt flag for specified channel
N *
N * @note       - PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *             - Write 1 to clear this bit
N *
N */
N#define _PWM_CLR_CAP_INT_FLAG(PWM,u32Ch)\
N{\
N    (u32Ch<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_CLR_CAP_INT_FLAG(PWM,u32Ch){    (u32Ch<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CAPIF0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CAPIF2_Msk<<(((u32Ch)%2)*16)));}
N
N/**
N * @brief       Get capture rising latched indicator for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @retval      0             The specified channel capture falling rising indicator is not set 
N * @retval      1             The specified channel capture falling rising indicator is set
N *
N * @details     This function is used to get capture rising latched indicator for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_RISING_INDICATOR(PWM,u32Ch) ((u32Ch)<2)?\
N    (((PWM)->CCR0&(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16)))?1:0):\
N    (((PWM)->CCR2&(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)\
N
X#define _PWM_GET_CAP_RISING_INDICATOR(PWM,u32Ch) ((u32Ch)<2)?    (((PWM)->CCR0&(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16)))?1:0):    (((PWM)->CCR2&(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)
N
N
N
N/**
N * @brief      Clear capture rising latched indicator for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to clear capture rising latched indicator for specified channel
N *
N * @note       - PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *             - Write 1 to clear this bit
N *
N */
N#define _PWM_CLR_CAP_RISING_INDICATOR(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_CLR_CAP_RISING_INDICATOR(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CRLRI0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CRLRI2_Msk<<(((u32Ch)%2)*16)));}
N        
N
N
N
N/**
N * @brief      Get capture falling latched indicator for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3    
N * @retval      0        The specified channel capture falling latched indicator is not set 
N * @retval      1        The specified channel capture falling latched indicator is set
N *
N * @details     This function is used to get capture falling latched indicator for specified channel
N *
N */
N#define _PWM_GET_CAP_FALLING_INDICATOR(PWM,u32Ch) (u32Ch<2)?\
N    (((PWM)->CCR0&(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16)))?1:0):\
N    (((PWM)->CCR2&(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)
X#define _PWM_GET_CAP_FALLING_INDICATOR(PWM,u32Ch) (u32Ch<2)?    (((PWM)->CCR0&(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16)))?1:0):    (((PWM)->CCR2&(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)))?1:0)
N
N
N
N
N/**
N * @brief       Clear capture falling latched indicator for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to clear capture falling latched indicator for specified channel
N *
N * @note       - PBCR register must be set to 1 for specified capture group to prevent CFLRIx/CRLRIx is cleared when writing CCR0/CCR2
N *             - Write 1 to clear this bit
N *
N */
N#define _PWM_CLR_CAP_FALLING_INDICATOR(PWM,u32Ch)\
N{\
N    ((u32Ch)<2)?\
N    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16))):\
N    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)));\
N}
X#define _PWM_CLR_CAP_FALLING_INDICATOR(PWM,u32Ch){    ((u32Ch)<2)?    ((PWM)->CCR0 = (PWM)->CCR0&PWM_CCR_MASK|(PWM_CCR0_CFLRI0_Msk<<((u32Ch)*16))):    ((PWM)->CCR2 = (PWM)->CCR2&PWM_CCR_MASK|(PWM_CCR2_CFLRI2_Msk<<(((u32Ch)%2)*16)));}
N
N
N
N
N/**
N * @brief       Get capture rising latch register value for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      Capture rising latch register value 
N *
N * @details     This function is used to get capture rising latch register value for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_RISING_LATCH_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CRLR0) + (u32Ch)*8))))
N
N
N
N
N/**
N * @brief      Get capture falling latch register value for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     Capture falling latch register value 
N *
N * @details    This function is used to get capture falling latch register value for specified channel
N *
N *
N */
N#define _PWM_GET_CAP_FALLING_LATCH_VALUE(PWM,u32Ch) (*((__IO uint32_t *) (((uint32_t)&((PWM)->CFLR0) + (u32Ch)*8))))
N
N
N
N
N/**
N * @brief      Enable capture input path for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to enable capture input path for specified channel
N *
N *
N */
N#define _PWM_ENABLE_CAP_IN(PWM,u32Ch) ((PWM)->CAPENR |= (PWM_CAPENR_CINEN0_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief       Disable capture input path for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable capture input path for specified channel
N *
N *
N */
N#define _PWM_DISABLE_CAP_IN(PWM,u32Ch) ((PWM)->CAPENR&= ~(PWM_CAPENR_CINEN0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief       Enable PWM output path for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable PWM output path for specified channel
N *
N *
N */
N#define _PWM_ENABLE_PWM_OUT(PWM,u32Ch) ((PWM)->POE |= (PWM_POE_POE0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief      Disable PWM output path for specified channel
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to disable PWM output path for specified channel.
N *
N *
N */
N#define _PWM_DISABLE_PWM_OUT(PWM,u32Ch) ((PWM)->POE&= ~(PWM_POE_POE0_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief       Enable timer period trigger ADC function in center-aligned type for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to enable timer trigger ADC to start conversion when PWM counter up count to CNR
N *
N * @note        This function only support when PWM operating at center-aligned mode  
N *
N */
N#define _PWM_ENABLE_TIMER_PERIOD_TRIG_ADC(PWM,u32Ch) ((PWM)->TCON |= (PWM_TCON_PWM0TEN_Msk<<(u32Ch)))
N
N
N
N
N/**
N * @brief       Disable timer period trigger ADC function in center-aligned type for specified channel
N *
N * @param[in]   PWM            PWM group 
N *                             - PWMA : PWM Group A
N *                             - PWMB : PWM Group B 
N * @param[in]   u32Ch          PWM channel for PWM group A/B
N *                             - PWM_CH0
N *                             - PWM_CH1
N *                             - PWM_CH2
N *                             - PWM_CH3      
N * @return      None
N *
N * @details     This function is used to disable timer trigger ADC to start conversion when PWM counter up count to CNR
N *
N * @note        This function only support when PWM operating at center-aligned mode  
N *
N */
N#define _PWM_DISABLE_TIMER_PERIOD_TRIG_ADC(PWM,u32Ch) ((PWM)->TCON &= ~(PWM_TCON_PWM0TEN_Msk<<(u32Ch)))
N
N
N
N/**
N * @brief       Get timer trigger ADC to start conversion flag interrupt flag
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @retval      0             The specified channel timer trigger ADC to start conversion flag is not set 
N * @retval      1             The specified channel timer trigger ADC to start conversion flag is set
N *
N * @details    This function is used to get timer trigger ADC to start conversion flag interrupt flag
N *
N */
N#define _PWM_GET_TIMER_TRIG_ADC_FLAG(PWM,u32Ch) (((PWM)->TSTATUS&(PWM_TSTATUS_PWM0TF_Msk<<(u32Ch)))?1:0)
N
N
N
N
N/**
N * @brief      Clear timer trigger ADC to start conversion flag interrupt flag
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3      
N * @return     None
N *
N * @details    This function is used to clear timer trigger ADC to start conversion flag interrupt flag
N *
N */
N#define _PWM_CLEAR_TIMER_TRIG_ADC_FLAG(PWM,u32Ch) ((PWM)->TSTATUS = (PWM_TSTATUS_PWM0TF_Msk<<(u32Ch)))
N
N
N
N        
N/**
N * @brief      Reset PWM controller for specified group
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B     
N * @return     None
N *                                                           
N * @details    The function is used to reset PWM controller for specified group
N *
N * @note       PWM channel 0~3 in each group share the same PWM reset controller.
N */ 
N__INLINE void PWM_ResetPwmController(PWM_T* PWM)
X__inline void PWM_ResetPwmController(PWM_T* PWM)
N{
N    SYS->IPRSTC2 |= (SYS_IPRSTC2_PWM03_RST_Msk<<(((PWM)==PWMA)?0:1));
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |= ((1ul << 20)<<(((PWM)==((PWM_T *) ((( uint32_t)0x40000000) + 0x40000)))?0:1));
N    SYS->IPRSTC2 &= ~((SYS_IPRSTC2_PWM03_RST_Msk<<(((PWM)==PWMA)?0:1)));
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(((1ul << 20)<<(((PWM)==((PWM_T *) ((( uint32_t)0x40000000) + 0x40000)))?0:1)));
N}  
N
N
N
N
N/**
N * @brief      Get PWM Clock Source Frequency
N *
N * @param[in]  PWM            PWM group 
N *                            - PWMA : PWM Group A
N *                            - PWMB : PWM Group B 
N * @param[in]  u32Ch          PWM channel for PWM group A/B
N *                            - PWM_CH0
N *                            - PWM_CH1
N *                            - PWM_CH2
N *                            - PWM_CH3  
N * @return     PWM clock source frequency
N * @details    Get the PWM clock source frequency for specified channel.
N *
N * @note       - PWM channel 0 and channel 1 share the same clock source setting. 
N *             - PWM channel 2 and channel 3 share the same clock source setting. 
N */
N__INLINE uint32_t PWM_GetTimerClockSource(PWM_T* PWM, uint32_t u32Ch)
X__inline uint32_t PWM_GetTimerClockSource(PWM_T* PWM, uint32_t u32Ch)
N{
N    uint8_t     u8EngineClk;
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};
N    
N    u32ClkTbl[2] = SystemCoreClock;        
N    u8EngineClk = ((PWM)==PWMA)?((SYSCLK->CLKSEL1&(SYSCLK_CLKSEL1_PWM01_S_Msk<<(((u32Ch)/2)*2)))
X    u8EngineClk = ((PWM)==((PWM_T *) ((( uint32_t)0x40000000) + 0x40000)))?((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1&((3ul << 28)<<(((u32Ch)/2)*2)))
N                               >>(SYSCLK_CLKSEL1_PWM01_S_Pos+((u32Ch)/2)*2)):
X                               >>(28+((u32Ch)/2)*2)):
N                              ((SYSCLK->CLKSEL2&(SYSCLK_CLKSEL2_PWM45_S_Msk<<(((u32Ch)/2)*2)))
X                              ((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL2&((3ul << 4)<<(((u32Ch)/2)*2)))
N                               >>(SYSCLK_CLKSEL2_PWM45_S_Pos+((u32Ch)/2)*2));                                             
X                               >>(4+((u32Ch)/2)*2));                                             
N    return u32ClkTbl[u8EngineClk];    
N}
N
N
N/**
N  * @} End of PWM Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif  //__PWM_H__
N
N
N
L 6301 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "SPI.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\SPI.h" 1
N/**************************************************************************//**
N * @file     SPI.h
N * @version  V1.0
N * $Revision: 3 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series SPI Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "NUC200Series.h"
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup SPI_FUNC SPI Device Function Interface
N  * @{
N  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_CNTRL constant definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_CNTRL_VARCLK_EN              (1UL << 23) /*!< SPI_CNTRL setting for enable variable clock function */
N#define SPI_CNTRL_2BIT_EN                (1UL << 22) /*!< SPI_CNTRL setting for enable 2-bit transfer mode */
N#define SPI_CNTRL_FIFO_MODE_EN           (1UL << 21) /*!< SPI_CNTRL setting for enable FIFO mode */
N#define SPI_CNTRL_REORDER_EN             (1UL << 19) /*!< SPI_CNTRL setting for enable byte reorder function */
N#define SPI_CNTRL_MASTER_MODE            (0UL << 18) /*!< SPI_CNTRL setting for SPI master mode */
N#define SPI_CNTRL_SLAVE_MODE             (1UL << 18) /*!< SPI_CNTRL setting for SPI slave mode */
N#define SPI_CNTRL_IE_EN                  (1UL << 17) /*!< SPI_CNTRL setting for eanble interrupt */
N#define SPI_CNTRL_IF                     (1UL << 16) /*!< SPI_CNTRL unit transfer interrupt flag */
N#define SPI_CNTRL_SP_CYCLE(x)            ((x) << 12) /*!< SPI_CNTRL setting for suspend interval. it could be 0~15 */
N#define SPI_CNTRL_CLK_IDLE_HIGH          (1UL << 11) /*!< SPI_CNTRL setting for clock idle high */
N#define SPI_CNTRL_CLK_IDLE_LOW           (0)         /*!< SPI_CNTRL setting for clock idle low */
N#define SPI_CNTRL_LSB_FIRST              (1UL << 10) /*!< SPI_CNTRL setting for data format as LSB first */
N#define SPI_CNTRL_MSB_FIRST              (0)         /*!< SPI_CNTRL setting for data format as MSB first */
N#define SPI_CNTRL_TX_BIT_LEN(x)          ((((x)!=32)?(x):0) << 3) /*!< SPI_CNTRL setting for bit length of a transfer. it could be 8~32 */
N#define SPI_CNTRL_TX_RISING              (0)         /*!< SPI_CNTRL setting for output data on SPICLK rising edge */
N#define SPI_CNTRL_TX_FALLING             (4)         /*!< SPI_CNTRL setting for output data on SPICLK falling edge */
N#define SPI_CNTRL_RX_RISING              (0)         /*!< SPI_CNTRL setting for latch data on SPICLK rising edge */
N#define SPI_CNTRL_RX_FALLING             (2)         /*!< SPI_CNTRL setting for latch data on SPICLK falling edge */
N#define SPI_CNTRL_GO_BUSY                (1)         /*!< SPI_CNTRL setting for trigger SPI */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_DIVIDER constant definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_DIVIDER_DIV(x)  (x)         /*!< SPI_DIVIDER setting for SPI master clock divider. It could be 0~255 */
N#define SPI_DIVIDER_DIV2(x) ((x) << 16) /*!< SPI_DIVIDER setting for SPI master clock divider2 of varialbe clock function. It could be 0~255 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_SSR constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_SSR_SLAVE_FALLING_EDGE_TRIGGER (0x0)  /*!< SPI_SSR setting for falling edge trigger in SPI slave mode */
N#define SPI_SSR_SLAVE_RISING_EDGE_TRIGGER  (0x4)  /*!< SPI_SSR setting for rising edge trigger in SPI slave mode */
N#define SPI_SSR_SLAVE_LOW_LEVEL_ACTIVE     (0x10) /*!< SPI_SSR setting for low level active in SPI slave mode */
N#define SPI_SSR_SLAVE_HIGH_LEVEL_ACTIVE    (0x14) /*!< SPI_SSR setting for high level active in SPI slave mode */
N#define SPI_SSR_HW_AUTO_ACTIVE_LOW         (0x9)  /*!< SPI_SSR setting for SPI master SS signal is controled by hardware automatically and active low */
N#define SPI_SSR_HW_AUTO_ACTIVE_HIGH        (0xD)  /*!< SPI_SSR setting for SPI master SS signal is controled by hardware automatically active high */
N#define SPI_SSR_SW_SS_PIN_LOW              (0x1)  /*!< SPI_SSR setting to force SPI master SS signal to low by software */
N#define SPI_SSR_SW_SS_PIN_HIGH             (0x0)  /*!< SPI_SSR setting to force SPI master SS signal to high by software */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_DMA constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_DMA_RESET_PDMA                         (1UL << 2)  /*!< SPI_DMA setting for PDMA reset */
N#define SPI_DMA_RX_PDMA_GO                         (1UL << 1)  /*!< SPI_DMA setting for enable Rx PDMA */
N#define SPI_DMA_TX_PDMA_GO                         (1UL << 0)  /*!< SPI_DMA setting for enable Tx PDMA */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_CNTRL2 constant definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_CNTRL2_CLOCK_SETTING_NOT_BACKWARD_COMPATIBLE (1UL << 31) /*!< SPI_CNTRL2 setting for new clock configuration */
N#define SPI_CNTRL2_SLAVE_SELECT_INACTIVE_INT_EN          (1UL << 16) /*!< SPI_CNTRL2 setting for slave select inactive interrupt enable */
N#define SPI_CNTRL2_DUAL_IO_INPUT_MODE                    (2UL << 12) /*!< SPI_CNTRL2 setting for dual I/O input mode */
N#define SPI_CNTRL2_DUAL_IO_OUTPUT_MODE                   (3UL << 12) /*!< SPI_CNTRL2 setting for dual I/O output mode */
N#define SPI_CNTRL2_3WIRE_START_INTSTS                    (1UL << 11) /*!< SPI_CNTRL2 3-wire mode start interrupt flag */
N#define SPI_CNTRL2_3WIRE_START_INT_EN                    (1UL << 10) /*!< SPI_CNTRL2 setting for 3-wire mode start interrupt enable */
N#define SPI_CNTRL2_3WIRE_ABORT                           (1UL << 9)  /*!< SPI_CNTRL2 setting for 3-wire mode transfer abort */
N#define SPI_CNTRL2_3WIRE_MODE_EN                         (1UL << 8)  /*!< SPI_CNTRL2 setting for 3-wire mode enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_FIFO_CTL constant definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_FIFO_CTL_TX_THRESHOLD(x)   ((x) << 28) /*!< SPI_FIFO_CTL setting for Tx FIFO threshold         */
N#define SPI_FIFO_CTL_RX_THRESHOLD(x)   ((x) << 24) /*!< SPI_FIFO_CTL setting for Rx FIFO threshold         */
N#define SPI_FIFO_CTL_TIMEOUT_INT_EN    (1UL << 21) /*!< SPI_FIFO_CTL setting for time-out interrupt enable */
N#define SPI_FIFO_CTL_RX_OVERRUN_INT_EN (1UL << 6)  /*!< SPI_FIFO_CTL setting for Rx FIFO overrun interrupt enable */
N#define SPI_FIFO_CTL_TX_INT_EN         (1UL << 3)  /*!< SPI_FIFO_CTL setting for Tx FIFO interrupt enable */
N#define SPI_FIFO_CTL_RX_INT_EN         (1UL << 2)  /*!< SPI_FIFO_CTL setting for Rx FIFO interrupt enable */
N#define SPI_FIFO_CTL_TX_CLEAR          (1UL << 1)  /*!< SPI_FIFO_CTL setting for clearing Tx FIFO */
N#define SPI_FIFO_CTL_RX_CLEAR          (1)         /*!< SPI_FIFO_CTL setting for clearing Rx FIFO */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SPI_STATUS constant definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SPI_STATUS_TIMEOUT_FLAG        (1UL << 20) /*!< SPI_STATUS time-out flag */
N#define SPI_STATUS_IF                  (1UL << 16) /*!< SPI_STATUS unit transfer interrupt flag */
N#define SPI_STATUS_3WIRE_START_INTSTS  (1UL << 11) /*!< SPI_STATUS 3-wire mode start interrupt flag */
N#define SPI_STATUS_RX_OVERRUN          (1UL << 2)  /*!< SPI_STATUS Rx FIFO overrun flag */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @details    Configure the user-specified SPI port as a master
N */
N#define _SPI_SET_MASTER_MODE(port) ((port)->CNTRL &= (~SPI_CNTRL_SLAVE_MODE))
N
N/**
N * @details    Configure the user-specified SPI port as a slave
N */
N#define _SPI_SET_SLAVE_MODE(port) ((port)->CNTRL |= SPI_CNTRL_SLAVE_MODE)
N
N/**
N * @details    Configure the transfer bit length of the user-specified SPI port
N */
N#define _SPI_SET_TRANSFER_BIT_LENGTH(port, x) ((port)->CNTRL = ((port)->CNTRL & (~SPI_CNTRL_TX_BIT_LEN_Msk)) | SPI_CNTRL_TX_BIT_LEN(x))
N
N/**
N * @details    Enable the automatic slave select function of the user-specified SPI port
N */
N#define _SPI_ENABLE_HW_AUTO_SLAVE_SELECT(port) ((port)->SSR |= SPI_SSR_AUTOSS_Msk)
N
N/**
N * @details    Disable the automatic slave select function of the user-specified SPI port
N */
N#define _SPI_DISABLE_HW_AUTO_SLAVE_SELECT(port) ((port)->SSR &= (~SPI_SSR_AUTOSS_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE1(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_TX_NEG_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE2(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_RX_NEG_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE5(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk))
N
N/**
N * @details    Configure the timing type of the user-specified SPI port
N */
N#define _SPI_SET_TIMING_TYPE6(port) ((port)->CNTRL = ((port)->CNTRL & (~(SPI_CNTRL_CLKP_Msk|SPI_CNTRL_TX_NEG_Msk|SPI_CNTRL_RX_NEG_Msk)) | SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk))
N
N/**
N * @details    Configure the user-specified SPI port as LSB-first transfer type
N */
N#define _SPI_SET_TRANSFER_LSB_FIRST(port) ((port)->CNTRL |= SPI_CNTRL_LSB_FIRST)
N
N/**
N * @details    Configure the user-specified SPI port as MSB-first transfer type
N */
N#define _SPI_SET_TRANSFER_MSB_FIRST(port) ((port)->CNTRL &= (~SPI_CNTRL_LSB_FIRST))
N
N/**
N * @details    Enable byte reorder function
N */
N#define _SPI_ENABLE_REORDER_FUNCTION(port) ((port)->CNTRL |= SPI_CNTRL_REORDER_Msk)
N
N/**
N * @details    Disable byte reorder function
N */
N#define _SPI_DISABLE_REORDER_FUNCTION(port) ((port)->CNTRL &= (~SPI_CNTRL_REORDER_Msk))
N
N/**
N * @details    Configure the suspend interval of the user-specified SPI port. The x setting can be 0-0xF.
N */
N#define _SPI_SET_SUSPEND_CYCLE(port, x) ((port)->CNTRL = ((port)->CNTRL & (~SPI_CNTRL_SP_CYCLE_Msk)) | SPI_CNTRL_SP_CYCLE(x))
N
N/**
N * @details    Configure the user-specified SPI port as a low-level-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_LOW_LEVEL_ACTIVE(port) ((port)->SSR = (port)->SSR & (~(SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk)) | SPI_SSR_SS_LTRIG_Msk)
N
N/**
N * @details    Configure the user-specified SPI port as a high-level-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_HIGH_LEVEL_ACTIVE(port) ((port)->SSR |= (SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk))
N
N/**
N * @details    Configure the user-specified SPI port as a falling-edge-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_FALLING_EDGE_ACTIVE(port) ((port)->SSR &= (~(SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk)))
N
N/**
N * @details    Configure the user-specified SPI port as a rising-edge-active device when it is in slave mode
N */
N#define _SPI_SET_SLAVE_SELECT_RISING_EDGE_ACTIVE(port) ((port)->SSR = (port)->SSR & (~(SPI_SSR_SS_LTRIG_Msk|SPI_SSR_SS_LVL_Msk)) | SPI_SSR_SS_LVL_Msk)
N
N/**
N * @details    Get the level trigger Accomplish flag of the user-specified SPI port
N */
N#define _SPI_GET_SLAVE_LEVEL_TRIG_SUCCESS_FLAG(port) (((port)->SSR & SPI_SSR_LTRIG_FLAG_Msk)>>SPI_SSR_LTRIG_FLAG_Pos)
N
N/**
N * @details    Set the slave select control bits
N */
N#define _SPI_SET_SLAVE_SELECT_CNTRL_BIT(port, x) ((port)->SSR = (port)->SSR & (~SPI_SSR_SSR_Msk) | (x))
N
N/**
N * @details    Get the SPI busy status of the user-specified SPI port
N */
N#define _SPI_GET_BUSY_STATUS(port) ((port)->CNTRL & SPI_CNTRL_GO_BUSY_Msk)
N
N/**
N * @details    Set the SPI GO_BUSY bit of the user-specified SPI port
N */
N#define _SPI_SET_GO(port) ((port)->CNTRL |= SPI_CNTRL_GO_BUSY_Msk)
N
N/**
N * @details    Clear the SPI GO_BUSY bit of the user-specified SPI port
N */
N#define _SPI_CLR_GO(port) ((port)->CNTRL &= (~SPI_CNTRL_GO_BUSY_Msk))
N
N/**
N * @details    Set the SPI DIVIDER of the user-specified SPI port
N */
N#define _SPI_SET_ENGINE_CLK_DIVIDER(port, x) ((port)->DIVIDER = (port)->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk) | (x))
N
N/**
N * @details    Set the SPI DIVIDER2 of the user-specified SPI port
N */
N#define _SPI_SET_DIVIDER2(port, x) ((port)->DIVIDER = (port)->DIVIDER & (~SPI_DIVIDER_DIVIDER2_Msk) | ((x)<<SPI_DIVIDER_DIVIDER2_Pos))
N
N/**
N * @details    Enable the SPI variable clock function of the user-specified SPI port
N */
N#define _SPI_ENABLE_VARIABLE_CLOCK_FUNCTION(port) ((port)->CNTRL |= SPI_CNTRL_VARCLK_EN_Msk)
N
N/**
N * @details    Disable the SPI variable clock function of the user-specified SPI port
N */
N#define _SPI_DISABLE_VARIABLE_CLOCK_FUNCTION(port) ((port)->CNTRL &= (~SPI_CNTRL_VARCLK_EN_Msk))
N
N/**
N * @details    Enable the SPI unit transfer interrupt
N */
N#define _SPI_ENABLE_UNIT_TRANSFER_INT(port) ((port)->CNTRL |= SPI_CNTRL_IE_Msk)
N
N/**
N * @details    Disable the SPI unit transfer interrupt
N */
N#define _SPI_DISABLE_UNIT_TRANSFER_INT(port) ((port)->CNTRL &= (~SPI_CNTRL_IE_Msk))
N
N/**
N * @details    Clear the SPI unit transfer interrupt flag
N */
N#define _SPI_CLR_UNIT_TRANS_INT_FLAG(port) ((port)->STATUS |= SPI_STATUS_IF_Msk )
N
N/**
N * @details    Get the SPI unit transfer interrupt flag
N */
N#define _SPI_GET_UNIT_TRANS_INT_FLAG(port) (((port)->STATUS & SPI_STATUS_IF_Msk)>>SPI_STATUS_IF_Pos )
N
N/**
N * @details    Get the SPI Rx0 data
N */
N#define _SPI_GET_RX0_DATA(port) ((port)->RX[0])
N
N/**
N * @details    Get the SPI Rx1 data
N */
N#define _SPI_GET_RX1_DATA(port) ((port)->RX[1])
N
N/**
N * @details    Write data to the SPI Tx buffer0
N */
N#define _SPI_WRITE_TX_BUFFER0(port, x) ((port)->TX[0] = (x))
N
N/**
N * @details    Write data to the SPI Tx buffer1
N */
N#define _SPI_WRITE_TX_BUFFER1(port, x) ((port)->TX[1] = (x))
N
N/**
N * @details    Enable the SPI 3-wire mode
N */
N#define _SPI_ENABLE_3WIRE_MODE(port) ((port)->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N * @details    Disable the 3-wire mode
N */
N#define _SPI_DISABLE_3WIRE_MODE(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_NOSLVSEL_Msk))
N
N/**
N * @details    Abort the SPI transfer when the 3-wire mode is enabled
N */
N#define _SPI_ABORT_3WIRE_TRANSFER(port) ((port)->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk)
N
N/**
N * @details    Enable the SPI 3-wire mode start interrupt
N */
N#define _SPI_ENABLE_3WIRE_START_INT(port) ((port)->CNTRL2 |= SPI_CNTRL2_SSTA_INTEN_Msk)
N
N/**
N * @details    Disable the SPI 3-wire mode start interrupt
N */
N#define _SPI_DISABLE_3WIRE_START_INT(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_SSTA_INTEN_Msk))
N
N/**
N * @details    Get the SPI 3-wire mode start interrupt flag
N */
N#define _SPI_GET_3WIRE_START_INT_FLAG(port) (((port)->CNTRL2 & SPI_CNTRL2_SLV_START_INTSTS_Msk)>>SPI_CNTRL2_SLV_START_INTSTS_Pos)
N
N/**
N * @details    Clear the SPI 3-wire mode start interrupt flag
N */
N#define _SPI_CLR_3WIRE_START_INT_FLAG(port) ((port)->CNTRL2 |= SPI_CNTRL2_SLV_START_INTSTS_Msk)
N
N/**
N * @details    Enable the SPI 2-bit transfer mode
N */
N#define _SPI_ENABLE_2BIT_MODE(port) ((port)->CNTRL |= SPI_CNTRL_TWOB_Msk)
N
N/**
N * @details    Disable the SPI 2-bit transfer mode
N */
N#define _SPI_DISABLE_2BIT_MODE(port) ((port)->CNTRL &= (~SPI_CNTRL_TWOB_Msk))
N
N/**
N * @details    Enable the SPI FIFO mode
N */
N#define _SPI_ENABLE_FIFO_MODE(port) ((port)->CNTRL |= SPI_CNTRL_FIFO_Msk)
N
N/**
N * @details    Disable the SPI FIFO mode
N */
N#define _SPI_DISABLE_FIFO_MODE(port) ((port)->CNTRL &= (~SPI_CNTRL_FIFO_Msk))
N
N/**
N * @details    Configure the transmit FIFO threshold of the user-specified SPI port. The x setting can be 0-7.
N */
N#define _SPI_SET_TX_THRESHOLD(port, x) ((port)->FIFO_CTL = ((port)->FIFO_CTL & (~SPI_FIFO_CTL_TX_THRESHOLD_Msk)) | (x)<<SPI_FIFO_CTL_TX_THRESHOLD_Pos)
N
N/**
N * @details    Configure the receive FIFO threshold of the user-specified SPI port. The x setting can be 0-7.
N */
N#define _SPI_SET_RX_THRESHOLD(port, x) ((port)->FIFO_CTL = ((port)->FIFO_CTL & (~SPI_FIFO_CTL_RX_THRESHOLD_Msk)) | (x)<<SPI_FIFO_CTL_RX_THRESHOLD_Pos)
N
N/**
N * @details    Enable the SPI receive FIFO time-out interrupt
N */
N#define _SPI_ENABLE_TIMEOUT_INT(port) ((port)->FIFO_CTL |= SPI_FIFO_CTL_TIMEOUT_INTEN_Msk)
N
N/**
N * @details    Disable the SPI receive FIFO time-out interrupt
N */
N#define _SPI_DISABLE_TIMEOUT_INT(port) ((port)->FIFO_CTL &= (~SPI_FIFO_CTL_TIMEOUT_INTEN_Msk))
N
N/**
N * @details    Enable the SPI receive FIFO overrun interrupt
N */
N#define _SPI_ENABLE_RX_OVERRUN_INT(port) ((port)->FIFO_CTL |= SPI_FIFO_CTL_RXOV_INTEN_Msk)
N
N/**
N * @details    Disable the SPI receive FIFO overrun interrupt
N */
N#define _SPI_DISABLE_RX_OVERRUN_INT(port) ((port)->FIFO_CTL &= (~SPI_FIFO_CTL_RXOV_INTEN_Msk))
N
N/**
N * @details    Enable the SPI transmit FIFO threshold interrupt
N */
N#define _SPI_ENABLE_TX_THRESHOLD_INT(port) ((port)->FIFO_CTL |= SPI_FIFO_CTL_TX_INTEN_Msk)
N
N/**
N * @details    Disable the SPI transmit FIFO threshold interrupt
N */
N#define _SPI_DISABLE_TX_THRESHOLD_INT(port) ((port)->FIFO_CTL &= (~SPI_FIFO_CTL_TX_INTEN_Msk))
N
N/**
N * @details    Enable the SPI receive FIFO threshold interrupt
N */
N#define _SPI_ENABLE_RX_THRESHOLD_INT(port) ((port)->FIFO_CTL |= SPI_FIFO_CTL_RX_INTEN_Msk)
N
N/**
N * @details    Disable the SPI receive FIFO threshold interrupt
N */
N#define _SPI_DISABLE_RX_THRESHOLD_INT(port) ((port)->FIFO_CTL &= (~SPI_FIFO_CTL_RX_INTEN_Msk))
N
N/**
N * @details    Clear the SPI transmit FIFO buffer
N */
N#define _SPI_CLR_TX_FIFO(port) ((port)->FIFO_CTL |= SPI_FIFO_CTL_TX_CLR_Msk)
N
N/**
N * @details    Clear the SPI receive FIFO buffer
N */
N#define _SPI_CLR_RX_FIFO(port) ((port)->FIFO_CTL |= SPI_FIFO_CTL_RX_CLR_Msk)
N
N/**
N * @details    Enable SPI RX PDMA transfer
N */
N#define _SPI_ENABLE_RX_PDMA(port) ((port)->DMA |= SPI_DMA_RX_DMA_GO_Msk)
N
N/**
N * @details    Enable SPI TX PDMA transfer
N */
N#define _SPI_ENABLE_TX_PDMA(port) ((port)->DMA |= SPI_DMA_TX_DMA_GO_Msk)
N
N/**
N * @details    Clear BCn bit to 0 for clock configuration backward compatible.
N */
N#define _SPI_SET_CLOCK_SETTING_BACKWARD_COMPATIBLE(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk))
N
N/**
N * @details    Set BCn bit to 1 for more flexible clock configuration.
N */
N#define _SPI_SET_CLOCK_SETTING_NOT_BACKWARD_COMPATIBLE(port) ((port)->CNTRL2 |= SPI_CNTRL2_BCn_Msk)
N
N/**
N * @details    Enable the SPI dual I/O input mode 
N */
N#define _SPI_ENABLE_DUAL_IO_INPUT_MODE(port) ((port)->CNTRL2 = (port)->CNTRL2 & (~(SPI_CNTRL2_DUAL_IO_EN_Msk|SPI_CNTRL2_DUAL_IO_DIR_Msk)) | SPI_CNTRL2_DUAL_IO_EN_Msk)
N
N/**
N * @details    Enable the SPI dual I/O output mode 
N */
N#define _SPI_ENABLE_DUAL_IO_OUTPUT_MODE(port) ((port)->CNTRL2 |= (SPI_CNTRL2_DUAL_IO_EN_Msk|SPI_CNTRL2_DUAL_IO_DIR_Msk) )
N
N/**
N * @details    Disable the SPI dual I/O mode 
N */
N#define _SPI_DISABLE_DUAL_IO_MODE(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_DUAL_IO_EN_Msk))
N
N/**
N * @details    Enable the SPI slave select inactive interrupt
N */
N#define _SPI_ENABLE_SS_INACTIVE_INT(port) ((port)->CNTRL2 |= SPI_CNTRL2_SS_INT_OPT_Msk)
N
N/**
N * @details    Disable the SPI slave select inactive interrupt
N */
N#define _SPI_DISABLE_SS_INACTIVE_INT(port) ((port)->CNTRL2 &= (~SPI_CNTRL2_SS_INT_OPT_Msk))
N
N/**
N * @details    Get the Tx FIFO count
N */
N#define _SPI_GET_TX_FIFO_COUNT(port) (((port)->STATUS & SPI_STATUS_TX_FIFO_COUNT_Msk)>>SPI_STATUS_TX_FIFO_COUNT_Pos)
N
N/**
N * @details    Get the Tx FIFO full flag
N */
N#define _SPI_GET_TX_FIFO_FULL_FLAG(port) (((port)->STATUS & SPI_STATUS_TX_FULL_Msk)>>SPI_STATUS_TX_FULL_Pos)
N
N/**
N * @details    Get the Tx FIFO empty flag
N */
N#define _SPI_GET_TX_FIFO_EMPTY_FLAG(port) (((port)->STATUS & SPI_STATUS_TX_EMPTY_Msk)>>SPI_STATUS_TX_EMPTY_Pos)
N
N/**
N * @details    Get the Rx FIFO full flag
N */
N#define _SPI_GET_RX_FIFO_FULL_FLAG(port) (((port)->STATUS & SPI_STATUS_RX_FULL_Msk)>>SPI_STATUS_RX_FULL_Pos)
N
N/**
N * @details    Get the Rx FIFO empty flag
N */
N#define _SPI_GET_RX_FIFO_EMPTY_FLAG(port) (((port)->STATUS & SPI_STATUS_RX_EMPTY_Msk)>>SPI_STATUS_RX_EMPTY_Pos)
N
N/**
N * @details    Get the Rx FIFO time-out flag
N */
N#define _SPI_GET_RX_FIFO_TIMEOUT_FLAG(port) (((port)->STATUS & SPI_STATUS_TIMEOUT_Msk)>>SPI_STATUS_TIMEOUT_Pos)
N
N/**
N * @details    Get the Rx FIFO count
N */
N#define _SPI_GET_RX_FIFO_COUNT(port) (((port)->STATUS & SPI_STATUS_RX_FIFO_COUNT_Msk)>>SPI_STATUS_RX_FIFO_COUNT_Pos)
N
N/**
N * @details    Get the Tx FIFO threshold interrupt flag
N */
N#define _SPI_GET_TX_FIFO_THRESHOLD_INT_FLAG(port) (((port)->STATUS & SPI_STATUS_TX_INTSTS_Msk)>>SPI_STATUS_TX_INTSTS_Pos)
N
N/**
N * @details    Get the Rx FIFO overrun flag
N */
N#define _SPI_GET_RX_FIFO_OVERRUN_FLAG(port) (((port)->STATUS & SPI_STATUS_RX_OVERRUN_Msk)>>SPI_STATUS_RX_OVERRUN_Pos)
N
N/**
N * @details    Get the Rx FIFO threshold interrupt flag
N */
N#define _SPI_GET_RX_FIFO_THRESHOLD_INT_FLAG(port) (((port)->STATUS & SPI_STATUS_RX_INTSTS_Msk)>>SPI_STATUS_RX_INTSTS_Pos)
N
N
N/**
N * @brief      Get SPI0 clock1 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI0 clock1 frequency.
N *
N * @details    This function calculates the clock rate of SPI0 clock1 (SPI engine clock).
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi0Clock1Freq()
Xstatic __inline uint32_t SPI_GetSpi0Clock1Freq()
N{
N    if(SPI0->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI0_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 4))
N            return (SystemCoreClock/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            return (PllClock/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return (PllClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI0_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 4))
N            return ((SystemCoreClock>>1)/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            return ((PllClock>>1)/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N}
N
N/**
N * @brief      Get SPI1 clock1 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI1 clock1 frequency.
N *
N * @details    This function calculates the clock rate of SPI1 clock1 (SPI engine clock).
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi1Clock1Freq()
Xstatic __inline uint32_t SPI_GetSpi1Clock1Freq()
N{
N    if(SPI1->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI1_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 5))
N            return (SystemCoreClock/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            return (PllClock/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return (PllClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI1_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 5))
N            return ((SystemCoreClock>>1)/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            return ((PllClock>>1)/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N}
N
N/**
N * @brief      Get SPI2 clock1 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI2 clock1 frequency.
N *
N * @details    This function calculates the clock rate of SPI2 clock1 (SPI engine clock).
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi2Clock1Freq()
Xstatic __inline uint32_t SPI_GetSpi2Clock1Freq()
N{
N    if(SPI2->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI2_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 6))
N            return (SystemCoreClock/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            return (PllClock/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return (PllClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI2_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 6))
N            return ((SystemCoreClock>>1)/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            return ((PllClock>>1)/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N}
N
N/**
N * @brief      Get SPI3 clock1 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI3 clock1 frequency.
N *
N * @details    This function calculates the clock rate of SPI3 clock1 (SPI engine clock).
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi3Clock1Freq()
Xstatic __inline uint32_t SPI_GetSpi3Clock1Freq()
N{
N    if(SPI3->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI3_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 7))
N            return (SystemCoreClock/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            return (PllClock/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return (PllClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI3_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 7))
N            return ((SystemCoreClock>>1)/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            return ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            return ((PllClock>>1)/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            return ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N}
N
N/**
N * @brief      Get SPI0 clock2 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI0 clock2 frequency.
N *
N * @details    This function calculates the clock rate of SPI0 clock2.
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi0Clock2Freq()
Xstatic __inline uint32_t SPI_GetSpi0Clock2Freq()
N{
N    uint32_t u32EngineClockRate;
N    
N    if(SPI0->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI0_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 4))
N            u32EngineClockRate = (SystemCoreClock/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = (PllClock/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = (PllClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI0_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 4))
N            u32EngineClockRate = ((SystemCoreClock>>1)/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = ((PllClock>>1)/((SPI0->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N    return (u32EngineClockRate>>1)/(((SPI0->DIVIDER & 0x00FF0000)>>16)+1);
X    return (u32EngineClockRate>>1)/(((((SPI_T *) ((( uint32_t)0x40000000) + 0x30000))->DIVIDER & 0x00FF0000)>>16)+1);
N}
N
N/**
N * @brief      Get SPI1 clock2 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI1 clock2 frequency.
N *
N * @details    This function calculates the clock rate of SPI1 clock2.
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi1Clock2Freq()
Xstatic __inline uint32_t SPI_GetSpi1Clock2Freq()
N{
N    uint32_t u32EngineClockRate;
N    
N    if(SPI1->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI1_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 5))
N            u32EngineClockRate = (SystemCoreClock/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = (PllClock/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = (PllClock/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI1_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 5))
N            u32EngineClockRate = ((SystemCoreClock>>1)/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = ((PllClock>>1)/((SPI1->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N    return (u32EngineClockRate>>1)/(((SPI1->DIVIDER & 0x00FF0000)>>16)+1);
X    return (u32EngineClockRate>>1)/(((((SPI_T *) ((( uint32_t)0x40000000) + 0x34000))->DIVIDER & 0x00FF0000)>>16)+1);
N}
N
N/**
N * @brief      Get SPI2 clock2 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI2 clock2 frequency.
N *
N * @details    This function calculates the clock rate of SPI2 clock2.
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi2Clock2Freq()
Xstatic __inline uint32_t SPI_GetSpi2Clock2Freq()
N{
N    uint32_t u32EngineClockRate;
N    
N    if(SPI2->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI2_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 6))
N            u32EngineClockRate = (SystemCoreClock/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = (PllClock/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = (PllClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI2_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 6))
N            u32EngineClockRate = ((SystemCoreClock>>1)/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = ((PllClock>>1)/((SPI2->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0xFF)+1));  
N    }
N    return (u32EngineClockRate>>1)/(((SPI2->DIVIDER & 0x00FF0000)>>16)+1);
X    return (u32EngineClockRate>>1)/(((((SPI_T *) ((( uint32_t)0x40100000) + 0x30000))->DIVIDER & 0x00FF0000)>>16)+1);
N}
N
N/**
N * @brief      Get SPI3 clock2 frequency (Hz).
N *
N * @param      None
N *
N * @return     SPI3 clock2 frequency.
N *
N * @details    This function calculates the clock rate of SPI3 clock2.
N *
N */
Nstatic __INLINE uint32_t SPI_GetSpi3Clock2Freq()
Xstatic __inline uint32_t SPI_GetSpi3Clock2Freq()
N{
N    uint32_t u32EngineClockRate;
N    
N    if(SPI3->CNTRL2 & SPI_CNTRL2_BCn_Msk)
X    if(((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->CNTRL2 & (1ul << 31))
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI3_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 7))
N            u32EngineClockRate = (SystemCoreClock/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = (SystemCoreClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = (PllClock/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = (PllClock/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N    else
N    {
N        /* Check the SPI engine clock source */
N        if(SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_SPI3_S_Msk)
X        if(((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (1ul << 7))
N            u32EngineClockRate = ((SystemCoreClock>>1)/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: system clock */
X            u32EngineClockRate = ((SystemCoreClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N        else
N            u32EngineClockRate = ((PllClock>>1)/((SPI3->DIVIDER & 0xFF)+1)); /* SPI engine clock source: PLL */
X            u32EngineClockRate = ((PllClock>>1)/((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0xFF)+1));  
N    }
N    return (u32EngineClockRate>>1)/(((SPI3->DIVIDER & 0x00FF0000)>>16)+1);
X    return (u32EngineClockRate>>1)/(((((SPI_T *) ((( uint32_t)0x40100000) + 0x34000))->DIVIDER & 0x00FF0000)>>16)+1);
N}
N
N
N
N/**
N  * @} End of SPI Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif
N
L 6302 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "TIMER.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\TIMER.h" 1
N/**************************************************************************//**
N * @file     TIMER.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series Timer Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#include "NUC200Series.h"
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup TIMER_FUNC TIMER Device Function Interface
N  * @{
N  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TCSR Constants Definitions                                                                              */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define TIMER_TCSR_CEN_ENABLE           0x40000000UL /*!< Enable Timer to start counting         */
N#define TIMER_TCSR_CEN_DISABLE          0x00000000UL /*!< Disable Timer to stop/suspend counting */
N#define TIMER_TCSR_IE_ENABLE            0x20000000UL /*!< Enable Timer Interrupt function  */
N#define TIMER_TCSR_IE_DISABLE           0x00000000UL /*!< Disable Timer Interrupt function */
N#define TIMER_TCSR_MODE_ONESHOT         0x00010000UL /*!< Specify Timer One-Shot mode and enable TDR            */
N#define TIMER_TCSR_MODE_PERIODIC        0x08010000UL /*!< Specify Timer Periodic mode and enable TDR            */
N#define TIMER_TCSR_MODE_TOGGLE          0x10010000UL /*!< Specify Timer Toggle mode and enable TDR              */
N#define TIMER_TCSR_MODE_CONTINUOUS      0x18010000UL /*!< Specify Timer Continuous Counting mode and enable TDR */
N#define TIMER_TCSR_CRST                 0x04000000UL /*!< Reset Timer          */
N#define TIMER_TCSR_CTB_ENABLE           0x01000000UL /*!< Enable Counter Mode  */
N#define TIMER_TCSR_CTB_DISABLE          0x00000000UL /*!< Disable Counter Mode */
N#define TIMER_TCSR_WAKE_EN_ENABLE       0x00800000UL /*!< Enable Timer Wake up function  */
N#define TIMER_TCSR_WAKE_EN_DISABLE      0x00000000UL /*!< Disable Timer Wake up function */
N#define TIMER_TCSR_TDR_EN_ENABLE        0x00010000UL /*!< Enable Timer Data Load function  */
N#define TIMER_TCSR_TDR_EN_DISABLE       0x00000000UL /*!< Disable Timer Data Load function */
N#define TIMER_TCSR_PRESCALE(x)          ((x)-1)      /*!< TCSR setting for prescale. 1 <= x <= 256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TEXCON Constants Definitions                                                                            */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define TIMER_TEXCON_TCDB_ENABLE        0x80UL /*!< Enable Timer Counter pin de-bounce  */
N#define TIMER_TEXCON_TCDB_DISABLE       0x00UL /*!< Disable Timer Counter pin de-bounce */
N#define TIMER_TEXCON_TEXDB_ENABLE       0x40UL /*!< Enable Timer Capture pin de-bounce  */
N#define TIMER_TEXCON_TEXDB_DISABLE      0x00UL /*!< Disable Timer Capture pin de-bounce */
N#define TIMER_TEXCON_TEXIEN_ENABLE      0x20UL /*!< Enable Timer Capture pin interrupt  */
N#define TIMER_TEXCON_TEXIEN_DISABLE     0x00UL /*!< Disable Timer Capture pin interrupt */
N#define TIMER_TEXCON_MODE_RESET_COUNT   0x10UL /*!< Transition on Timer Capture pin is using to reset the timer counter    */
N#define TIMER_TEXCON_MODE_CAP           0x00UL /*!< Transition on Timer Capture pin is using as the Timer Capture function */
N#define TIMER_TEXCON_TEXEN_ENABLE       0x08UL /*!< Enable Timer Capture pin function   */
N#define TIMER_TEXCON_TEXEN_DISABLE      0x00UL /*!< Disable Timer Capture pin function  */
N#define TIMER_TEXCON_TEX_EDGE_BOTH      0x04UL /*!< Capture pin will generate a detected signal both on 0 to 1 and 1 to 0 transition. */
N#define TIMER_TEXCON_TEX_EDGE_RISING    0x02UL /*!< Capture pin will generate a detected signal only on 0 to 1 transition.            */
N#define TIMER_TEXCON_TEX_EDGE_FALLING   0x00UL /*!< Capture pin will generate a detected signal only on 1 to 0 transition.            */
N#define TIMER_TEXCON_TX_PHASE_RISING    0x01UL /*!< Counter pin will generate a count when transition from 0 to 1 on Counter pin */
N#define TIMER_TEXCON_TX_PHASE_FALLING   0x00UL /*!< Counter pin will generate a count when transition from 1 to 0 on Counter pin */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TIMER Macro Definitions                                                                                 */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Predefined timer TCSR setting for enable periodic timer but disable interrupt. 1 <= x <= 256
N */
N#define TIMER_TCSR_INIT(x)              (TIMER_TCSR_MODE_PERIODIC | TIMER_TCSR_CEN_Msk | TIMER_TCSR_PRESCALE(x))
N
N
N/**
N * @details     Predefined timer TCSR setting for enable periodic timer and enable interrupt. 1 <= x <= 256
N */
N#define TIMER_TCSR_INIT_IE(x)           (TIMER_TCSR_MODE_PERIODIC | TIMER_TCSR_CEN_Msk | TIMER_TCSR_IE_Msk | TIMER_TCSR_PRESCALE(x))
N
N
N/**
N * @brief       Start Timer Counting
N *
N * @param[in]   TIMER       TIMER port. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N * @param[in]   tcsr        TCSR register settings of specified TIMER port.
N * @param[in]   presacle    Timer clock input will be divided by presacle.
N *
N * @return      None
N *
N * @details     To start Timer counting by TCSR settings.
N */
N#define _TIMER_START(TIMER, tcsr, presacle)     ((TIMER)->TCSR = ((tcsr) | TIMER_TCSR_PRESCALE(presacle) | TIMER_TCSR_CEN_ENABLE))    
N
N
N/**
N * @brief       Enable Timer Capture Function
N *
N * @param[in]   TIMER       TIMER port. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N * @param[in]   texcon      TEXCON register settings of specified TIMER port.
N *
N * @return      None
N *
N * @details     To enable Timer capture function to get current TDR or reset Timer counter when transition on external capture pin.
N */
N#define _TIMER_ENABLE_CAPTURE(TIMER, texcon)     ((TIMER)->TEXCON = ((texcon) | TIMER_TEXCON_TEXEN_ENABLE))    
N
N
N/**
N * @details     To reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_RESET(TIMER)                     ((TIMER)->TCSR = TIMER_TCSR_CRST)    
N
N
N/**
N * @details     Set Timer Compared Value for specified Timer channel. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_SET_CMP_VALUE(TIMER, value)      ((TIMER)->TCMPR = value)    
N
N
N/**
N * @details     Get Timer Compare Match Interrupt Flag. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_CMP_INT_FLAG(TIMER)          (((((TIMER)->TISR) & TIMER_TISR_TIF_Msk) == TIMER_TISR_TIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear Timer Compare Match Interrupt Flag to 0. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_CLEAR_CMP_INT_FLAG(TIMER)        ((TIMER)->TISR = TIMER_TISR_TIF_Msk)
N                                               
N
N/**
N * @details     Get Timer Wakeup Interrupt Flag. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_WAKEUP_INT_FLAG(TIMER)       (((((TIMER)->TISR) & TIMER_TISR_TWF_Msk) == TIMER_TISR_TWF_Msk)? 1:0)
N
N
N/**
N * @details     Clear Timer Wakeup Interrupt Flag to 0. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_CLEAR_WAKEUP_INT_FLAG(TIMER)     ((TIMER)->TISR = TIMER_TISR_TWF_Msk)
N                                               
N
N/**
N * @details     Get Timer TDR value. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_TDR(TIMER)                   ((TIMER)->TDR)
N
N
N/**
N * @details     Get Timer Capture Data value. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_TCAP(TIMER)                   ((TIMER)->TCAP)
N
N
N/**
N * @details     Get Interrupt Flag for Capture pin. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_GET_CAP_INT_FLAG(TIMER)          (((((TIMER)->TEXISR) & TIMER_TEXISR_TEXIF_Msk) == TIMER_TEXISR_TEXIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear Interrupt Flag to 0 for Capture pin. TIMER = TIMER0, TIMER1, TIMER2 or TIMER3
N */
N#define _TIMER_CLEAR_CAP_INT_FLAG(TIMER)        ((TIMER)->TEXISR = TIMER_TEXISR_TEXIF_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief       Get Timer Clock Source Frequency
N *
N * @param[in]   eTimerCH    E_TMR0 / E_TMR1 / E_TMR2 / E_TMR3
N *
N * @return      Timer clock frequency (Hz)
N *
N * @details     Get the specified Timer clock source frequency.
N */
Nstatic __INLINE uint32_t TIMER_GetClockFreq(uint32_t eTimerCH)
Xstatic __inline uint32_t TIMER_GetClockFreq(uint32_t eTimerCH)
N{
N    uint8_t u8TMRClkSrcSel;
N    uint32_t u32ClkSrcTbl[] = {__XTAL, __RTC_XTAL, 0, 0, 0, __IRC10K, 0, __IRC22M};
X    uint32_t u32ClkSrcTbl[] = {(12000000UL), (32768UL), 0, 0, 0, (10000UL), 0, (22118400UL)};
N        
N    u32ClkSrcTbl[2] = SystemCoreClock;
N
N    u8TMRClkSrcSel = (SYSCLK->CLKSEL1 >> (8+(eTimerCH*4))) & 0x7;
X    u8TMRClkSrcSel = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 >> (8+(eTimerCH*4))) & 0x7;
N
N    return u32ClkSrcTbl[u8TMRClkSrcSel]; 
N}
N
N
N/**
N * @brief       Calculate Timer Initial Value
N *
N * @param[in]   u32ClockValue   Input the Timer clock frequency (Hz)
N * @param[in]   u32TicksPerSec  Specify the ticks per second
N *
N * @return      Return 32 bits unsigned integer where \n
N *                  bits [ 0:23] - TCMP of Timer Compare Register, the range is 0 ~ 0xFFFFFF. \n
N *                  bits [24:31] - PRESCALE of Timer Control Register, the range is 0 ~ 0xFF.
N *
N * @details     Calculate the Timer Compare Value and pre-scale counter of Timer. \n
N *              The target Timer clock input is divided by (PRESCALE + 1).
N */
Nstatic __INLINE uint32_t TIMER_CalInitValue(uint32_t u32ClockFreq, uint32_t u32TicksPerSec)
Xstatic __inline uint32_t TIMER_CalInitValue(uint32_t u32ClockFreq, uint32_t u32TicksPerSec)
N{
N    uint32_t u32Prescale;
N    uint32_t u32FinalTCMPR;
N
N    for (u32Prescale=1; u32Prescale<256; u32Prescale++)
N    {
N        u32FinalTCMPR = u32ClockFreq / (u32TicksPerSec*u32Prescale);
N
N        /* The TCMPR value must > 1 */
N        if ((u32FinalTCMPR > 1) && (u32FinalTCMPR < 0x1000000))
N            return (((u32Prescale-1) << 24) | u32FinalTCMPR);
N    }
N    
N    return (uint32_t)-1;
N}
N
N
N/**
N  * @} End of TIMER Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif  // __TIMER_H__ 
L 6303 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "WDT.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\WDT.h" 1
N/**************************************************************************//**
N * @file     WDT.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series Watchdog Timer and Window Watchdog Timer Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#include "NUC200Series.h"
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup WDT_FUNC WDT Device Function Interface
N  * @{
N  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCR Constants Definitions                                                                              */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_WTCR_COMMON(x)          (WDT_WTCR_WTE_Msk | WDT_WTCR_WTIF_Msk | WDT_WTCR_WTR_Msk | ((x) << WDT_WTCR_WTIS_Pos))
N
N#define WDT_WTCR_WAKEUP_INT_2POW4   (WDT_WTCR_COMMON(0) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^04 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW6   (WDT_WTCR_COMMON(1) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^06 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW8   (WDT_WTCR_COMMON(2) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^08 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW10  (WDT_WTCR_COMMON(3) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^10 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW12  (WDT_WTCR_COMMON(4) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^12 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW14  (WDT_WTCR_COMMON(5) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^14 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW16  (WDT_WTCR_COMMON(6) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^16 * WDT clock */
N#define WDT_WTCR_WAKEUP_INT_2POW18  (WDT_WTCR_COMMON(7) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTWKE_Msk) /*!< WTCR setting for wakeup, interrupt enable and interval = 2^18 * WDT clock */
N
N#define WDT_WTCR_INT_2POW4          (WDT_WTCR_COMMON(0) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^04 * WDT clock */
N#define WDT_WTCR_INT_2POW6          (WDT_WTCR_COMMON(1) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^06 * WDT clock */
N#define WDT_WTCR_INT_2POW8          (WDT_WTCR_COMMON(2) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^08 * WDT clock */
N#define WDT_WTCR_INT_2POW10         (WDT_WTCR_COMMON(3) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^10 * WDT clock */
N#define WDT_WTCR_INT_2POW12         (WDT_WTCR_COMMON(4) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^12 * WDT clock */
N#define WDT_WTCR_INT_2POW14         (WDT_WTCR_COMMON(5) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^14 * WDT clock */
N#define WDT_WTCR_INT_2POW16         (WDT_WTCR_COMMON(6) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^16 * WDT clock */
N#define WDT_WTCR_INT_2POW18         (WDT_WTCR_COMMON(7) | WDT_WTCR_WTIE_Msk) /*!< WTCR setting for interrupt enable and interval = 2^18 * WDT clock */
N
N#define WDT_WTCR_INT_RESET_2POW4    (WDT_WTCR_COMMON(0) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^04 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW6    (WDT_WTCR_COMMON(1) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^06 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW8    (WDT_WTCR_COMMON(2) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^08 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW10   (WDT_WTCR_COMMON(3) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^10 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW12   (WDT_WTCR_COMMON(4) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^12 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW14   (WDT_WTCR_COMMON(5) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^14 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW16   (WDT_WTCR_COMMON(6) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^16 * WDT clock */
N#define WDT_WTCR_INT_RESET_2POW18   (WDT_WTCR_COMMON(7) | WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRE_Msk) /*!< WTCR setting for interrupt, reset enable and interval = 2^18 * WDT clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCRALT Constants Definitions                                                                           */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_WTCRALT_WTRDSEL_1024    0x00000000UL /*!< WTCRALT setting for select Watchdog reset delay period is (1024 + 2) * WDT clock */
N#define WDT_WTCRALT_WTRDSEL_128     0x00000001UL /*!< WTCRALT setting for select Watchdog reset delay period is (128 + 2) * WDT clock */
N#define WDT_WTCRALT_WTRDSEL_16      0x00000002UL /*!< WTCRALT setting for select Watchdog reset delay period is (16 + 2) * WDT clock */
N#define WDT_WTCRALT_WTRDSEL_1       0x00000003UL /*!< WTCRALT setting for select Watchdog reset delay period is (1 + 2) * WDT clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WDT Macro Definitions                                                                                   */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Get WDT Timeout Reset Flag
N */
N#define _WDT_GET_RESET_FLAG()               ((((WDT->WTCR) & WDT_WTCR_WTRE_Msk) == WDT_WTCR_WTRE_Msk)? 1:0)
N
N
N/**
N * @details     Clear WDT Timeout Reset Flag to 0
N */
N#define _WDT_CLEAR_RESET_FLAG()             (WDT->WTCR |= WDT_WTCR_WTRE_Msk)
N
N
N/**
N * @details     Get WDT Timeout Interrupt Flag
N */
N#define _WDT_GET_TIMEOUT_INT_FLAG()         ((((WDT->WTCR) & WDT_WTCR_WTIF_Msk) == WDT_WTCR_WTIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear WDT Timeout Interrupt Flag to 0
N */
N#define _WDT_CLEAR_TIMEOUT_INT_FLAG()       (WDT->WTCR |= WDT_WTCR_WTIF_Msk)
N
N
N/**
N * @details     Get WDT Timeout Wake-up Flag
N */
N#define _WDT_GET_TIMEOUT_WAKEUP_FLAG()      ((((WDT->WTCR) & WDT_WTCR_WTWKF_Msk) == WDT_WTCR_WTWKF_Msk)? 1:0)
N
N
N/**
N * @details     Clear WDT Timeout Wake-up Flag to 0
N */
N#define _WDT_CLEAR_TIMEOUT_WAKEUP_FLAG()    (WDT->WTCR |= WDT_WTCR_WTWKF_Msk)
N
N
N/**
N * @details     Enable WDT to start counting
N */
N#define _WDT_ENABLE_COUNTING()              (WDT->WTCR |= WDT_WTCR_WTE_Msk)
N
N
N/**
N * @details     Disable WDT to stop counting
N */
N#define _WDT_DISABLE_COUNTING()             (WDT->WTCR &= ~WDT_WTCR_WTE_Msk)
N
N
N/**
N * @details     Reset the contents of WDT
N */
N#define _WDT_RESET()                        (WDT->WTCR |= WDT_WTCR_WTR_Msk)
N
N
N/**
N * @details     To select Watchdog reset delay period. x = WDT_WTCRALT_WTRDSEL_1024, WDT_WTCRALT_WTRDSEL_128, WDT_WTCRALT_WTRDSEL_16 or WDT_WTCRALT_WTRDSEL_1
N */
N#define _WDT_SELECT_RESET_DELAY_PERIOD(x)   (WDT->WTCRALT = x)    
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WWDTCR Constants Definitions                                                                            */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_WWDTCR_WINCMP(x)       ((x) << WWDT_WWDTCR_WINCMP_Pos)   /*!< WWDTCR setting for adjust the valid reload window. 0 <= x <= 0x3F */
N
N#define WWDT_WWDTCR_PERIODSEL_1     (0 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 1 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_2     (1 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 2 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_4     (2 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 4 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_8     (3 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 8 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_16    (4 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 16 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_32    (5 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 32 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_64    (6 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 64 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_128   (7 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 128 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_192   (8 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 192 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_256   (9 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 256 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_384   (10 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 384 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_512   (11 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 512 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_768   (12 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 768 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_1024  (13 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 1024 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_1536  (14 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 1536 * (64*WWDT_CLK) */
N#define WWDT_WWDTCR_PERIODSEL_2048  (15 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< WWDTCR setting to select the pre-scale for the WWDT counter period. Max timeout period is 2048 * (64*WWDT_CLK) */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WWDT Macro Definitions                                                                                  */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Enable WWDT to start counting
N *
N * @param[in]   wincmp      The WWDT valid reload window. 0 <= wincmp <= 0x3F.
N * @param[in]   periodsel   The pre-scale for the WWDT counter period. It could be \n
N *                              WWDT_WWDTCR_PERIODSEL_1, WWDT_WWDTCR_PERIODSEL_2, WWDT_WWDTCR_PERIODSEL_4, WWDT_WWDTCR_PERIODSEL_8, \n
N *                              WWDT_WWDTCR_PERIODSEL_16, WWDT_WWDTCR_PERIODSEL_32, WWDT_WWDTCR_PERIODSEL_64, WWDT_WWDTCR_PERIODSEL_128, \n
N *                              WWDT_WWDTCR_PERIODSEL_192, WWDT_WWDTCR_PERIODSEL_256, WWDT_WWDTCR_PERIODSEL_384, WWDT_WWDTCR_PERIODSEL_512, \n
N *                              WWDT_WWDTCR_PERIODSEL_768, WWDT_WWDTCR_PERIODSEL_1024, WWDT_WWDTCR_PERIODSEL_1536, WWDT_WWDTCR_PERIODSEL_2048.
N *
N * @return      None
N *
N * @details     To start WWDT counting and WWDT interrupt function is disabled.
N */
N#define _WWDT_ENABLE(wincmp, periodsel)         (WWDT->WWDTCR = (WWDT_WWDTCR_WINCMP(wincmp) | (periodsel) | WWDT_WWDTCR_WWDTEN_Msk))
N
N
N/**
N * @details     Enable WWDT to start counting with WWDT interrupt enable
N *
N * @param[in]   wincmp      The WWDT valid reload window. 0 <= wincmp <= 0x3F.
N * @param[in]   periodsel   The pre-scale for the WWDT counter period. It could be \n
N *                              WWDT_WWDTCR_PERIODSEL_1, WWDT_WWDTCR_PERIODSEL_2, WWDT_WWDTCR_PERIODSEL_4, WWDT_WWDTCR_PERIODSEL_8, \n
N *                              WWDT_WWDTCR_PERIODSEL_16, WWDT_WWDTCR_PERIODSEL_32, WWDT_WWDTCR_PERIODSEL_64, WWDT_WWDTCR_PERIODSEL_128, \n
N *                              WWDT_WWDTCR_PERIODSEL_192, WWDT_WWDTCR_PERIODSEL_256, WWDT_WWDTCR_PERIODSEL_384, WWDT_WWDTCR_PERIODSEL_512, \n
N *                              WWDT_WWDTCR_PERIODSEL_768, WWDT_WWDTCR_PERIODSEL_1024, WWDT_WWDTCR_PERIODSEL_1536, WWDT_WWDTCR_PERIODSEL_2048.
N *
N * @return      None
N *
N * @details     To start WWDT counting and enable WWDT interrupt function.
N */
N#define _WWDT_ENABLE_IE(wincmp, periodsel)      (WWDT->WWDTCR = (WWDT_WWDTCR_WINCMP(wincmp) | (periodsel) | WWDT_WWDTCR_WWDTIE_Msk | WWDT_WWDTCR_WWDTEN_Msk))
N
N
N/**
N * @details     To reload the WWDT counter value to 0x3F
N */
N#define _WWDT_RELOAD_COUNTER()                  (WWDT->WWDTRLD = 0x00005AA5)
N
N
N/**
N * @details     To get the counter value of WWDT
N */
N#define _WWDT_GET_COUNTER()                     (WWDT->WWDTCVR)
N   
N
N/**
N * @details     Get WWDT Compare Match Interrupt Flag
N */
N#define _WWDT_GET_CMP_INT_FLAG()                ((((WWDT->WWDTSR) & WWDT_WWDTSR_WWDTIF_Msk) == WWDT_WWDTSR_WWDTIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear WWDT Compare Match Interrupt Flag to 0
N */
N#define _WWDT_CLEAR_CMP_INT_FLAG()              (WWDT->WWDTSR = WWDT_WWDTSR_WWDTIF_Msk)
N
N
N/**
N * @details     Get WWDT Timeout Reset Flag
N */
N#define _WWDT_GET_RESET_FLAG()                  ((((WWDT->WWDTSR) & WWDT_WWDTSR_WWDTRF_Msk) == WWDT_WWDTSR_WWDTRF_Msk)? 1:0)
N
N
N/**
N * @details     Clear WWDT Timeout Reset Flag to 0
N */
N#define _WWDT_CLEAR_RESET_FLAG()                (WWDT->WWDTSR = WWDT_WWDTSR_WWDTRF_Msk)
N
N
N
N/**
N  * @} End of WDT Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif  // __WDT_H__ 
L 6304 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "RTC.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\RTC.h" 1
N/**************************************************************************//**
N * @file     RTC.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series Real Time Clock Timer Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __RTC_H__
N#define __RTC_H__
N
N#include "NUC200Series.h"
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup RTC_FUNC RTC Device Function Interface
N  * @{
N  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* INIR Constants Definitions                                                                              */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_INIR_VALUE              0xA5EB1357UL  /*!< RTC Initiation value to make RTC leaving reset state */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* AER Constants Definitions                                                                               */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_AER_VALUE               0x0000A965UL  /*!< RTC AER value to enable RTC access and keep 1024 RTC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* FCR Constants Definitions                                                                               */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_FCR_INTEGER(x)          ((32776 - (x)) << RTC_FCR_INTEGER_Pos) /*!< x is integer part of detected RTC frequency and 32761 <= x <= 32776 */
N#define RTC_FCR_FRACTION(x)         ((uint32_t)((x) * 60))                 /*!< x is fraction part of detected RTC frequency */
N                                                            
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Time Data Constants Definitions                                                                         */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_TIME_10HR(x)            ((x) << RTC_TLR_10HR_Pos)  /*!< 10-Hour Time Digit of Current/Alarm Time, 0 <= x <= 2 */
N#define RTC_TIME_1HR(x)             ((x) << RTC_TLR_1HR_Pos)   /*!< 1-Hour Time Digit of Current/Alarm Time, 0 <= x <= 9 */
N#define RTC_TIME_10MIN(x)           ((x) << RTC_TLR_10MIN_Pos) /*!< 10-Min Time Digit of Current/Alarm Time, 0 <= x <= 5 */
N#define RTC_TIME_1MIN(x)            ((x) << RTC_TLR_1MIN_Pos)  /*!< 1-Min Time Digit of Current/Alarm Time, 0 <= x <= 9 */
N#define RTC_TIME_10SEC(x)           ((x) << RTC_TLR_10SEC_Pos) /*!< 10-Sec Time Digit of Current/Alarm Time, 0 <= x <= 5 */
N#define RTC_TIME_1SEC(x)            ((x) << RTC_TLR_1SEC_Pos)  /*!< 1-Sec Time Digit of Current/Alarm Time, 0 <= x <= 9 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Calendar Data Constants Definitions                                                                     */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_CALENDAR_10YEAR(x)      ((x) << RTC_CLR_10YEAR_Pos) /*!< 10-Year Calendar Digit of Current/Alarm Calendar, 0 <= x <= 9 */
N#define RTC_CALENDAR_1YEAR(x)       ((x) << RTC_CLR_1YEAR_Pos)  /*!< 1-Year Calendar Digit of Current/Alarm Calendar, 0 <= x <= 9 */
N#define RTC_CALENDAR_10MON(x)       ((x) << RTC_CLR_10MON_Pos)  /*!< 10-Month Calendar Digit of Current/Alarm Calendar, 0 <= x <= 1 */
N#define RTC_CALENDAR_1MON(x)        ((x) << RTC_CLR_1MON_Pos)   /*!< 1-Month Calendar Digit of Current/Alarm Calendar, 0 <= x <= 9 */
N#define RTC_CALENDAR_10DAY(x)       ((x) << RTC_CLR_10DAY_Pos)  /*!< 10-Day Calendar Digit of Current/Alarm Calendar, 0 <= x <= 3 */
N#define RTC_CALENDAR_1DAY(x)        ((x) << RTC_CLR_1DAY_Pos)   /*!< 1-Day Calendar Digit of Current/Alarm Calendar, 0 <= x <= 9 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TSSR Constants Definitions                                                                              */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_TSSR_12H                0x0UL /*!< Selected as 12-hour time scale with AM and PM indication */
N#define RTC_TSSR_24H                0x1UL /*!< Selected as 24-hour time scale */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* DWR Constants Definitions                                                                               */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_DWR_SUNDAY              0x0UL /*!< Day of the Week is Sunday */
N#define RTC_DWR_MONDAY              0x1UL /*!< Day of the Week is Monday */
N#define RTC_DWR_TUESDAY             0x2UL /*!< Day of the Week is Tuesday */
N#define RTC_DWR_WEDNESDAY           0x3UL /*!< Day of the Week is Wednesday */
N#define RTC_DWR_THURSDAY            0x4UL /*!< Day of the Week is Thursday */
N#define RTC_DWR_FRIDAY              0x5UL /*!< Day of the Week is Friday */
N#define RTC_DWR_SATURDAY            0x6UL /*!< Day of the Week is Saturday */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* RIER Constants Definitions                                                                              */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_RIER_AIER_ENABLE        0x01UL /*!< Alarm Interrupt Enable */
N#define RTC_RIER_AIER_DISABLE       0x00UL /*!< Alarm Interrupt Disable */
N#define RTC_RIER_TIER_ENABLE        0x02UL /*!< Time Tick Interrupt Enable */
N#define RTC_RIER_TIER_DISABLE       0x00UL /*!< Time Tick Interrupt Disable */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* TTR Constants Definitions                                                                               */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define RTC_TTR_1                   0x00UL /*!< RTC time tick period is 1 sec */
N#define RTC_TTR_1DIV2               0x01UL /*!< RTC time tick period is 1/2 sec */
N#define RTC_TTR_1DIV4               0x02UL /*!< RTC time tick period is 1/4 sec */
N#define RTC_TTR_1DIV8               0x03UL /*!< RTC time tick period is 1/8 sec */
N#define RTC_TTR_1DIV16              0x04UL /*!< RTC time tick period is 1/16 sec */
N#define RTC_TTR_1DIV32              0x05UL /*!< RTC time tick period is 1/32 sec */
N#define RTC_TTR_1DIV64              0x06UL /*!< RTC time tick period is 1/64 sec */
N#define RTC_TTR_1DIV128             0x07UL /*!< RTC time tick period is 1/128 sec */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* RTC Macro Definitions                                                                                   */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Initial RTC and run at normal active state
N */
N#define _RTC_INIT()                         (RTC->INIR = RTC_INIR_VALUE)
N
N
N/**
N * @details     To check if RTC is at normal active state or not
N */
N#define _RTC_IS_ACTIVE()                    ((RTC->INIR == 1)? 1:0)
N
N
N/**
N * @details     Enable RTC access and will keep 1024 RTC clock
N */
N#define _RTC_ENABLE_AER()                   (RTC->AER = RTC_AER_VALUE)
N
N
N/**
N * @details     To check if AER is enabled for read/write or not
N */
N#define _RTC_IS_AER_ENABLE()                (((RTC->AER & RTC_AER_ENF_Msk) == RTC_AER_ENF_Msk)? 1:0) 
N
N
N/**
N * @brief       Set RTC Frequency Compensation
N *
N * @param[in]   integer     Integer part of detected RTC frequency and 32761 <= integer <= 32776.
N * @param[in]   fraction    Fraction part of detected RTC frequency.
N *
N * @return      None
N *
N * @details     Set RTC frequency compensation of detected frequency.
N */
N#define _RTC_SET_FCR(integer, fraction)     (RTC->FCR = (RTC_FCR_INTEGER(integer) | RTC_FCR_FRACTION(fraction)))
N
N
N/**
N * @details     Get RTC Hour Data in 24-Hour Mode
N */
N#define _RTC_GET_HOUR()                     (((_GET_BYTE2(RTC->TLR) >> 4) * 10) + (_GET_BYTE2(RTC->TLR) & 0xF))
N
N
N/**
N * @details     Get RTC Min Data
N */
N#define _RTC_GET_MIN()                      (((_GET_BYTE1(RTC->TLR) >> 4) * 10) + (_GET_BYTE1(RTC->TLR) & 0xF))
N
N
N/**
N * @details     Get RTC Sec Data
N */
N#define _RTC_GET_SEC()                      (((_GET_BYTE0(RTC->TLR) >> 4) * 10) + (_GET_BYTE0(RTC->TLR) & 0xF))
N
N
N/**
N * @details     Get RTC Year Data
N */
N#define _RTC_GET_YEAR()                     (((_GET_BYTE2(RTC->CLR) >> 4) * 10) + (_GET_BYTE2(RTC->CLR) & 0xF))
N
N
N/**
N * @details     Get RTC Mon Data
N */
N#define _RTC_GET_MON()                      (((_GET_BYTE1(RTC->CLR) >> 4) * 10) + (_GET_BYTE1(RTC->CLR) & 0xF))
N
N
N/**
N * @details     Get RTC Day Data
N */
N#define _RTC_GET_DAY()                      (((_GET_BYTE0(RTC->CLR) >> 4) * 10) + (_GET_BYTE0(RTC->CLR) & 0xF))
N
N
N/**
N * @details     Get RTC Alarm Hour Data in 24-Hour Mode
N */
N#define _RTC_GET_ALARM_HOUR()               (((_GET_BYTE2(RTC->TAR) >> 4) * 10) + (_GET_BYTE2(RTC->TAR) & 0xF))
N
N
N/**
N * @details     Get RTC Alarm Min Data
N */
N#define _RTC_GET_ALARM_MIN()                (((_GET_BYTE1(RTC->TAR) >> 4) * 10) + (_GET_BYTE1(RTC->TAR) & 0xF))
N
N
N/**
N * @details     Get RTC Alarm Sec Data
N */
N#define _RTC_GET_ALARM_SEC()                (((_GET_BYTE0(RTC->TAR) >> 4) * 10) + (_GET_BYTE0(RTC->TAR) & 0xF))
N
N
N/**
N * @details     Get RTC Alarm Year Data
N */
N#define _RTC_GET_ALARM_YEAR()               (((_GET_BYTE2(RTC->CAR) >> 4) * 10) + (_GET_BYTE2(RTC->CAR) & 0xF))
N
N
N/**
N * @details     Get RTC Alarm Mon Data
N */
N#define _RTC_GET_ALARM_MON()                (((_GET_BYTE1(RTC->CAR) >> 4) * 10) + (_GET_BYTE1(RTC->CAR) & 0xF))
N
N
N/**
N * @details     Get RTC Alarm Day Data
N */
N#define _RTC_GET_ALARM_DAY()                (((_GET_BYTE0(RTC->CAR) >> 4) * 10) + (_GET_BYTE0(RTC->CAR) & 0xF))
N
N
N/**
N * @brief       Set RTC Day of the Week 
N *
N * @param[in]   fraction    Fraction part of detected RTC frequency.
N * @param[in]   dwr         Specify RTC day of the week. It could be \n
N *                          RTC_DWR_SUNDAY, RTC_DWR_MONDAY, RTC_DWR_TUESDAY, RTC_DWR_WEDNESDAY, \n
N *                          RTC_DWR_THURSDAY, RTC_DWR_FRIDAY, RTC_DWR_SATURDAY.
N *
N * @return      None
N *
N * @details     Set current RTC Day of the Week.
N */
N#define _RTC_SET_DWR(dwr)                   (RTC->DWR = (dwr))
N
N
N/**
N * @details     Get RTC Day of the Week
N */
N#define _RTC_GET_DWR()                      (RTC->DWR)
N
N
N/**
N * @details     Enable RTC Alarm Interrupt
N */
N#define _RTC_ALARM_INT_ENABLE()             (RTC->RIER |= RTC_RIER_AIER_ENABLE)
N
N
N/**
N * @details     Disable RTC Alarm Interrupt
N */
N#define _RTC_ALARM_INT_DISABLE()            (RTC->RIER &= ~RTC_RIER_AIER_Msk)
N
N
N/**
N * @details     Enable RTC Tick Interrupt
N */
N#define _RTC_TICK_INT_ENABLE()              (RTC->RIER |= RTC_RIER_TIER_ENABLE)
N
N
N/**
N * @details     Disable RTC Tick Interrupt
N */
N#define _RTC_TICK_INT_DISABLE()             (RTC->RIER &= ~RTC_RIER_TIER_Msk)
N
N
N/**
N * @details     Get RTC Alarm Interrupt Flag
N */
N#define _RTC_GET_ALARM_INT_FLAG()           (((RTC->RIIR & RTC_RIIR_AIF_Msk) == RTC_RIIR_AIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear RTC Alarm Interrupt Flag
N */
N#define _RTC_CLEAR_ALARM_INT_FLAG()         (RTC->RIIR = RTC_RIIR_AIF_Msk)
N                                               
N
N/**
N * @details     Get RTC Tick Interrupt Flag
N */
N#define _RTC_GET_TICK_INT_FLAG()            (((RTC->RIIR & RTC_RIIR_TIF_Msk) == RTC_RIIR_TIF_Msk)? 1:0)
N
N
N/**
N * @details     Clear RTC Tick Interrupt Flag
N */
N#define _RTC_CLEAR_TICK_INT_FLAG()          (RTC->RIIR = RTC_RIIR_TIF_Msk)
N                                               
N
N/**
N * @brief       Set RTC Time Tick Period 
N *
N * @param[in]   ttr         Specify RTC time tick period. It could be \n
N *                          RTC_TTR_1, RTC_TTR_1DIV2, RTC_TTR_1DIV4, RTC_TTR_1DIV8, \n
N *                          RTC_TTR_1DIV16, RTC_TTR_1DIV32, RTC_TTR_1DIV64 and RTC_TTR_1DIV128.
N *
N * @return      None
N *
N * @details     Set current RTC Day of the Week.
N */
N#define _RTC_SET_TTR(ttr)                   (RTC->TTR = (ttr))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief       Set RTC Time
N *
N * @param[in]   u32Hour     Specify RTC Hour data in 24-Hour mode
N * @param[in]   u32Min      Specify RTC Min data
N * @param[in]   u32Sec      Specify RTC Sec data
N *
N * @return      None
N *
N * @details     Set current RTC Time in 24-Hour mode.
N */
Nstatic __INLINE void RTC_SetCurrentTime(uint32_t u32Hour, uint32_t u32Min, uint32_t u32Sec)
Xstatic __inline void RTC_SetCurrentTime(uint32_t u32Hour, uint32_t u32Min, uint32_t u32Sec)
N{
N    RTC->TSSR = RTC_TSSR_24H;
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->TSSR = 0x1UL;
N
N    RTC->TLR = RTC_TIME_10HR(u32Hour/10) | RTC_TIME_1HR(u32Hour%10) |
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->TLR = ((u32Hour/10) << 20) | ((u32Hour%10) << 16) |
N               RTC_TIME_10MIN(u32Min/10) | RTC_TIME_1MIN(u32Min%10) |
X               ((u32Min/10) << 12) | ((u32Min%10) << 8) |
N               RTC_TIME_10SEC(u32Sec/10) | RTC_TIME_1SEC(u32Sec%10);
X               ((u32Sec/10) << 4) | ((u32Sec%10) << 0);
N}
N
N
N/**
N * @brief       Set RTC Calendar
N *
N * @param[in]   u32Year     Specify RTC Year data and 0 <= u32Year <= 99
N * @param[in]   u32Mon      Specify RTC Mon data
N * @param[in]   u32Day      Specify RTC Day data
N *
N * @return      None
N *
N * @details     Set current RTC Calendar.
N */
Nstatic __INLINE void RTC_SetCurrentCalendar(uint32_t u32Year, uint32_t u32Mon, uint32_t u32Day)
Xstatic __inline void RTC_SetCurrentCalendar(uint32_t u32Year, uint32_t u32Mon, uint32_t u32Day)
N{
N    RTC->CLR = RTC_CALENDAR_10YEAR(u32Year/10) | RTC_CALENDAR_1YEAR(u32Year%10) |
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->CLR = ((u32Year/10) << 20) | ((u32Year%10) << 16) |
N               RTC_CALENDAR_10MON(u32Mon/10)   | RTC_CALENDAR_1MON(u32Mon%10)   |
X               ((u32Mon/10) << 12)   | ((u32Mon%10) << 8)   |
N               RTC_CALENDAR_10DAY(u32Day/10)   | RTC_CALENDAR_1DAY(u32Day%10);
X               ((u32Day/10) << 4)   | ((u32Day%10) << 0);
N}
N
N
N/**
N * @brief       Set RTC Alarm Time
N *
N * @param[in]   u32Hour     Specify RTC Alarm Hour data in 24-Hour mode
N * @param[in]   u32Mon      Specify RTC Alarm Mon data
N * @param[in]   u32Day      Specify RTC Alarm Day data
N *
N * @return      None
N *
N * @details     Set current RTC Alarm Time in 24-Hour mode.
N */
Nstatic __INLINE void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Min, uint32_t u32Sec)
Xstatic __inline void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Min, uint32_t u32Sec)
N{
N    RTC->TSSR = RTC_TSSR_24H;
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->TSSR = 0x1UL;
N
N    RTC->TAR = RTC_TIME_10HR(u32Hour/10) | RTC_TIME_1HR(u32Hour%10) |
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->TAR = ((u32Hour/10) << 20) | ((u32Hour%10) << 16) |
N               RTC_TIME_10MIN(u32Min/10) | RTC_TIME_1MIN(u32Min%10) |
X               ((u32Min/10) << 12) | ((u32Min%10) << 8) |
N               RTC_TIME_10SEC(u32Sec/10) | RTC_TIME_1SEC(u32Sec%10);
X               ((u32Sec/10) << 4) | ((u32Sec%10) << 0);
N}
N
N
N/**
N * @brief       Set RTC Alarm Calendar
N *
N * @param[in]   u32Year     Specify RTC Alarm Year data and 0 <= u32Year <= 99
N * @param[in]   u32Mon      Specify RTC Alarm Mon data
N * @param[in]   u32Day      Specify RTC Alarm Day data
N *
N * @return      None
N *
N * @details     Set current RTC Alarm Calendar.
N */
Nstatic __INLINE void RTC_SetAlarmCalendar(uint32_t u32Year, uint32_t u32Mon, uint32_t u32Day)
Xstatic __inline void RTC_SetAlarmCalendar(uint32_t u32Year, uint32_t u32Mon, uint32_t u32Day)
N{
N    RTC->CAR = RTC_CALENDAR_10YEAR(u32Year/10) | RTC_CALENDAR_1YEAR(u32Year%10) |
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->CAR = ((u32Year/10) << 20) | ((u32Year%10) << 16) |
N               RTC_CALENDAR_10MON(u32Mon/10)   | RTC_CALENDAR_1MON(u32Mon%10)   |
X               ((u32Mon/10) << 12)   | ((u32Mon%10) << 8)   |
N               RTC_CALENDAR_10DAY(u32Day/10)   | RTC_CALENDAR_1DAY(u32Day%10);
X               ((u32Day/10) << 4)   | ((u32Day%10) << 0);
N}
N
N
N/**
N * @brief       Wait RTC AER Enable
N *
N * @param       None
N *
N * @return      None
N *
N * @details     Wait RCT AER bit enable for access RTC registers.
N */
Nstatic __INLINE void RTC_WaitAccessEnable(void)
Xstatic __inline void RTC_WaitAccessEnable(void)
N{
N    /* Wait AER disabled and enable AER again */
N    while (_RTC_IS_AER_ENABLE() == 1);
X    while ((((((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER & (1ul << 16)) == (1ul << 16))? 1:0) == 1);
N    _RTC_ENABLE_AER();
X    (((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER = 0x0000A965UL);
N
N    /* Check if AER has enabled for accress RTC registers */
N    while (_RTC_IS_AER_ENABLE() == 0);
X    while ((((((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER & (1ul << 16)) == (1ul << 16))? 1:0) == 0);
N}
N
N
N/**
N  * @} End of RTC Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif  // __RTC_H__ 
L 6305 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "UART.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\UART.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V2.1
N * $Revision: 6 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series UART Interface Controller Driver Header File
N *
N * @note                                                                              
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N#include "NUC200Series.h"
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup UART_FUNC UART Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE      (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FCR_RFITL_4BYTES     (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FCR_RFITL_8BYTES     (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FCR_RFITL_14BYTES    (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE      (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 bit */
N#define UART_FCR_RTS_TRI_LEV_4BYTES     (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bits */
N#define UART_FCR_RTS_TRI_LEV_8BYTES     (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bits */
N#define UART_FCR_RTS_TRI_LEV_14BYTES    (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5     (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6     (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7     (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8     (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Tigger   */
N#define UART_RTS_IS_LOW_LEV_TRG  (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Tigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART  (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN   (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set LIN Funciton             */
N#define UART_FUNC_SEL_IrDA  (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485 (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LIN_CTL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_LIN_CTL_LINS_EN        (0x1UL << UART_LIN_CTL_LINS_EN_Pos)       /*!< UA_LIN_CTL setting to set LIN Slave Mode Enable */
N#define UART_LIN_CTL_LINS_HDET_EN   (0x1UL << UART_LIN_CTL_LINS_HDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Slave Header Detection Enable */
N#define UART_LIN_CTL_LINS_ARS_EN    (0x1UL << UART_LIN_CTL_LINS_ARS_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Automatic Resynchronization Mode Enable */
N#define UART_LIN_CTL_LINS_DUM_EN    (0x1UL << UART_LIN_CTL_LINS_DUM_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Divider Update Method Enable */
N#define UART_LIN_CTL_LIN_WAKE_EN    (0x1UL << UART_LIN_CTL_LIN_WAKE_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Wake-Up Mode Enable */
N#define UART_LIN_CTL_LIN_SHD        (0x1UL << UART_LIN_CTL_LIN_SHD_Pos)       /*!< UA_LIN_CTL setting to set LIN TX Send Header Enable */
N#define UART_LIN_CTL_LIN_IDPEN      (0x1UL << UART_LIN_CTL_LIN_IDPEN_Pos)     /*!< UA_LIN_CTL setting to set LIN ID Parity Enable */
N#define UART_LIN_CTL_LIN_BKDET_ENN  (0x1UL << UART_LIN_CTL_LIN_BKDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Detection Enable */
N#define UART_LIN_CTL_LIN_RX_DIS     (0x1UL << UART_LIN_CTL_LIN_RX_DIS_Pos)    /*!< UA_LIN_CTL setting to set LIN Receiver Disable */
N#define UART_LIN_CTL_BIT_ERR_EN     (0x1UL << UART_LIN_CTL_BIT_ERR_EN_Pos)    /*!< UA_LIN_CTL setting to set Bit Error Detect Enable */
N#define UART_LIN_CTL_LIN_BKFL(x)    (((x)-1) << UART_LIN_CTL_LIN_BKFL_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Field Length, x = 10 ~ 15, default value is 12 */
N#define UART_LIN_CTL_LIN_BS_LEN(x)  (((x)-1) << UART_LIN_CTL_LIN_BS_LEN_Pos)/*!< UA_LIN_CTL setting to set LIN Break/Sync Delimiter Length, x = 1 ~ 4 */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK             (0x0UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC        (0x1UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field and sync field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC_ID     (0x2UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field, sync field and ID field*/
N#define UART_LIN_CTL_LIN_LIN_PID(x) ((x) << UART_LIN_CTL_LIN_PID_Pos)       /*!< UA_LIN_CTL setting to set LIN PID value */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* BAUD constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0                                 (0)
N#define UART_BAUD_MODE2                                 (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk)
N
N
N/**
N * @brief      Compute Baud Rate Divider Settings by mode 0
N *
N * @param[in]  u32SrcFreq      UART clock source(UART_S) divides by UART divider(UART_N)
N * @param[in]  u32BaudRate     Target bitrate (Hz)
N *    
N * @return     None
N *    
N * @details    The function is used to get baud-rate divider settings by mode 0  based on your settings.\n
N *    
N *             Example: UART clock source from PLL(48MHz) and UART clock divider is set 2.\n 
N *                      If desired baudrate is 115200, you can call UART_BAUD_DIV_MODE2(24000000,115200);
N *                           
N */
N#define UART_BAUD_DIV_MODE0(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-2)
N
N/**
N * @brief      Compute Baud Rate Divider Settings by mode 2
N *
N * @param[in]  u32SrcFreq      UART clock source(UART_S) was divided by UART divider(UART_N)
N * @param[in]  u32BaudRate     Target bitrate (Hz)
N *    
N * @return     None
N *    
N * @details    The function is used to get baud rate divider settings by mode 2 based on your settings.\n
N *    
N *             Example: UART clock source from PLL(48MHz) and UART clock divider is set 2.\n 
N *                      If desired baudrate is 115200, you can call UART_BAUD_DIV_MODE2(24000000,115200);
N *                           
N */
N
N#define UART_BAUD_DIV_MODE2(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate/2)) / u32BaudRate)-2)     
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Data Transmit/Receive                                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Send one data byte from specify uart port
N *
N * @param[in]  UART         Structure pointer of UART Channel selected, should be:
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u8Data       Data byte to transmit 
N *                          
N * @return     None
N *
N * @details    The function is used to send UART data.\n
N *             Example: _UART_SENDBYTE(UART0,0x55)
N */
N#define _UART_SENDBYTE(UART,u8Data)   ((UART)->THR = (u8Data))
N
N/**
N * @brief      Receive one data byte from specify uart port
N *
N * @param[in]  UART         Structure pointer of UART Channel selected, should be: 
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @return     The oldest data byte in RX FIFO 
N *
N * @details    The function is used to get one data byte from RX FIFO of specified UART port.\n
N *             Example: _UART_RECEIVEBYTE(UART0,u8Data)
N */
N#define _UART_RECEIVEBYTE(UART,u8Data)  ((u8Data) = (UART)->RBR)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Baud Rate Relative                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Get UART Clock Source Freq. (Hz)
N *
N * @param[in]  None  
N *
N * @return     UART Clock Source Freq.
N *
N * @details    The function will read UART_S bit field in CLKSEL1 register to determine UART clock source freq.\n
N *             Before calling the function, please use SystemCoreClockUpdate to update system clock freq.
N */
N
Nstatic __INLINE uint32_t UART_GetClockFreq()
Xstatic __inline uint32_t UART_GetClockFreq()
N{
N    uint8_t u8UartClkSrcSel;
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};    
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};    
N    u32ClkTbl[1] = PllClock;
N    u8UartClkSrcSel = (SYSCLK->CLKSEL1 & SYSCLK_CLKSEL1_UART_S_Msk) >> SYSCLK_CLKSEL1_UART_S_Pos;
X    u8UartClkSrcSel = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL1 & (3ul << 24)) >> 24;
N    return u32ClkTbl[u8UartClkSrcSel];
N}
N
N/**
N * @brief      Get UART Clock Divider. (Hz)
N *
N * @param[in]  None  
N *
N * @return     UART Clock Divider.
N *
N * @details    The function will read UART_N bit field in CLKDIV register to determine current UART clock divider.
N *             
N */
N
Nstatic __INLINE uint32_t UART_GetClockDivider()
Xstatic __inline uint32_t UART_GetClockDivider()
N{
N    return ((SYSCLK->CLKDIV & SYSCLK_CLKDIV_UART_N_Msk) >> SYSCLK_CLKDIV_UART_N_Pos) + 1;
X    return ((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKDIV & (0xFul << 8)) >> 8) + 1;
N}
N
N
N/**
N * @brief      Using Baud Rate Equation Mode 0 to get divisor.     (DIV_X_EN=0, DIV_X_ONE=0) 
N *
N * @param[in]  u32BaudRate  Baud rate setting for UART   
N *
N * @return     UART baud rate divisor.
N *
N * @details    The function will get UART baud rate divisor by equation. (UART_CLK / [16 * (A+2)])
N *             
N */
Nstatic __INLINE uint32_t UART_GetDivisor_ByMode0(uint32_t u32BaudRate)
Xstatic __inline uint32_t UART_GetDivisor_ByMode0(uint32_t u32BaudRate)
N{
N    return ((((UART_GetClockFreq()/UART_GetClockDivider()) / u32BaudRate + 1) >> 4) -2) ;
N}
N
N
N/**
N * @brief      Using Baud Rate Equation Mode 1 to get divisor. (DIV_X_EN=1, DIV_X_ONE=0) 
N *
N * @param[in]  u32BaudRate  Baud rate setting for UART   
N * @param[in]  u8Divider_X  Divider X
N *
N * @return     UART baud rate divisor.
N *
N * @details    The function will get UART baud rate divisor by equation. (UART_CLK / [(B+1) * (A+2)] )
N *             
N */                      
Nstatic __INLINE uint32_t UART_GetDivisor_ByMode1(uint32_t u32BaudRate,uint8_t u8Divider_X)
Xstatic __inline uint32_t UART_GetDivisor_ByMode1(uint32_t u32BaudRate,uint8_t u8Divider_X)
N{
N    return ((((UART_GetClockFreq()/UART_GetClockDivider()) / u32BaudRate + 1) / u8Divider_X) -2) ;
N}                                        
N
N/**
N * @brief      Using Baud Rate Equation Mode 2 to get divisor.(DIV_X_EN=1, DIV_X_ONE=1) 
N *
N * @param[in]  u32BaudRate  Baud rate setting for UART   
N *
N * @return     UART baud rate divisor.
N *
N * @details    The function will get UART baud rate divisor by equation. (UART_CLK / 1 * (A+2)] )
N *             
N */
Nstatic __INLINE uint32_t UART_GetDivisor_ByMode2(uint32_t u32BaudRate)
Xstatic __inline uint32_t UART_GetDivisor_ByMode2(uint32_t u32BaudRate)
N{
N    return (((UART_GetClockFreq()/UART_GetClockDivider() * 2) / u32BaudRate + 1) >> 1);
N}
N
N/**
N * @brief      Set UART Baud Rate
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u32BaudRate  Baud rate setting for UART 
N *                          - Bit per sec. : ex.115200
N * @return     None
N *
N * @details    The function uses mode 2 (DIV_X_EN=1, DIV_X_ONE=1) to set baud rate.\n
N *             Example: UART_SetBaudRate(UART0, 115200)
N */
Nstatic __INLINE void UART_SetBaudRate(UART_T *UART, uint32_t u32BaudRate)
Xstatic __inline void UART_SetBaudRate(UART_T *UART, uint32_t u32BaudRate)
N{
N    UART->BAUD = UART_BAUD_MODE2 | UART_GetDivisor_ByMode2(u32BaudRate); 
X    UART->BAUD = ((1ul << 29) | (1ul << 28)) | UART_GetDivisor_ByMode2(u32BaudRate); 
N}
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* FORMAT CONTROL                                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Set UART line control 
N *
N * @param[in]  UART         Structure pointer of UART Channel selected,should be:  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u32PortSettings  Line control value: Use "|" to combine your settings
N *                          - Word Length Select : eg. UART_WORD_LEN_5 
N *                          - Parity Bit         : eg. UART_PARITY_NONE
N *                          - Stop Bit           : eg. UART_STOPBIT_1
N * @return     None
N *
N * @details    The function is used to set UART data format (Word Length Select /Parity Bit/Stop Bit).\n
N *             Example: _UART_SET_DATA_FORMAT(UART0, UART_WORD_LEN_5 | UART_PARITY_NONE | UART_STOPBIT_1)
N */
N#define _UART_SET_DATA_FORMAT(UART, u32PortSettings)  ((UART)->LCR = (u32PortSettings))
N
N
N
N/**
N * @brief      Set UART transmit delay time 
N *
N * @param[in]  UART         Structure pointer of UART Channel selected,should be:  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  DelayTime  N-th uart bit-time between each transmission
N *                                                                
N * @return     None
N *
N * @details    The function is used to set N-th uart bit-time between each transmission. \n
N *             Example: _UART_SET_TX_DELAYTIME(UART0, 10)
N */
N
N#define _UART_SET_TX_DELAYTIME(UART,DelayTime)    ((UART)->TOR = ((UART)->TOR &~UART_TOR_DLY_Msk)|((DelayTime)<<UART_TOR_DLY_Pos))  
N
N
N
N/**
N * @brief      Set time-out counter
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  u32Count     TimeOutCounter:  0~255
N *
N * @return     None
N *                                                           
N * @details    The function is used to access TOR[7:0] to control timeout counter.\n
N *             When there is un-read data in rx-fifo and IER[11] is set, the counter will start up-count.\n
N *             Until the counter each the value, the time-out event will happened.\n
N *             Example: UART_SetTimeOutCounter(UART0, 128)
N *
N * @note       Per count is according to bitrate settings.
N */
N                               
Nstatic __INLINE void UART_SetTimeOutCounter(UART_T* UART,uint32_t u32Count)
Xstatic __inline void UART_SetTimeOutCounter(UART_T* UART,uint32_t u32Count)
N{
N    (UART)->TOR = ((UART)->TOR & ~UART_TOR_TOIC_Msk)| (u32Count);
X    (UART)->TOR = ((UART)->TOR & ~(0xFFul << 0))| (u32Count);
N    (UART)->IER |= UART_IER_TIME_OUT_EN_Msk;
X    (UART)->IER |= (1ul << 11);
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* FIFO Control                                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Check specified uart port transmission is over. 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @retval     0 = The transmission is not over. 
N * @retval     1 = The transmission is over. 
N *
N * @details    The function is used to read FSR[28] to check the TX_FIFO and TX_Shift_Reigster is empty.\n
N *             Example: _UART_IS_TX_EMPTY(UART0)
N */
N
N#define _UART_IS_TX_EMPTY(UART)    (((UART)->FSR & UART_FSR_TE_FLAG_Msk)>>UART_FSR_TE_FLAG_Pos) 
N
N
N/**
N * @brief      Wait specified uart port transmission is over 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @return     None 
N *
N * @details    The function is used to polling FSR[28] and waiting the TX_FIFO and 
N *             TX_Shift_Reigster is empty. Wait FSR[28] bit is set to exit the while loop.\n
N *             Example: _UART_WAIT_TX_EMPTY(UART0)
N */
N#define _UART_WAIT_TX_EMPTY(UART)        while(!((((UART)->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N
N
N                                              
N/**
N * @brief      Check RDA_IF is set or not
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     0 = the number of bytes in the RX FIFO is less than the RFITL  
N * @retval     1 = The number of bytes in the RX FIFO equals or larger than RFITL
N *
N * @details    The function is used to read RDA_IF to check the number of bytes in the RX FIFO.
N *             
N *             Example: _UART_IS_RX_READY(UART0)
N */
N
N#define _UART_IS_RX_READY(UART)    (((UART)->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N * @brief      Check there is un-read data in RX FIFO
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     The number of N data bytes in RX FIFO.
N *
N * @details    The function is used to read FSR[13:8] RX FIFO POINTER to check 
N *             there is un-read data int RX_FIFO.\n
N *             Example: _UART_GET_RX_POINTER(UART0)
N */
N#define _UART_GET_RX_POINTER(UART)    (((UART)->FSR & UART_FSR_RX_POINTER_Msk) >> UART_FSR_RX_POINTER_Pos)
N
N
N/**
N * @brief      Check there is un-transmited data in TX FIFO
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     The number of N data bytes in TX FIFO.
N *
N * @details    The function is used to read FSR[21:16] TX FIFO POINTER to check 
N *             there is un-transmited data int TX_FIFO.\n
N *             Example: _UART_GET_TX_POINTER(UART0)
N */
N#define _UART_GET_TX_POINTER(UART)    (((UART)->FSR & UART_FSR_TX_POINTER_Msk) >> UARTFSR_TX_POINTER_Pos)
N
N
N/**
N * @brief      Check TX FIFO is full or not 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     1 = TX FIFO is full
N * @retval     0 = TX FIFO is not full
N *
N * @details    The function is used to read FSR[23] to check tx fifo is full or not.
N *             If writing data to tx fifo when it is full,buffer error will happen.
N *             Example: _UART_IS_TX_FULL(UART0)
N */
N#define _UART_IS_TX_FULL(UART)   (((UART)->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N * @brief      Check RX FIFO is full or not 
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N *
N * @retval     1 = RX FIFO is full
N * @retval     0 = RX FIFO is not full
N *
N * @details    The function is used to read FSR[15] to check rx fifo is full or not.
N *             If receving a new data to rx fifo when it is full,buffer error will happen.
N *             Example: _UART_IS_RX_FULL(UART0)
N */
N
N#define _UART_IS_RX_FULL(UART)   (((UART)->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N * @brief      Reset TX/RX FIFO
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  uPara      Reset FIFO Select  (Uses "OR" to add your settings)
N *                          - UART_FCR_TFR_Msk : TX FIFO 
N *                          - UART_FCR_RFR_Msk : RX FIFO 
N * @return     None
N *
N * @details    The function is used to write FCR[2:1] to reset TX or RX FIFO.\n
N *             Example: _UART_FLUSH_FIFO(UART0,UART_TX_FIFO|UART_RX_FIFO)
N *
N * @note       After user call the function, data in tx or rx fifo in specified UART port will be cleared.
N */
N
N#define _UART_FLUSH_FIFO(UART,uPara)    ((UART)->FCR |= (uPara))
N
N
N/**
N * @brief      Set Rx trigger level
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eLevel       Rx trigger level
N *                          - UART_FCR_RFITL_1BYTE   : RDA Trigger Level is 1 byte   
N *                          - UART_FCR_RFITL_4BYTES  : RDA Trigger Level is 4 byte  
N *                          - UART_FCR_RFITL_8BYTES  : RDA Trigger Level is 8 byte 
N *                          - UART_FCR_RFITL_14BYTES : RDA Trigger Level is 14 byte 
N * @return     None
N *                                                           
N * @details    The function is used to access FCR[7:4] to control rx trigger level.\n
N *             Example: _UART_SET_RX_TRG_LEV(UART0, UART_RX_TRG_LEV_8)
N *
N * @note       Rx trigger level will effort RDA_IF and RDA_INT.
N */
N#define _UART_SET_RX_TRG_LEV(UART,eLevel)    ((UART)->FCR = ((UART)->FCR & ~UART_FCR_RFITL_Msk)| (eLevel))
N
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Interrupt Control                                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Enable specified interrupt
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eIntTypeSel  Interrupt type select
N *                          - UART_IER_LIN_IEN_Msk     : LIN Rx break interrupt  
N *                          - UART_IER_BUF_ERR_IEN_Msk : Buffur Error interrupt   
N *                          - UART_IER_RTO_IEN_Msk     : Rx time-out interrupt       
N *                          - UART_IER_MOS_IEN_Msk     : Modem interrupt           
N *                          - UART_IER_RLS_IEN_Msk     : Rx Line status interrupt                              
N *                          - UART_IER_THRE_IEN_Msk    : Tx empty interrupt          
N *                          - UART_IER_RDA_IEN_Msk     : Rx ready interrupt           
N *
N * @return     None
N *                                                           
N * @details    The function is used to enable specified UART interrupt.\n
N *             Example: _UART_ENABLE_INT(UART0,(eDRVUART_RDA_INT | eDRVUART_RLS_INT)
N *             
N * @note       When enable eDRVUART_THRE_INT interrupt source, the interrup will happen continouly if
N *             TX_FIFO is empty. Remind you that be careful to use it.\n  
N *             Please reference TRM to get more information.
N *
N */
N
N#define _UART_ENABLE_INT(UART,eIntTypeSel)    ((UART)->IER |= (eIntTypeSel))
N
N
N/**
N * @brief      Disable specified interrupt  
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eIntTypeSel  Interrupt type select
N *                          - UART_IER_LIN_IEN_Msk     : LIN Rx break interrupt  
N *                          - UART_IER_BUF_ERR_IEN_Msk : Buffur Error interrupt   
N *                          - UART_IER_RTO_IEN_Msk     : Rx time-out interrupt       
N *                          - UART_IER_MOS_IEN_Msk     : Modem interrupt           
N *                          - UART_IER_RLS_IEN_Msk     : Rx Line status interrupt                              
N *                          - UART_IER_THRE_IEN_Msk    : Tx empty interrupt          
N *                          - UART_IER_RDA_IEN_Msk     : Rx ready interrupt           
N * @return     None
N *                                                           
N * @details    The function is used to disable UART specified interrupt.\n
N *             Example: _UART_DISABLE_INT(UART0,(UART_RDA_INT | UART_RLS_INT)
N */
N#define _UART_DISABLE_INT(UART,eIntSel)    ((UART)->IER &= ~ (eIntSel))
N
N
N/**
N * @brief      Get specified interrupt flag/status
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eIntTypeFlag  Interrupt Type Flag,should be
N *                          - UART_LIN_INT_FLAG      : LIN Rx break interrupt flag    
N *                          - UART_BUFERR_INT_FLAG   : Buffur Error interrupt flag    
N *                          - UART_TOUT_INT_FLAG     : Rx time-out interrupt flag     
N *                          - UART_MOS_INT_FLAG      : Modem interrupt flag           
N *                          - UART_RLS_INT_FLAG      : Rx Line status interrupt flag 
N *                          - UART_THRE_INT_FLAG     : Tx empty interrupt flag        
N *                          - UART_RDA_INT_FLAG      : Rx ready interrupt flag     
N *
N * @retval     0 = The specified interrupt is not happened. 
N * @retval     1 = The specified interrupt is happened.
N *                                                           
N * @details    The function is used to read ISR[7:0] to get interrupt status.\n
N *             Example: _UART_GET_INT_FLAG(UART0,UART_RLS_INT)
N *
N */                                                                                      
N#define _UART_GET_INT_FLAG(UART,eIntTypeFlag) (((UART)->ISR & (eIntTypeFlag))?1:0)
N
N
N
N/**
N * @brief      Clear RLS interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access PEF/FEF/BIF BIT to clear RLS interrupt flag.\n
N *             Example: _UART_CLEAR_RLS_INT_FLAG(UART0)
N *
N */  
N#define _UART_CLEAR_RLS_INT_FLAG(UART)  ((UART)->FSR |= (UART_FSR_PEF_Msk|UART_FSR_FEF_Msk|UART_FSR_BIF_Msk))
N
N
N /**
N * @brief      Clear Modem interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access DCTSF to clear Modem interrupt flag.\n
N *             Example: _UART_CLEAR_MODEM_INT_FLAG(UART0)
N *
N */  
N#define _UART_CLEAR_MODEM_INT_FLAG(UART)  ((UART)->MSR |= UART_MSR_DCTSF_Msk)
N
N /**
N * @brief      Clear LIN Rx break interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access LIN Rx break interrupt flag
N *             to clear Modem interrupt flag.\n
N *             Example: _UART_CLEAR_LIN_RXBREAK_INT_FLAG(UART0)
N */ 
N#define _UART_CLEAR_LIN_RXBREAK_INT_FLAG(UART)   ((UART)->ISR |= UART_ISR_LIN_RX_BREAK_IF_Msk)
N
N /**
N * @brief      Clear buffur error interrupt flag
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @return     None
N *                                                           
N * @details    The function is used to access RX_OVER_IF and TX_OVER_IF to clear buffur error interrupt flag.\n
N *             Example: _UART_CLEAR_BUFERR_INT_FLAG(UART0)
N *
N */
N#define _UART_CLEAR_BUFERR_INT_FLAG(UART)  ((UART)->FSR |= UART_FSR_RX_OVER_IF_Msk | UART_FSR_TX_OVER_IF_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Flow Control                                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Set RTS Trigger Level
N *
N * @param[in]  UART         Structure pointer of UART Channel  
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1 
N * @param[in]  eActLevel    RTS Active Level  
N *                          - UART_RTS_IS_HIGH_LEV_TRG : High Level trigger(Default)  
N *                          - UART_RTS_IS_LOW_LEV_TRG  : Low Level trigger 
N *
N * @param[in]  eTRGLevel    RTS Trigger Level Select
N *                          - UART_FCR_RTS_TRI_LEV_1BYTE   : RTS Trigger Level is 1 byte 
N *                          - UART_FCR_RTS_TRI_LEV_4BYTES  : RTS Trigger Level is 4 bytes 
N *                          - UART_FCR_RTS_TRI_LEV_8BYTES  : RTS Trigger Level is 8 bytes 
N *                          - UART_FCR_RTS_TRI_LEV_14BYTES : RTS Trigger Level is 14 bytes
N *
N * @return     None                                                            
N *                                                           
N * @details    The function is used to set RTS trigger level 1,4,8,14 bytes. It is used to autoflow control.\n
N *             Example: UART_SetRTS_TrgLev(UART0,UART_RTS_IS_HIGH_LEV_TRG,UART_RTS_TRG_LEV_1)
N *
N * @details    Default State: RTS is high level active. 
N */  
N                         
N__INLINE void UART_SetRTS_TrgLev(UART_T* UART,uint32_t eActLevel,uint32_t eTRG_Level)
X__inline void UART_SetRTS_TrgLev(UART_T* UART,uint32_t eActLevel,uint32_t eTRG_Level)
N{
N    (UART)->MCR = ((UART)->MCR & ~UART_MCR_LEV_RTS_Msk     | (eActLevel ));
X    (UART)->MCR = ((UART)->MCR & ~(1ul << 9)     | (eActLevel ));
N    (UART)->FCR = ((UART)->FCR & ~UART_FCR_RTS_TRI_LEV_Msk | (eTRG_Level));
X    (UART)->FCR = ((UART)->FCR & ~(0xFul << 16) | (eTRG_Level));
N}
N
N/**
N * @brief      Enable RTS/CTS Auto Flow Control
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  eFlowCtl     Flow Control Select
N *                          - UART_IER_AUTO_RTS_EN_Msk : RTS Auto Flow Control 
N *                          - UART_IER_AUTO_CTS_EN_Msk : CTS Auto Flow Control 
N * @return     None
N *                                                           
N * @details    The function is used to set AutoFlow Control RTS/CTS function.\n
N *             Example: _UART_ENABLE_AUTOFLOW(UART0,UART_AUTO_RTS)
N *
N */  
N#define _UART_ENABLE_AUTOFLOW(UART,eFlowCtl)     ((UART)->IER |= (eFlowCtl))
N
N
N/**
N * @brief      Disable RTS/CTS Auto Flow Control
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  eFlowCtl     Flow Control Select
N *                          - UART_IER_AUTO_RTS_EN_Msk : RTS Auto Flow Control 
N *                          - UART_IER_AUTO_CTS_EN_Msk : CTS Auto Flow Control 
N * @return     None
N *                                                           
N * @details    The function is used to disable AutoFlow Control RTS/CTS function.\n
N *             Example: _UART_DISABLE_AUTOFLOW(UART0,UART_AUTO_RTS)
N *
N */    
N#define _UART_DISABLE_AUTOFLOW(UART,eFlowCtl)   ((UART)->IER &= ~(eFlowCtl))
N
N
N
N/**
N * @brief      Get RTS Pin value
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @retval     1 = RTS pin value is HIGH
N * @retval     0 = RTS pin value is LOW
N *                                                           
N * @details    The function is used to get RTS pin value.
N *             Example: _UART_GET_RTSPIN(UART0)
N *
N */
N#define _UART_GET_RTSPIN(UART)   (((UART)->MCR & UART_MCR_RTS_ST_Msk)>> UART_MCR_RTS_ST_Pos)
N
N/**
N * @brief      Get CTS Pin value
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @retval     1 = CTS pin value is HIGH
N * @retval     0 = CTS pin value is LOW
N *                                                           
N * @details    The function is used to get CTS pin value.
N *             Example: _UART_GET_CTSPIN(UART0)
N *
N */
N#define _UART_GET_CTSPIN(UART)   (((UART)->MSR & UART_MSR_CTS_ST_Msk)>> UART_MSR_CTS_ST_Pos)
N
N
N/**
N * @brief      Get LEV_RTS bit settings
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @retval     1 = LEV_RTS bit is set
N * @retval     0 = LEV_RTS bit is clear
N *                                                           
N * @details    The function is used to get LEV_RTS bit settings.
N *             Example: _UART_GET_LEVRTS(UART0)
N *
N */
N#define _UART_GET_LEVRTS(UART)   (((UART)->MCR & UART_MCR_LEV_RTS_Msk)>> UART_MCR_LEV_RTS_Pos)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function Switch                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Switch Function 
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  eFuncSel     Function Select  
N *                          - FUNC_UART : UART function 
N *                          - FUNC_IrDA : IrDA function
N *                          - FUNC_RS485: RS485 function 
N *                          - FUNC_LIN  : LIN function                                    
N.* @return     None
N * @details    The function is used to uart function to Uart,IrDA,RS485 or LIN.\n
N *             Example: _UART_SEL_FUNC(UART_PORT0,FUNC_IrDA)
N *
N */  
N
N#define _UART_SEL_FUNC(UART,eFuncSel)   ((UART)->FUN_SEL = (eFuncSel))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* IrDA Function                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @brief      Initialize IrDA TX configuration
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  bIsInvTx     Invert Tx signal or not   
N *                          - TRUE  : Invert tx signal     
N *                          - FALSE : No invert tx signal  
N *
N * @return     None
N *                                                           
N * @details    The function is used to intialize IrDA TX. It wll switch IrDA mode and 
N *             configure invert tx signal or nor.\n                                              
N *             Example: _UART_SET_IrDA_TXMODE(UART0,FALSE)
N *
N */  
N
N#define _UART_SET_IrDA_TXMODE(UART,bIsInvTx)    ((UART)->IRCR = UART_IRCR_TX_SELECT_Msk|((bIsInvTx)<<UART_IRCR_INV_TX_Pos))
N
N
N/**
N * @brief      Initialize IrDA RX configuration
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  bIsInvRx     Invert Rx signal or not
N *                          - TRUE  : Invert rx signal     
N *                          - FALSE : No invert rx signal  
N * @return     None
N *                                                           
N * @details    The function is used to intialize IrDA RX. It wll switch IrDA mode and 
N *             configure invert rx signal or nor.\n                                              
N *             Example: _UART_SET_IrDA_RXMODE(UART_PORT0,FALSE)
N *
N */  
N
N#define _UART_SET_IrDA_RXMODE(UART,bIsInvRx)    ((UART)->IRCR = (bIsInvRx)<<UART_IRCR_INV_RX_Pos)
N
N
N/**
N * @brief      Enable Rx receive function in RS485 mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to set Rx disable function.\n
N *             Example: _UART_RS485_SET_RXDISABLE(UART0)
N *
N */                                                                                      
N#define _UART_RS485_SET_RXDISABLE(UART)    ((UART)->FCR|= UART_FCR_RX_DIS_Msk)
N
N
N/**
N * @brief      Disable Rx receive function in RS485 mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to Clear Rx disable function.\n
N *             Example: _UART_RS485_CLEAR_RXDISABLE(UART0)
N *
N */                                                                                      
N#define _UART_RS485_CLEAR_RXDISABLE(UART)   ((UART)->FCR&= ~UART_FCR_RX_DIS_Msk) 
N
N
N/**
N * @brief      Enable or Disable Rx receive function in RS485 mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  bIsEnable    Control RX_DISABLE function 
N *                          - TRUE : Enable Rx disable receive function    
N *                          - FALSE : Disable Rx disable receive function 
N * @return     None
N *                                                           
N * @details    The function is used to control Rx disable function.\n
N *             Example: _UART_RS485_RXDISABLE(UART0,TRUE)
N *
N */                                                                                      
N
N#define _UART_RS485_RXDISABLE(UART,bIsEnable)  (bIsEnable)?_UART_RS485_SET_RXDISABLE((UART)):_UART_RS485_CLEAR_RXDISABLE((UART))
N
N
N
N
N
N/**
N * @brief      Clear RS-485 Address Byte Detection Flag
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to write RS485_ADD_DETF_Msk bit is '1' to this bit
N *             Example: _UART_RS485_CLEAR_ADD_DETF(UART0)
N *
N */                                                                                      
N
N#define _UART_RS485_CLEAR_ADD_DETF(UART)   ((UART)->FSR  |= UART_FSR_RS485_ADD_DETF_Msk)
N
N
N   
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* LIN Function                                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Set LIN master mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  BreakLength  Break Length Setting: 
N *                          - 0~15
N * @return     None
N *                                                           
N * @details    The function is used to control UART to be LIN master.\n
N *             Before sending header field,please remember to enable the function.\n
N *             After sending a header to bus,LIN_TX_EN is cleared automatically.\n
N *             Example: _UART_SET_LIN_TXMODE(UART0,12)
N *
N */                                                                                      
N#define _UART_SET_LIN_TXMODE(UART,BreakLength) ((UART)->ALT_CSR = (BreakLength) | UART_ALT_CSR_LIN_TX_EN_Msk)
N
N/**
N * @brief      Set LIN slave mode
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @param[in]  BreakLength  Break Length Setting: 
N *                          - 0~15
N * @return     None
N *                                                           
N * @details    The function is used to control UART to be LIN slave.\n 
N *             Example: _UART_SET_LIN_RXMODE(UART0,12)
N *
N */                                                                                      
N
N#define _UART_SET_LIN_RXMODE(UART,BreakLength) ((UART)->ALT_CSR = (BreakLength) | UART_ALT_CSR_LIN_RX_EN_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART Clock Control                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/                                                                                     
N/**
N * @brief      Enable UART APB Clock 
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to access APBCLK to enable UART APB Clock.
N *             Before using UART, please call the function firstly.\n
N *             Example: _UART_ENABLE_CLOCK(UART0)
N *
N */ 
N#define _UART_ENABLE_CLOCK(UART)   (SYSCLK->APBCLK  |= ( 1<< (SYSCLK_APBCLK_UART0_EN_Pos + (((UART)==(UART0))?0:1))))
N  
N/**
N * @brief      Disable UART APB Clock 
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to access APBCLK to disable UART APB Clock.\n
N *             Example: _UART_DISABLE_CLOCK(UART0)
N *
N */ 
N#define _UART_DISABLE_CLOCK(UART)   (SYSCLK->APBCLK &=~((1<< (SYSCLK_APBCLK_UART0_EN_Pos + (((UART)==(UART0))?0:1)))))
N
N
N/**
N * @brief      Reset UART IP
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to access IPRSTC2 to reset UART IP.\n
N *             Example: UART_ResetIP(UART0)
N *
N */ 
N__INLINE void UART_ResetIP(UART_T* UART)
X__inline void UART_ResetIP(UART_T* UART)
N{
N    SYS->IPRSTC2 |= 1<< (SYS_IPRSTC2_UART0_RST_Pos+ ((UART)==UART0)?0:1) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |= 1<< (16+ ((UART)==((UART_T *) ((( uint32_t)0x40000000) + 0x50000)))?0:1) ;
N    SYS->IPRSTC2 &= ~(1<< (SYS_IPRSTC2_UART0_RST_Pos+ ((UART)==UART0)?0:1)) ;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(1<< (16+ ((UART)==((UART_T *) ((( uint32_t)0x40000000) + 0x50000)))?0:1)) ;
N}     
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Break Control                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/ 
N/**
N * @brief      Set break control bit
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to set BCB bit and force TXD pin to low state.\n
N *             Example: _UART_FORCE_BREAK(UART0)
N *
N */ 
N#define _UART_FORCE_BREAK(UART)           ((UART)->LCR |= UART_LCR_BCB_Msk)
N
N/**
N * @brief      Clear break control bit
N *
N * @param[in]  UART         Structure pointer of UART Channel
N *                          - UART0 : UART Channel 0
N *                          - UART1 : UART Channel 1
N * @return     None
N *                                                           
N * @details    The function is used to clear BCB bit and force TXD pin return normal state.\n
N *             Example: _UART_CLEAR_BREAK(UART0)
N *
N */ 
N#define _UART_CLEAR_BREAK(UART)           ((UART)->LCR &= ~UART_LCR_BCB_Msk)
N
N
N
N
N__INLINE int32_t UART_Write(UART_T *UART,uint8_t *pu8TxBuf,uint32_t u32WriteBytes)
X__inline int32_t UART_Write(UART_T *UART,uint8_t *pu8TxBuf,uint32_t u32WriteBytes)
N{
N    uint32_t  u32Count, u32delayno;
N
N    for (u32Count=0; u32Count != u32WriteBytes; u32Count++)
N    {
N       u32delayno = 0;
N       while (((UART)->FSR & UART_FSR_TE_FLAG_Msk) == 0)  /* Wait Tx empty and Time-out manner */
X       while (((UART)->FSR & (1ul << 28)) == 0)   
N       {
N            u32delayno++;
N            if ( u32delayno >= 0x40000000 )             
N               return FALSE;               
X               return 0;               
N       }
N       _UART_SENDBYTE((UART),pu8TxBuf[u32Count]);        /* Send UART Data from buffer */
X       (((UART))->THR = (pu8TxBuf[u32Count]));         
N    }
N    return TRUE;
X    return 1;
N}
N
N__INLINE int32_t UART_Read(UART_T *UART,uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
X__inline int32_t UART_Read(UART_T *UART,uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
N{
N    uint32_t u32Count, u32delayno;
N
N    for (u32Count=0; u32Count != u32ReadBytes; u32Count++)
N    {
N         u32delayno = 0;
N         while ((UART)->FSR & UART_FSR_RX_EMPTY_Msk)
X         while ((UART)->FSR & (1ul << 14))
N         {
N            u32delayno++;        
N            if ( u32delayno >= 0x40000000 )        
N                return FALSE;               
X                return 0;               
N         }
N         _UART_RECEIVEBYTE((UART),pu8RxBuf[u32Count]);          /* Get Data from UART RX  */
X         ((pu8RxBuf[u32Count]) = ((UART))->RBR);           
N    }
N    return TRUE;
X    return 1;
N}
N
N
N/**
N  * @} End of UART Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif
N
N
N
N
N
N
N
N
N
N
N
L 6306 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "I2S.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\I2S.h" 1
N/**************************************************************************//**
N * @file     I2S.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series I2S Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2S_H__
N#define __I2S_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup I2S_FUNC I2S Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* I2S_CON constant definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2S_CON_FMT_PCMA        0x01000000UL
N#define I2S_CON_FMT_PCMB        0x01000080UL
N#define I2S_CON_FMT_I2S         0x00000000UL
N#define I2S_CON_FMT_MSB_JUST    0x00000080UL
N#define I2S_CON_WORDWIDTH_8     0x00000000UL
N#define I2S_CON_WORDWIDTH_16    0x00000010UL
N#define I2S_CON_WORDWIDTH_24    0x00000020UL
N#define I2S_CON_WORDWIDTH_32    0x00000030UL
N#define I2S_CON_MUTE            0x00000008UL
N#define I2S_CON_PLAY_EN         0x00000002UL
N#define I2S_CON_REC_EN          0x00000004UL
N#define I2S_CON_ENABLE          0x00000001UL
N#define I2S_CON_MONO_LEFT   0x00800040UL
N#define I2S_CON_MONO_RIGHT  0x00000040UL
N#define I2S_CON_STEREO      0x00000000UL
N#define I2S_CON_RX_TH(x)    (((x)-1) << 12) // x = 1 ~ 8   
N#define I2S_CON_TX_TH(x)    ((x) << 9)      // x = 0 ~ 7
N#define I2S_CON_SLAVE       0x00000100UL
N#define I2S_CON_MCLK_EN     0x00008000UL
N#define I2S_CON_MASTER      0x00000000UL
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* I2S_CLKDIV constant definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2S_CLKDIV_BCLK(x)  (((x)/2 - 1) << 8)   /*!< I2S_CLKDIV setting for I2S BCLK clock divider. It could be 2,4~512 */
N#define I2S_CLKDIV_MCLK(x)  ((x)/2)              /*!< I2S_CLKDIV setting for I2S MCLK clock divider. It could be 0,2,4 ~ 14 */
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#if 0
S/**
S * @details    Configure the user-specified SPI port as a master
S */
S#define _SPI_SET_MASTER_MODE(port) ((port)->CNTRL &= (~SPI_CNTRL_SLAVE_MODE))
S
S
S
S
S/**
S * @brief      Get SPI clock1 frequency (Hz).
S *
S * @param[in]  pSpiPort   Specify the SPI port.
S *
S * @return     SPI clock1 frequency.
S *
S * @details    This function calculates the clock rate of clock1 (SPI engine clock).
S *
S */
Sstatic __INLINE uint32_t SPI_GetClock1Freq(SPI_T * pSpiPort)
S{
S    return (SystemCoreClock>>1)/((pSpiPort->DIVIDER & 0xFFFF)+1);
S}
S
N#endif
N
N/**
N  * @} End of I2S Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N#endif  //__I2S_H__
N
L 6307 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "USB.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\USB.h" 1
N/**************************************************************************//**
N * @file     USB.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 12/08/06 6:45p $
N * @brief    NUC200 Series USB Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef _USBD_H
N#define _USBD_H
N
N#include "NUC200Series.h"
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup USBD_FUNC   USB Device Function Interface
N  * @{
N  */
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N//E_USBD_NULL_POINTER             Callback function is NULL.
N//E_USBD_INVALID_EP_NUM           EndPoint number error.
N//E_USBD_SIZE_TOO_LONG            Data size is too long.
N//E_USBD_VALUE_INVALID            Input argument is invalid.  
N
N#define E_USBD_NULL_POINTER       -1
N#define E_USBD_INVALID_EP_NUM     -2
N#define E_USBD_SIZE_TOO_LONG      -3
N#define E_USBD_VALUE_INVALID      -4
N
N
N/* Define USB Register Address */
N#define USBD_INTEN          (USBD_BASE + 0x00)
N#define USBD_INTSTS         (USBD_BASE + 0x04)
N#define USBD_FADDR          (USBD_BASE + 0x08)
N#define USBD_EPSTS          (USBD_BASE + 0x0C)
N#define USBD_ATTR           (USBD_BASE + 0x10)
N#define USBD_FLDET          (USBD_BASE + 0x14)
N#define USBD_BUFSEG         (USBD_BASE + 0x18)
N#define USBD_BUFSEG0        (USBD_BASE + 0x20)
N#define USBD_MXPLD0         (USBD_BASE + 0x24)
N#define USBD_CFG0           (USBD_BASE + 0x28)
N#define USBD_CFGP0          (USBD_BASE + 0x2C)
N#define USBD_BUFSEG1        (USBD_BASE + 0x30)
N#define USBD_MXPLD1         (USBD_BASE + 0x34)
N#define USBD_CFG1           (USBD_BASE + 0x38)
N#define USBD_CFGP1          (USBD_BASE + 0x3C)
N#define USBD_BUFSEG2        (USBD_BASE + 0x40)
N#define USBD_MXPLD2         (USBD_BASE + 0x44)
N#define USBD_CFG2           (USBD_BASE + 0x48)
N#define USBD_CFGP2          (USBD_BASE + 0x4C)
N#define USBD_BUFSEG3        (USBD_BASE + 0x50)
N#define USBD_MXPLD3         (USBD_BASE + 0x54)
N#define USBD_CFG3           (USBD_BASE + 0x58)
N#define USBD_CFGP3          (USBD_BASE + 0x5C)
N#define USBD_BUFSEG4        (USBD_BASE + 0x60)
N#define USBD_MXPLD4         (USBD_BASE + 0x64)
N#define USBD_CFG4           (USBD_BASE + 0x68)
N#define USBD_CFGP4          (USBD_BASE + 0x6C)
N#define USBD_BUFSEG5        (USBD_BASE + 0x70)
N#define USBD_MXPLD5         (USBD_BASE + 0x74)
N#define USBD_CFG5           (USBD_BASE + 0x78)
N#define USBD_CFGP5          (USBD_BASE + 0x7C)
N#define USBD_DRVSE0         (USBD_BASE + 0x90)
N#define USBD_SRAM_BASE       (USBD_BASE + 0x100)
N
N#define INTEN_INNAK         0x00008000
N#define INTEN_WAKEUPEN      0x00000100
N#define INTEN_WAKEUP        0x00000008
N#define INTEN_FLDET         0x00000004
N#define INTEN_USB           0x00000002
N#define INTEN_BUS           0x00000001
N
N#define INTSTS_SETUP        0x80000000
N#define INTSTS_EPTF5        0x00200000
N#define INTSTS_EPTF4        0x00100000
N#define INTSTS_EPTF3        0x00080000
N#define INTSTS_EPTF2        0x00040000
N#define INTSTS_EPTF1        0x00020000
N#define INTSTS_EPTF0        0x00010000
N#define INTSTS_WAKEUP       0x00000008
N#define INTSTS_FLDET        0x00000004
N#define INTSTS_USB          0x00000002
N#define INTSTS_BUS          0x00000001
N
N#define ATTR_BYTEM          0x00000400
N#define ATTR_PWRDN          0x00000200
N#define ATTR_DPPU_EN        0x00000100
N#define ATTR_USB_EN         0x00000080
N#define ATTR_RWAKEUP        0x00000020
N#define ATTR_PHY_EN         0x00000010
N#define ATTR_TIMEOUT        0x00000008
N#define ATTR_RESUME         0x00000004
N#define ATTR_SUSPEND        0x00000002
N#define ATTR_USBRST         0x00000001
N
N#define CFG_CSTALL          0x00000200
N#define CFG_DSQ_SYNC        0x00000080
N#define CFG_STATE           0x00000060
N#define CFG_EPT_IN          0x00000040          /*  10: IN endpoint  */
N#define CFG_EPT_OUT         0x00000020          /*  01: Out endpoint */
N#define CFG_ISOCH           0x00000010
N#define CFG_EPT             0x0000000F
N
N#define CFGP_SSTALL         0x00000002
N#define CFGP_CLRRDY         0x00000001
N
N#define EPSTS_IN_ACK        0x00            /*  000: In ACK */
N#define EPSTS_IN_NAK        0x10            /*  001: In NAK */
N#define EPSTS_OUT0_ACK      0x20            /*  010: Out 0 ACK */
N#define EPSTS_OUT1_ACK      0x60            /*  110: Out 1 ACK */
N#define EPSTS_SETUP_ACK     0x30            /*  011: Setup ACK */
N#define EPSTS_ISO           0x70            /*  111: Isochronous translation end */
N#define EPSTS_STS           0x70            /*  A mask to get EP state */
N
N#define _USBD_DATA0(Data)           ((Data) & 0x37F)
N#define _USBD_DATA1(Data)           ((Data) | 0x80)
N#define _USBD_ENABLE_MISC_INT(u32Flags)   outp32(USBD_INTEN, (u32Flags) & (INTEN_WAKEUP + INTEN_FLDET + INTEN_USB + INTEN_BUS))
N
N#define _USBD_ENABLE_WAKEUP()       USBD->INTEN |= USBD_INTEN_WAKEUP_EN_Msk
N#define _USBD_DISABLE_WAKEUP()      USBD->INTEN &= (~USBD_INTEN_WAKEUP_EN_Msk)
N#define _USBD_ENABLE_WAKEUP_INT()   USBD->INTEN |= USBD_INTEN_WAKEUP_IE_Msk
N#define _USBD_DISABLE_WAKEUP_INT()  USBD->INTEN &= (~USBD_INTEN_WAKEUP_IE_Msk)
N#define _USBD_ENABLE_FLDET_INT()    USBD->INTEN |= USBD_INTEN_FLDET_IE_Msk
N#define _USBD_DISABLE_FLDET_INT()   USBD->INTEN &= (~USBD_INTEN_FLDET_IE_Msk)
N#define _USBD_ENABLE_USB_INT()      USBD->INTEN |= USBD_INTEN_USB_IE_Msk
N#define _USBD_DISABLE_USB_INT()     USBD->INTEN &= (~USBD_INTEN_USB_IE_Msk)
N#define _USBD_ENABLE_BUS_INT()      USBD->INTEN |= USBD_INTEN_BUS_IE_Msk
N#define _USBD_DISABLE_BUS_INT()     USBD->INTEN &= (~USBD_INTEN_BUS_IE_Msk)
N
N/* Respond EPx (x = 0 ~ 5) STALL packet */
N#define _USBD_CLEAR_EP_READY_AND_TRIG_STALL(u32EpId)      outp32(USBD_CFGP0+(0x10*(u32EpId)), (inp32(USBD_CFGP0+(0x10*(u32EpId))) | (CFGP_SSTALL | CFGP_CLRRDY)))
N    
N/* Clear EPx (x = 0 ~ 5) In/Out ready */
N#define _USBD_CLEAR_EP_READY(u32EpId)                     outp32(USBD_CFGP0+(0x10*(u32EpId)), (inp32(USBD_CFGP0+(0x10*(u32EpId))) | CFGP_CLRRDY))
N
N/* Specify USB buffer for SETUP packet */
N#define _USBD_SET_SETUP_BUF(u32BufAddr)                   outp32(USBD_BUFSEG, (u32BufAddr) - USBD_SRAM_BASE)
N
N/* Specify USB buffer for EPx (x = 0 ~ 5) */
N#define _USBD_SET_EP_BUF(u32EpId, u32BufAddr)             outp32(USBD_BUFSEG0+(0x10 * (u32EpId)), (u32BufAddr) - USBD_SRAM_BASE)
N        
N/* Trigger next transaction for EPx (x = 0 ~ 5) */
N#define _USBD_TRIG_EP(u32EpId, u32TrigSize)               outp32((USBD_MXPLD0+(0x10*(u32EpId))), (u32TrigSize))
N
N/* Set toggle bit for EPx (x = 0 ~ 5) */
N#define _USBD_SET_EP_TOG_BIT(u32EpId, bData0)             outp32(USBD_CFG0+(0x10*(u32EpId)), bData0 ? _USBD_DATA0(inp32(USBD_CFG0+(0x10*(u32EpId)))) : _USBD_DATA1(inp32(USBD_CFG0+(0x10*(u32EpId)))))
N
N/* Get Data Out size for EPx (x = 0 ~ 5) */
N#define _USBD_GET_EP_DATA_SIZE(u32EpId)                   inp8(USBD_MXPLD0 + (0x10*(u32EpId)))
N
N#define _USBD_SET_EVENT_FLAG(u32Data)                     outp32((&USBD->INTSTS), (u32Data))  
N
N#define _USBD_GET_EVENT_FLAG()                            inp32((&USBD->INTSTS))
N
N/* Clear EPx (x = 0 ~ 5) Force device to response STALL */
N#define _USBD_CLEAR_EP_STALL(u32EpId)                     outp32(USBD_CFGP0+(0x10 * (u32EpId)), inp32(USBD_CFGP0+(0x10 * (u32EpId))) & ~CFGP_SSTALL)
N    
N/* Trigger EPx (x = 0 ~ 5) Force device to response STALL */
N#define _USBD_TRIG_EP_STALL(u32EpId)                      outp32(USBD_CFGP0+(0x10*(u32EpId)), inp32(USBD_CFGP0+(0x10*(u32EpId))) | CFGP_SSTALL)
N
N/* Clear EPx (x = 0 ~ 5) Specify Data 0 or 1 after IN token toggle automatically after host ACK */
N#define _USBD_CLEAR_EP_DSQ_SYNC(u32EpId)                  outp32(USBD_CFG0+(0x10*(u32EpId)), inp32(USBD_CFG0+(0x10*(u32EpId))) & ~CFG_DSQ_SYNC)
N
N/* Configure Set CFGx (x = 0 ~ 5) */
N#define _USBD_SET_CFG(u32CFGNum,u32Data)                  outp32(USBD_CFG0+(0x10*(u32CFGNum)), (u32Data) & 0x03FF)
N
N/* Configure Get CFGx (x = 0 ~ 5) */    
N#define _USBD_GET_CFG(u32CFGNum)                          (inp32(USBD_CFG0 + (u32CFGNum) * 0x10) & 0x03FF)
N
N/* Set Function Address */
N#define _USBD_SET_FADDR(u32Addr)                          (USBD->FADDR = u32Addr)
N
N/* Get Function Address */  
N#define _USBD_GET_FADDR()                                 (USBD->FADDR)
N
N/* Get System states */
N#define _USBD_GET_EPSTS()                                 inp32((&USBD->EPSTS))
N
N/* Configure Set CFGPx (x = 0 ~ 5) */
N#define _USBD_SET_CFGP(u8CFGPNum, u32Data)                outp32(USBD_CFGP0+(0x10 * (u8CFGPNum)), (u32Data) & 0x03)
N
N#define _USBD_SET_CFG_EP0(u32Data)                        outp32(USBD_CFGP0, (u32Data) & 0x03)
N
N#define _USBD_SET_CFG_EP1(u32Data)                        outp32(USBD_CFGP1, (u32Data) & 0x03)
N
N#define _USBD_SET_CFG_EP2(u32Data)                        outp32(USBD_CFGP2, (u32Data) & 0x03)
N
N#define _USBD_SET_CFG_EP3(u32Data)                        outp32(USBD_CFGP3, (u32Data) & 0x03)
N
N#define _USBD_SET_CFG_EP4(u32Data)                        outp32(USBD_CFGP4, (u32Data) & 0x03)
N
N#define _USBD_SET_CFG_EP5(u32Data)                        outp32(USBD_CFGP5, (u32Data) & 0x03)
N
N/* Configure Get CFGPx (x = 0 ~ 5) */
N#define _USBD_GET_CFGP(u32CFGPNum)                        (inp32(USBD_CFGP0+(0x10 * (u32CFGPNum))) & 0x03)
N 
N/* Enable USB , PHY and use remote wake-up */
N#define _USBD_ENABLE_USB()                                outp32((&USBD->ATTR), 0x7D0)
N
N/* Disable USB, PHY and use remote wake-up */
N#define _USBD_DISABLE_USB()                               outp32((&USBD->ATTR), 0x760)
N
N/* Disable PHY and don't use remote wake-up */
N#define _USBD_DISABLE_PHY()                               outp32((&USBD->ATTR), 0x7C0)
N
N#define _USBD_ENABLE_SE0()                                (USBD->DRVSE0 = 1)
N
N#define _USBD_DISABLE_SE0()                               (USBD->DRVSE0 = 0)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB Request                                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N/* Request Type */
N#define REQ_STANDARD        0x00
N#define REQ_CLASS           0x20
N#define REQ_VENDOR          0x40
N
N/* Request */
N#define GET_STATUS          0x00
N#define CLEAR_FEATURE       0x01
N
N#define SET_FEATURE         0x03
N
N#define SET_ADDRESS         0x05
N#define GET_DESCRIPTOR      0x06
N#define SET_DESCRIPTOR      0x07
N#define GET_CONFIGURATION   0x08
N#define SET_CONFIGURATION   0x09
N#define GET_INTERFACE       0x0A
N#define SET_INTERFACE       0x0B
N#define SYNC_FRAME          0x0C
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB Descriptor Type                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DESC_DEVICE         0x01
N#define DESC_CONFIG         0x02
N#define DESC_STRING         0x03
N#define DESC_INTERFACE      0x04
N#define DESC_ENDPOINT       0x05
N#define DESC_QUALIFIER      0x06
N#define DESC_OTHERSPEED     0x07
N/* For HID */
N#define DESC_HID            0x21
N#define DESC_HID_RPT        0x22
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB Descriptor Length                                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define LEN_DEVICE          18
N#define LEN_CONFIG          9
N#define LEN_INTERFACE       9
N#define LEN_ENDPOINT        7
N/* For HID */
N#define LEN_HID             0x09
N
N/* USB Endpoint Type */
N#define EP_ISO              0x01
N#define EP_BULK             0x02
N#define EP_INT              0x03
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB Feature Selector                                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FEATURE_DEVICE_REMOTE_WAKEUP    0x01
N#define FEATURE_ENDPOINT_HALT           0x00
N
N#define EP_INPUT                        0x80
N#define EP_OUTPUT                       0x00
N#define MAX_EP_ID                       6
N#define USB_DATA_QUEUE_SIZE             16
N#define USB_SRAM_ADDR g_UsbSramBase
N#define USB_BUF_SETUP                   USBD_GetSetupBuffer()
N
N#define USBD_EVENT_FLAG_ATTACH        0x00000001
N#define USBD_EVENT_FLAG_DETACH        0x00000002
N#define USBD_EVENT_FLAG_BUS_RESET     0x00000004
N#define USBD_EVENT_FLAG_BUS_SUSPEND   0x00000008
N#define USBD_EVENT_FLAG_BUS_RESUME    0x00000010
N#define USBD_EVENT_FLAG_SETUP         0x00000020
N    
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB Device state                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum
N{
N    eUSBD_DETACHED    = 0,
N    eUSBD_ATTACHED    = 0x00000001,
N    eUSBD_POWERED     = eUSBD_ATTACHED + 0x00000002,
N    eUSBD_DEFAULT     = eUSBD_POWERED  + 0x00000004,
N    eUSBD_ADDRESS     = eUSBD_DEFAULT  + 0x00000008,
N    eUSBD_CONFIGURED  = eUSBD_ADDRESS  + 0x00000010,
N    eUSBD_SUSPENDED   = 0x00000020
N
N} E_USBD_STATE;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB Vender_info descriptor structure                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint8_t byLength;
N    uint8_t byDescType;
N    uint16_t au16UnicodeString[100];
N    
N} S_USBD_STRING_DESC;
N
Ntypedef S_USBD_STRING_DESC    S_STRING_DESC;
N
Ntypedef struct
N{
N    uint16_t u16VendorId;
N    uint16_t u16ProductId;
N    const S_USBD_STRING_DESC *psVendorStringDesc;
N    const S_USBD_STRING_DESC *psProductStringDesc;
N
N} S_USBD_VENDOR_INFO;
N
Ntypedef S_USBD_VENDOR_INFO    S_VENDOR_INFO;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Typedef USB Callback function                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef void (*PFN_USBD_ATTACH_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_DETACH_CALLBACK)(void *);
N
Ntypedef void (*PFN_USBD_BUS_RESET_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_BUS_SUSPEND_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_BUS_RESUME_CALLBACK)(void *);
N
Ntypedef void (*PFN_USBD_SETUP_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_EP_IN_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_EP_OUT_CALLBACK)(void *);
N
Ntypedef void (*PFN_USBD_CTRL_SETUP_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_CTRL_DATA_IN_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_CTRL_DATA_OUT_CALLBACK)(void *);
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Typedef ISR USB Callback function                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef void (*PFN_USBD_ISR_ATTACH_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_ISR_DETACH_CALLBACK)(void *);
N
Ntypedef void (*PFN_USBD_ISR_BUS_RESET_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_ISR_BUS_SUSPEND_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_ISR_BUS_RESUME_CALLBACK)(void *);
N
Ntypedef void (*PFN_USBD_ISR_SETUP_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_ISR_EP_IN_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_ISR_EP_OUT_CALLBACK)(void *);
N
Ntypedef void (*PFN_USBD_CALLBACK)(void *);
Ntypedef void (*PFN_USBD_INTCALLBACK)(void *);
Ntypedef int32_t (*PFN_USBD_COMPARE)(uint8_t);
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB Control callback function structure                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint8_t u8RequestType;
N    uint8_t u8Request;
N    PFN_USBD_CTRL_SETUP_CALLBACK      pfnCtrlSetupCallback;
N    PFN_USBD_CTRL_DATA_IN_CALLBACK    pfnCtrlDataInCallback;
N    PFN_USBD_CTRL_DATA_OUT_CALLBACK   pfnCtrlDataOutCallback;
N    void *                              pVoid;
N} S_USBD_CTRL_CALLBACK_ENTRY;
N
Ntypedef struct
N{
N    int32_t                             bReg;
N    S_USBD_CTRL_CALLBACK_ENTRY        sCtrlCallbackEntry;
N} S_USBD_CTRL_CALLBACK_ENTRY_REG;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* EP ctrl structure. USB class must implement this structure                                              */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint32_t u32EpNum;
N    uint32_t u32MaxPacketSize; 
N    uint8_t *u8SramBuffer;
N}S_USBD_EP_CTRL;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Misc and USB event call back function                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    PFN_USBD_CALLBACK apfnCallback;
N    void *              apCallbackArgu;
N}S_USBD_EVENT_PROCESS;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* The interface between USB class and USB driver                                                          */
N/* USB class implement this structure and register to USB driver                                           */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    void * device;
N    PFN_USBD_CALLBACK pfnStart;       /* The callback function when set configuration or set interface */
N    PFN_USBD_COMPARE  pfnCompare;
N    void * pVoid;
N}S_USBD_CLASS;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* USB driver device                                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint32_t u32ATTR;
N    uint32_t u32EPSTS;
N    uint32_t u32FLDET;
N    uint32_t u32INTSTS;
N
N    int32_t  abData0[MAX_EP_ID];  /* Index is EP identity   */
X    int32_t  abData0[6];   
N    S_USBD_EP_CTRL sEpCrl[MAX_EP_ID+1];
X    S_USBD_EP_CTRL sEpCrl[6+1];
N    int32_t  eUsbState;           /* E_USBD_STATE */
N
N    uint16_t u16MiscEventFlags;
N
N    uint16_t u16EPEventFlags;
N
N    S_USBD_CTRL_CALLBACK_ENTRY    *pCtrlCallback;
N    uint32_t CtrlCallbackSize;
N    uint8_t  au8Setup[8];
N    uint8_t  u8UsbAddress;
N    uint8_t  u8UsbConfiguration;
N        
N    int32_t  bSelfPowered;  /* TRUE : Self-Powereded, FALSE : BUS-Powereded */
N    int32_t  bRemoteWakeup; /* TRUE : Support RemoteWakeup, FALSE : no support */
N    uint8_t  u8MaxPower;        /* Maximum MaxPower 0xFA (500mA), default is 0x32 (100mA) */
N        
N    S_USBD_CLASS *psUsbClass;
N} S_USBD_DEVICE;
N
N
N/* EP ctrl structure;descript EP */
Nextern S_USBD_EP_CTRL sEpDescription[];
N/* BUS event call back function; USB class must implement */
Nextern S_USBD_EVENT_PROCESS g_sBusOps[];
N/* USB event call back function; USB class must implement */
Nextern S_USBD_EVENT_PROCESS g_sUsbOps[];
Nextern uint32_t CFG_EP_SETTING[6];  /* CFGx register setting value */
Nextern PFN_USBD_INTCALLBACK g_FnIntCallBack;  /* Interrupt call back  */
Nextern S_USBD_DEVICE gsUsbDevice;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Get/Set USB device state                                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N/* DATA0 or DATA1 Out transaction when Data Out ACK happens */
Nint32_t USBD_IsData0Out(uint32_t u32EpId);
N
N/* Get USB device state. */
NE_USBD_STATE USBD_GetUsbState(void);
N
N/* Set USB device state. */
Nvoid USBD_SetUsbState(E_USBD_STATE eUsbState);
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define USBD READ/WRITE USB BUFFER                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define _USBD_READ_USB_BUF(UsbBuf, Mem, Len) \
N    memcpy ((void *) (Mem), (void *) (UsbBuf), (Len))
X#define _USBD_READ_USB_BUF(UsbBuf, Mem, Len)     memcpy ((void *) (Mem), (void *) (UsbBuf), (Len))
N
N#define _USBD_WRITE_USB_BUF(UsbBuf, Mem, Len) \
N    memcpy ((void *) (UsbBuf), (void *) (Mem), (Len))
X#define _USBD_WRITE_USB_BUF(UsbBuf, Mem, Len)     memcpy ((void *) (UsbBuf), (void *) (Mem), (Len))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* APIs declare                                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t USBD_GetVersion(void);
Nint32_t  USBD_Open(void * pVoid);
Nvoid     USBD_PreDispatchEvent(void);
Nvoid     USBD_DispatchEvent(void);
Nvoid     USBD_Close(void);
Nvoid     USBD_BusResetCallback(void * pVoid);
Nuint32_t USBD_GetSetupBuffer(void);
Nvoid *   USBD_InstallClassDevice(S_USBD_CLASS *sUsbClass);
Nint32_t  USBD_InstallCtrlHandler(void * *device, S_USBD_CTRL_CALLBACK_ENTRY *psCtrlCallbackEntry, uint32_t u32RegCnt);
Nint32_t  USBD_DataOutTrigger(uint32_t u32EpNum, uint32_t u32Size);
Nuint8_t* USBD_GetOutData(uint32_t u32EpNum, uint32_t *u32Size);
Nint32_t  USBD_DataIn(uint32_t u32EpNum, const uint8_t * u8Buffer, uint32_t u32Size);
Nvoid     USBD_CtrlSetupAck(void * pArgu);
Nvoid     USBD_CtrlDataInAck(void * pArgu);
Nvoid     USBD_CtrlDataOutAck(void * pArgu);
Nvoid     USBD_ClrCtrlReady(void);
Nvoid     USBD_ClrCtrlReadyAndTrigStall(void);
Nvoid     USBD_CtrlDataInDefault(void * pVoid);
Nvoid     USBD_CtrlDataOutDefault(void * pVoid);
Nvoid     USBD_Reset(uint32_t u32EpNum);
Nint32_t USBD_GetEpId(uint32_t u32EpNum);
Nint32_t USBD_GetEpIdentity(uint32_t u32EpNum, uint32_t u32EPAttr);
Nvoid     USBD_EnableRemoteWakeup(void);
Nvoid     USBD_DisableRemoteWakeup(void);
Nvoid     USBD_EnableSelfPower (void);
Nvoid     USBD_DisableSelfPower (void);
Nint32_t  USBD_IsSelfPowerEnabled (void);          /* TRUE : Self-Powereded, FALSE : BUS-Powereded */
Nvoid     USBD_EnableRemoteWakeup(void);
Nvoid     USBD_DisableRemoteWakeup(void);
Nint32_t  USBD_IsRemoteWakeupEnabled (void);       /* TRUE : Support RemoteWakeup, FALSE : not support */
Nint32_t  USBD_SetMaxPower(uint32_t u32MaxPower);  /* Maximum MaxPower 0xFA (500mA), default is 0x32 (100mA) */
Nint32_t  USBD_GetMaxPower(void);                  /* Maximum MaxPower 0xFA (500mA), default is 0x32 (100mA)   */
N
Nvoid USBD_CtrlSetupSetAddress(void * pVoid);
Nvoid USBD_CtrlSetupClearSetFeature(void * pVoid);
Nvoid USBD_CtrlSetupGetConfiguration(void * pVoid);
Nvoid USBD_CtrlSetupGetStatus(void * pVoid);
Nvoid USBD_CtrlSetupGetInterface(void * pVoid);
Nvoid USBD_CtrlSetupSetInterface(void * pVoid);
Nvoid USBD_CtrlSetupSetConfiguration(void * pVoid);
Nvoid USBD_CtrlDataInSetAddress(void * pVoid);
N
Nint32_t USBD_IsData0(uint32_t u32EpId);
N
Nvoid USBD_EnableUsb(S_USBD_DEVICE *psDevice);
Nvoid USBD_DisableUsb(S_USBD_DEVICE *psDevice);
Nvoid USBD_PreDispatchWakeupEvent(S_USBD_DEVICE *psDevice);
Nvoid USBD_PreDispatchFDTEvent(S_USBD_DEVICE *psDevice);
Nvoid USBD_PreDispatchEPEvent(S_USBD_DEVICE *psDevice);
Nvoid USBD_PreDispatchBusEvent(S_USBD_DEVICE *psDevice);
Nvoid USBD_DispatchWakeupEvent(S_USBD_DEVICE *psDevice);
Nvoid USBD_DispatchMiscEvent(S_USBD_DEVICE *psDevice);
Nvoid USBD_DispatchEPEvent(S_USBD_DEVICE *psDevice);
Nvoid USBD_memcpy(uint8_t *pi8Dest, uint8_t *pi8Src, uint32_t u32Size);
Nuint32_t USBD_GetFreeSRAM(void);
N    
N#ifdef __cplusplus
S}
N#endif
N
N
N
N/**
N  * @} End of USB Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif 
N
N
N
L 6308 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "PDMA.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\PDMA.h" 1
N/**************************************************************************//**
N * @file     PDMA.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 12/08/06 8:08p $
N * @brief    NUC200 Series PDMA Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __PDMA_H__
N#define __PDMA_H__
N
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup PDMA_FUNC PDMA Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PDMA_CSRx constants definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_CSR_PDMACEN            (1UL << 0)  /*!< PDMA_CSRx setting for PDMA channel enable */
N#define PDMA_CSR_SW_RST             (1UL << 1)  /*!< PDMA_CSRx setting for Software Engine Reset */
N#define PDMA_CSR_MODE_SEL_M2M       (0)         /*!< PDMA_CSRx setting for PDMA Mode Selection as Memory to Memory*/
N#define PDMA_CSR_MODE_SEL_P2M       (1UL << 2)  /*!< PDMA_CSRx setting for PDMA Mode Selection as Peripheral to Memory*/
N#define PDMA_CSR_MODE_SEL_M2P       (2UL << 2)  /*!< PDMA_CSRx setting for PDMA Mode Selection as Memory to Peripheral*/
N#define PDMA_CSR_SAD_SEL_INCREASE   (0)         /*!< PDMA_CSRx setting for Transfer Source Address Direction Selection as increase*/
N#define PDMA_CSR_SAD_SEL_FIXED      (2UL << 4)  /*!< PDMA_CSRx setting for Transfer Source Address Direction Selection as fixed*/
N#define PDMA_CSR_DAD_SEL_INCREASE   (0)         /*!< PDMA_CSRx setting for Transfer Destination Address Direction Selection as increase*/
N#define PDMA_CSR_DAD_SEL_FIXED      (2UL << 6)  /*!< PDMA_CSRx setting for Transfer Destination Address Direction Selection as fixed*/
N#define PDMA_CSR_APB_TWS_32BITS     (0)         /*!< PDMA_CSRx setting for Peripheral Transfer Width Selection as 32-bits*/
N#define PDMA_CSR_APB_TWS_8BITS      (1UL << 19) /*!< PDMA_CSRx setting for Peripheral Transfer Width Selection as 8-bits*/
N#define PDMA_CSR_APB_TWS_16BITS     (2UL << 19) /*!< PDMA_CSRx setting for Peripheral Transfer Width Selection as 16-bits*/
N#define PDMA_CSR_TRIG_EN            (1UL << 23) /*!< PDMA_CSRx setting for Trigger Enable*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PDMA_IERx constants definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_IER_TABORT_IE_ENABLE   (1UL << 0) /*!< PDMA_IERx setting for PDMA Read/Write Target Abort Interrupt Enable*/
N#define PDMA_IER_BLKD_IE_ENABLE     (1UL << 1) /*!< PDMA_IERx setting for PDMA Block Transfer Done Interrupt Enable*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PDMAGCR_GCRCSR constants definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMAGCR_CLK0_EN     (1UL << 8)  /*!< PDMA_GCRCSR setting for PDMA Controller Channel 0 Clock Enable Control*/
N#define PDMAGCR_CLK1_EN     (1UL << 9)  /*!< PDMA_GCRCSR setting for PDMA Controller Channel 1 Clock Enable Control*/
N#define PDMAGCR_CLK2_EN     (1UL << 10) /*!< PDMA_GCRCSR setting for PDMA Controller Channel 2 Clock Enable Control*/
N#define PDMAGCR_CLK3_EN     (1UL << 11) /*!< PDMA_GCRCSR setting for PDMA Controller Channel 3 Clock Enable Control*/
N#define PDMAGCR_CLK4_EN     (1UL << 12) /*!< PDMA_GCRCSR setting for PDMA Controller Channel 4 Clock Enable Control*/
N#define PDMAGCR_CLK5_EN     (1UL << 13) /*!< PDMA_GCRCSR setting for PDMA Controller Channel 5 Clock Enable Control*/
N#define PDMAGCR_CLK6_EN     (1UL << 14) /*!< PDMA_GCRCSR setting for PDMA Controller Channel 6 Clock Enable Control*/
N#define PDMAGCR_CLK7_EN     (1UL << 15) /*!< PDMA_GCRCSR setting for PDMA Controller Channel 7 Clock Enable Control*/
N#define PDMAGCR_CLK8_EN     (1UL << 16) /*!< PDMA_GCRCSR setting for PDMA Controller Channel 8 Clock Enable Control*/
N
N#define PDMAGCR_CRC_CLK_EN  (1UL << 24) /*!< PDMA_GCRCSR setting for CRC Controller Clock Enable Control*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* CRC CTL Constants Definitions                                                                           */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CTL_CRC_MODE_CCITT          0x00000000UL  /*!< CRC Polynomial Mode is CRC-CCITT                        */
N#define CRC_CTL_CRC_MODE_CRC8           0x40000000UL  /*!< CRC Polynomial Mode is CRC-8                            */
N#define CRC_CTL_CRC_MODE_CRC16          0x80000000UL  /*!< CRC Polynomial Mode is CRC-16                           */
N#define CRC_CTL_CRC_MODE_CRC32          0xC0000000UL  /*!< CRC Polynomial Mode is CRC-32                           */
N#define CRC_CTL_CPU_WDLEN_8             0x00000000UL  /*!< CPU Write Data Length is 8-bit mode                     */
N#define CRC_CTL_CPU_WDLEN_16            0x10000000UL  /*!< CPU Write Data Length is 16-bit mode                    */
N#define CRC_CTL_CPU_WDLEN_32            0x20000000UL  /*!< CPU Write Data Length is 32-bit mode                    */
N#define CRC_CTL_CHECKSUM_COM_EN         0x08000000UL  /*!< Enable 1's complement for CRC checksum                  */
N#define CRC_CTL_WDATA_COM_EN            0x04000000UL  /*!< Enable 1's complement for CRC write data in             */
N#define CRC_CTL_CHECKSUM_RSV_EN         0x02000000UL  /*!< Enable bit order reverse for CRC checksum               */
N#define CRC_CTL_WDATA_RSV_EN            0x01000000UL  /*!< Enable bit order reverse per byre for CRC write data in */
N#define CRC_CTL_DMA_TRIG_EN             0x00800000UL  /*!< Enable CRC DMA data read or write transfer              */
N#define CRC_CTL_CRC_RST                 0x00000002UL  /*!< CRC Engine Reset                                        */
N#define CRC_CTL_CRCCEN_EN               0x00000001UL  /*!< Enable CRC Channel to enable CRC's operation            */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* CRC DMAIER Constants Definitions                                                                        */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_DMAIER_CRC_TABORT_IE_EN     0x0001UL  /*!< Enable CRC DMA Read/Write Target Abort Interrupt function */
N#define CRC_DMAIER_CRC_BLKD_IE_EN       0x0002UL  /*!< Enable CRC DMA Block Transfer Done Interrupt function     */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* CRC DMAISR Constants Definitions                                                                        */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_DMAISR_CRC_TABORT_IF        0x0001UL  /*!< Indicate CRC DMA Read/Write Target Abort Interrupt Flag */
N#define CRC_DMAISR_CRC_BLKD_IF          0x0002UL  /*!< Indicate CRC DMA Block Transfer Done Interrupt Flag     */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PDMA Define Macro                                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N// PDSSR0 register default value is 0xFFFFFFFF 
N#define _PDMAGCR_PDSSR0_SPI0_RXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<0))) |((x) << 0))  /*!< Set PDMA SPI0 RX as channel x*/
N#define _PDMAGCR_PDSSR0_SPI0_TXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<4))) |((x) << 4))  /*!< Set PDMA SPI0 TX Selection as channel x*/
N#define _PDMAGCR_PDSSR0_SPI1_RXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<8))) |((x) << 8))  /*!< Set PDMA SPI1 RX Selection as channel x*/
N#define _PDMAGCR_PDSSR0_SPI1_TXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<12)))|((x) << 12)) /*!< Set PDMA SPI1 TX Selection as channel x*/
N#define _PDMAGCR_PDSSR0_SPI2_RXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<16)))|((x) << 16)) /*!< Set PDMA SPI2 RX Selection as channel x*/
N#define _PDMAGCR_PDSSR0_SPI2_TXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<20)))|((x) << 20)) /*!< Set PDMA SPI2 TX Selection as channel x*/
N#define _PDMAGCR_PDSSR0_SPI3_RXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<24)))|((x) << 24)) /*!< Set PDMA SPI3 RX Selection as channel x*/
N#define _PDMAGCR_PDSSR0_SPI3_TXSEL(x)     (PDMA_GCR->PDSSR0 = (PDMA_GCR->PDSSR0&(~(0xF<<28)))|((x) << 28)) /*!< Set PDMA SPI3 TX Selection as channel x*/
N
N// PDSSR1 register default value is 0xFFFFFFFF 
N#define _PDMAGCR_PDSSR1_UART0_RXSEL(x)    (PDMA_GCR->PDSSR1 = (PDMA_GCR->PDSSR1&(~(0xF<<0))) |((x) << 0))  /*!< Set PDMA UART0 RX Selection as channel x*/
N#define _PDMAGCR_PDSSR1_UART0_TXSEL(x)    (PDMA_GCR->PDSSR1 = (PDMA_GCR->PDSSR1&(~(0xF<<4))) |((x) << 4))  /*!< Set PDMA UART0 TX Selection as channel x*/
N#define _PDMAGCR_PDSSR1_UART1_RXSEL(x)    (PDMA_GCR->PDSSR1 = (PDMA_GCR->PDSSR1&(~(0xF<<8))) |((x) << 8))  /*!< Set PDMA UART1 RX Selection as channel x*/
N#define _PDMAGCR_PDSSR1_UART1_TXSEL(x)    (PDMA_GCR->PDSSR1 = (PDMA_GCR->PDSSR1&(~(0xF<<12)))|((x) << 12)) /*!< Set PDMA UART1 TX Selection as channel x*/
N#define _PDMAGCR_PDSSR1_ADC_RXSEL(x)      (PDMA_GCR->PDSSR1 = (PDMA_GCR->PDSSR1&(~(0xF<<24)))|((x) << 24)) /*!< Set PDMA ADC RX Selection as channel x*/
N
N// PDSSR2 register default value is 0xFF 
N#define _PDMAGCR_PDSSR2_I2S_RXSEL(x)      (PDMA_GCR->PDSSR2 = (PDMA_GCR->PDSSR2&(~(0xF<<0))) |((x) << 0))  /*!< Set PDMA I2S RX Selection as channel x*/
N#define _PDMAGCR_PDSSR2_I2S_TXSEL(x)      (PDMA_GCR->PDSSR2 = (PDMA_GCR->PDSSR2&(~(0xF<<4))) |((x) << 4))  /*!< Set PDMA I2S TX Selection as channel x*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* CRC Macro Definitions                                                                                   */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     Reset CRC State Machine and Internal Buffer
N */
N#define _CRC_RESET()                        (CRC->CTL |= CRC_CTL_CRC_RST_Msk)
N
N
N/**
N * @details     Enable CRC Function
N */
N#define _CRC_ENABLE()                       (CRC->CTL |= CRC_CTL_CRCCEN_Msk)
N
N
N/**
N * @details     Disable CRC Function
N */
N#define _CRC_DISABLE()                      (CRC->CTL &= ~CRC_CTL_CRCCEN_Msk)
N
N
N/**
N * @details     Trigger CRC DMA Transfer
N */
N#define _CRC_TRIG_DMA()                     (CRC->CTL |= CRC_CTL_TRIG_EN_Msk)
N
N
N/**
N * @details     Enable CRC DMA Read/Write Target Abort Interrupt
N */
N#define _CRC_TABORT_INT_ENABLE()            (CRC->DMAIER |= CRC_DMAIER_CRC_TABORT_IE_Msk)
N
N
N/**
N * @details     Disable CRC DMA Read/Write Target Abort Interrupt
N */
N#define _CRC_TABORT_INT_DISABLE()           (CRC->DMAIER &= ~CRC_DMAIER_CRC_TABORT_IE_Msk)
N
N
N/**
N * @details     Enable CRC DMA Block Transfer Done Interrupt
N */
N#define _CRC_BLKD_INT_ENABLE()              (CRC->DMAIER |= CRC_DMAIER_CRC_BLKD_IE_Msk)
N
N
N/**
N * @details     Disable CRC DMA Block Transfer Done Interrupt
N */
N#define _CRC_BLKD_INT_DISABLE()             (CRC->DMAIER &= ~CRC_DMAIER_CRC_BLKD_IE_Msk)
N
N
N/**
N * @details     Get CRC DMA Read/Write Target Abort Interrupt Flag
N */
N#define _CRC_GET_TABORT_INT_FLAG()          (((CRC->DMAISR & CRC_DMAISR_CRC_TABORT_IF_Msk) == CRC_DMAISR_CRC_TABORT_IF_Msk)? 1:0)
N
N
N/**
N * @details     Clear CRC DMA Read/Write Target Abort Interrupt Flag
N */
N#define _CRC_CLEAR_TABORT_INT_FLAG()        (CRC->DMAISR = CRC_DMAISR_CRC_TABORT_IF_Msk)
N                                               
N
N/**
N * @details     Get CRC DMA Block Transfer Done Interrupt Flag
N */
N#define _CRC_GET_BLKD_INT_FLAG()            (((CRC->DMAISR & CRC_DMAISR_CRC_BLKD_IF_Msk) == CRC_DMAISR_CRC_BLKD_IF_Msk)? 1:0)
N
N
N/**
N * @details     Clear CRC DMA Block Transfer Done Interrupt Flag
N */
N#define _CRC_CLEAR_BLKD_INT_FLAG()          (CRC->DMAISR = CRC_DMAISR_CRC_BLKD_IF_Msk)
N
N
N/**
N * @details     Set CRC DMA Transfer Source Address
N */
N#define _CRC_SET_DMA_SRC_ADDRESS(x)         (CRC->DMASAR = (x))
N
N
N/**
N * @details     Get CRC DMA Current Source Address 
N */
N#define _CRC_GET_DMA_CURRENT_SRC_ADDRESS()  (CRC->DMACSAR)
N
N
N/**
N * @details     Set CRC DMA Total Transfer Byte Count 
N */
N#define _CRC_SET_DMA_TRANS_BYTE_COUNT(x)    (CRC->DMABCR = (x))
N
N
N/**
N * @details     Get CRC DMA Current Remained Byte Count 
N */
N#define _CRC_GET_DMA_REMAINED_BYTE_COUNT()  (CRC->DMACBCR)
N
N
N/**
N * @details     Write Data to Perform CRC Operation in CRC CPU Mode
N */
N#define _CRC_CPU_WRITE_DATA(x)              (CRC->WDATA = (x))
N
N
N/**
N * @details     Set CRC Initial Seed Value
N */
N#define _CRC_SET_SEED(x)                    (CRC->SEED = (x))
N
N
N/**
N * @details     Get CRC-CCITT Polynomial Mode Checksum Value
N */
N#define _CRC_GET_POLY_CCITT_CHECKSUM()      (CRC->CHECKSUM & 0xFFFF)
N
N
N/**
N * @details     Get CRC-8 Polynomial Mode Checksum Value
N */
N#define _CRC_GET_POLY_8_CHECKSUM()          (CRC->CHECKSUM & 0xFF)
N
N
N/**
N * @details     Get CRC-16 Polynomial Mode Checksum Value
N */
N#define _CRC_GET_POLY_16_CHECKSUM()         (CRC->CHECKSUM & 0xFFFF)
N
N
N/**
N * @details     Get CRC-32 Polynomial Mode Checksum Value
N */
N#define _CRC_GET_POLY_32_CHECKSUM()         (CRC->CHECKSUM & 0xFFFFFFFF)
N
N
N/**
N  * @} End of PDMA Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N#endif  // __PDMA_H__ 
L 6309 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "SC.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\SC.h" 1
N/**************************************************************************//**
N * @file     SC.h
N * @version  V1.00
N * $Revision: 12 $
N * $Date: 12/08/22 7:24p $
N * @brief    NUC200 Series Smart Card Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N *
N ******************************************************************************/
N
N#ifndef __SC_H__
N#define __SC_H__
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 19 "..\..\LibNUC200Series\StdDriver\inc\SC.h" 2
N#include <stdlib.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 20 "..\..\LibNUC200Series\StdDriver\inc\SC.h" 2
N#include <stdio.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030076
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 21 "..\..\LibNUC200Series\StdDriver\inc\SC.h" 2
N#include <math.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 178085 $ Codemist 0.03
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5030076
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199409L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_SOFTFP __declspec(__nothrow) __softfp
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __pure
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#ifdef __BIG_ENDIAN
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* ndef __BIG_ENDIAN */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* ndef __BIG_ENDIAN */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern __softfp unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Nextern __softfp unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __softfp int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __softfp int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __softfp int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#define HUGE_VAL ((double)__INFINITY__)
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __pure double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __pure double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __pure double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __pure double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __pure double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __pure double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __pure float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __pure double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __pure float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __pure float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __pure float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __pure float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
Sextern _ARMABI __int64 llrint(double /*x*/);
Sextern _ARMABI __int64 llrintf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llrintl(long double __x)     { return llrint((double)__x); }
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
Sextern _ARMABI __int64 llround(double /*x*/);
Sextern _ARMABI __int64 llroundf(float /*x*/);
S_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __int64 llroundl(long double __x)     { return llround((double)__x); }
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __int64 llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __int64 llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __int64 llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __int64 llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S      using ::std::fmal;
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S      using ::std::lrintl;
S      using ::std::llrint;
S      using ::std::llrintf;
S      using ::std::llrintl;
S      using ::std::lround;
S      using ::std::lroundf;
S      using ::std::lroundl;
S      using ::std::llround;
S      using ::std::llroundf;
S      using ::std::llroundl;
S      using ::std::nan;
S      using ::std::nanf;
S      using ::std::nanl;
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S      using ::std::remquol;
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#endif /* __math_h */
N
N/* end of math.h */
N
L 22 "..\..\LibNUC200Series\StdDriver\inc\SC.h" 2
N#include "NUC200Series.h"
N
N
N/** @addtogroup NUC200_FUNC NUC200 Function Interface
N  * @{
N  */
N
N/** @addtogroup SC_FUNC SMARTCARD Device Function Interface
N  * @{
N  */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_CD_INS_REM_MASK          0xC
N#define SC_MAXIMUM_ATR_CODES        4
N#define SC_MAXIMUM_ATR_LENGTH       33
N/* Do activation & de-activation & warm-rest with manual sequence */
N#define SC_SEQ_MANUAL
N
N#define SC_SC_NUM					    3      // we have 3 interfaces
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Smart Card Internal Timer number constants definitions                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_TIMER0   8       /*!< Smart Card Internal Timer 0 */
N#define SC_TIMER1	16      /*!< Smart Card Internal Timer 1 */ 
N#define SC_TIMER2   32      /*!< Smart Card Internal Timer 2 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Clock Stop Level                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_CLK_PIN_STOP_NOT_SUPPORT     0
N#define SC_CLK_PIN_STOP_LOW             1
N#define SC_CLK_PIN_STOP_HIGH            2
N#define SC_CLK_PIN_STOP_NO_PREFE        3
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  RBR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_RBR_RBR_MASK				((uint32_t)0x000000FF)			/*!<Receive Buffer Register */
N/*---------------------------------------------------------------------------------------------------------*/
N/*  THR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_THR_THR_MASK				((uint32_t)0x000000FF)			/*!<Transmit Holding Register */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CTL constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_CTL_SC_CEN				((uint32_t)0x00000001)			/*!<SC Engine Enable */
N#define SC_CTL_DIS_RX				((uint32_t)0x00000002)			/*!<Disable RX transition */
N#define SC_CTL_DIS_TX				((uint32_t)0x00000004)			/*!<Disable TX transition */
N#define SC_CTL_AUTO_CON_EN			((uint32_t)0x00000008)			/*!<Auto Convention Enable */
N#define SC_CTL_CON_SEL_DIRECT_CON	((uint32_t)0x00000000)			/*!<Convention Select */
N#define SC_CTL_CON_SEL_INVERSE_CON	((uint32_t)0x00000030)			/*!<Convention Select */
N#define SC_CTL_RX_FTRI_LEV_1BYTE	((uint32_t)0x00000000)			/*!<RX Buffer Trigger Level 1 byte*/
N#define SC_CTL_RX_FTRI_LEV_2BYTES	((uint32_t)0x00000040)			/*!<RX Buffer Trigger Level 2 bytes*/
N#define SC_CTL_RX_FTRI_LEV_3BYTES	((uint32_t)0x00000080)			/*!<RX Buffer Trigger Level 3 bytes*/
N#define SC_CTL_TMR_SEL_DISABLE		((uint32_t)0x00000000)			/*!<Timer Selection. Disable all internal timer function */
N#define SC_CTL_TMR_SEL_24_BITS		((uint32_t)0x00002000)			/*!<Timer Selection. Enable internal 24 bits timer */
N#define SC_CTL_TMR_SEL_24_8_BITS	((uint32_t)0x00004000)			/*!<Timer Selection. Enable internal 24 bits timer and 8 bits internal timer */
N#define SC_CTL_TMR_SEL_24_8_8_BITS	((uint32_t)0x00006000)			/*!<Timer Selection. Enable internal 24 bits timer and two 8 bits timers */
N#define SC_CTL_SLEN					((uint32_t)0x00008000)			/*!<Stop Bit Length */
N#define SC_CTL_RX_ERETRY_EN			((uint32_t)0x00080000)			/*!<RX Error Retry Enable Register */
N#define SC_CTL_TX_ERETRY_EN			((uint32_t)0x00800000)			/*!<TX Error Retry Enable Register */
N#define SC_CTL_CD_DEB_SEL_IN_384_REMOVAL_128 ((uint32_t)0x00000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 384 engine clocks and de-bounce sample card removal once per 128 engine clocks.*/
N#define SC_CTL_CD_DEB_SEL_IN_192_REMOVAL_64	 ((uint32_t)0x01000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 192 engine clocks and de-bounce sample card removal once per 64 engine clocks. */
N#define SC_CTL_CD_DEB_SEL_IN_96_REMOVAL_32	 ((uint32_t)0x02000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 96 engine clocks and de-bounce sample card removal once per 32 engine clocks. */
N#define SC_CTL_CD_DEB_SEL_IN_48_REMOVAL_16	 ((uint32_t)0x03000000)			/*!<Card Detect De-Bounce Select Register. Card insert once per 48 engine clocks and de-bounce sample card removal once per 16 engine clocks. */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ALTCTL constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_ALTCTL_TX_RST			((uint32_t)0x00000001)			/*!<TX Software Reset */
N#define SC_ALTCTL_RX_RST			((uint32_t)0x00000002)			/*!<RX Software Reset */
N#define SC_ALTCTL_DACT_EN			((uint32_t)0x00000004)			/*!<Deactivation Sequence Generator Enable */
N#define SC_ALTCTL_ACT_EN			((uint32_t)0x00000008)			/*!<Activation Sequence Generator Enable */
N#define SC_ALTCTL_WARST_EN			((uint32_t)0x00000010)			/*!<Warm Reset Sequence Generator Enable */
N#define SC_ALTCTL_TMR0_SEN			((uint32_t)0x00000020)			/*!<Internal Timer0 Start Enable */
N#define SC_ALTCTL_TMR1_SEN			((uint32_t)0x00000040)			/*!<Internal Timer1 Start Enable */
N#define SC_ALTCTL_TMR2_SEN			((uint32_t)0x00000080)			/*!<Internal Timer2 Start Enable */
N#define SC_ALTCTL_RX_BGT_EN			((uint32_t)0x00001000)			/*!<Receiver Block Guard Time Function Enable */
N#define SC_ALTCTL_TMR0_ATV			((uint32_t)0x00002000)			/*!<Internal Timer0 Active State (Read Only) */
N#define SC_ALTCTL_TMR1_ATV			((uint32_t)0x00004000)			/*!<Internal Timer1 Active State (Read Only) */
N#define SC_ALTCTL_TMR2_ATV			((uint32_t)0x00008000)			/*!<Internal Timer2 Active State (Read Only) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ETUCR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_ETUCR_COMPEN_EN			((uint32_t)0x00008000)			/*!<Compensation Mode Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IER constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_IER_RDA_IE				((uint32_t)0x00000001)			/*!<Receive Data Reach Interrupt Enable */
N#define SC_IER_TBE_IE				((uint32_t)0x00000002)			/*!<Transmit Buffer Empty Interrupt Enable */
N#define SC_IER_TERR_IE				((uint32_t)0x00000004)			/*!<Transfer Error Interrupt Enable */
N#define SC_IER_TMR0_IE				((uint32_t)0x00000008)			/*!<Timer0 Interrupt Enable */
N#define SC_IER_TMR1_IE				((uint32_t)0x00000010)			/*!<Timer1 Interrupt Enable */
N#define SC_IER_TMR2_IE				((uint32_t)0x00000020)			/*!<Timer2 Interrupt Enable */
N#define SC_IER_BGT_IE				((uint32_t)0x00000040)			/*!<Block Guard Time Interrupt Enable */
N#define SC_IER_CD_IE				((uint32_t)0x00000080)			/*!<Card Detect Interrupt Enable */
N#define SC_IER_INIT_IE				((uint32_t)0x00000100)			/*!<Initial End Interrupt Enable */
N#define SC_IER_RTMR_IE				((uint32_t)0x00000200)			/*!<Receiver Buffer Time-Out Interrupt Enable  */
N#define SC_IER_ACON_ERR_IE			((uint32_t)0x00000400)			/*!<Auto convention Error Interrupt Enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_ISR_RDA_IS				((uint32_t)0x00000001)			/*!<Receive Data Reach Interrupt Status Flag (Read Only) */
N#define SC_ISR_TBE_IS				((uint32_t)0x00000002)			/*!<Transmit Buffer Empty Interrupt Status Flag (Read Only) */
N#define SC_ISR_TERR_IS				((uint32_t)0x00000004)			/*!<Transfer Error Interrupt Status Flag (Read Only) */
N#define SC_ISR_TMR0_IS				((uint32_t)0x00000008)			/*!<Timer0 Interrupt Status Flag (Read Only) */
N#define SC_ISR_TMR1_IS				((uint32_t)0x00000010)			/*!<Timer1 Interrupt Status Flag (Read Only) */
N#define SC_ISR_TMR2_IS				((uint32_t)0x00000020)			/*!<Timer2 Interrupt Status Flag (Read Only) */
N#define SC_ISR_BGT_IS				((uint32_t)0x00000040)			/*!<Block Guard Time Interrupt Status Flag (Read Only) */
N#define SC_ISR_CD_IS				((uint32_t)0x00000080)			/*!<Card Detect Interrupt Status Flag (Read Only) */
N#define SC_ISR_INIT_IS				((uint32_t)0x00000100)			/*!<Initial End Interrupt Status Flag (Read Only) */
N#define SC_ISR_RTMR_IS				((uint32_t)0x00000200)			/*!<Receiver buffer Time-Out Interrupt Status Flag (Read Only) */
N#define SC_ISR_ACON_ERR_IS			((uint32_t)0x00000400)			/*!<Auto Convention Error Interrupt Status Flag (Read Only) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  TRSR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_TRSR_RX_OVER_F			((uint32_t)0x00000001)			/*!<RX Overflow Error Status Flag (Read Only)  */
N#define SC_TRSR_RX_EMPTY_F			((uint32_t)0x00000002)			/*!<Receiver Buffer Empty Status Flag(Read Only) */
N#define SC_TRSR_RX_FULL_F			((uint32_t)0x00000004)			/*!<Receiver Buffer Full Status Flag (Read Only) */
N#define SC_TRSR_RX_EPA_F			((uint32_t)0x00000010)			/*!<Receiver Parity Error Status Flag (Read Only) */
N#define SC_TRSR_RX_EFR_F			((uint32_t)0x00000020)			/*!<Receiver Frame Error Status Flag (Read Only) */
N#define SC_TRSR_RX_EBR_F			((uint32_t)0x00000040)			/*!<Receiver Break Error Status Flag (Read Only) */
N#define SC_TRSR_TX_OVER_F			((uint32_t)0x00000100)			/*!<TX Overflow Error Interrupt Status Flag (Read Only) */
N#define SC_TRSR_TX_EMPTY_F			((uint32_t)0x00000200)			/*!<Transmit buffer Empty Status Flag (Read Only) */
N#define SC_TRSR_TX_FULL_F			((uint32_t)0x00000400)			/*!<Transmit buffer Full Status flag (Read Only) */
N#define SC_TRSR_RX_ERETRY_F			((uint32_t)0x00200000)			/*!<Receiver Retry Error (Read Only) */
N#define SC_TRSR_RX_OVER_ERETRY		((uint32_t)0x00400000)			/*!<Receiver Over Retry Error (Read Only) */
N#define SC_TRSR_RX_RX_ATV			((uint32_t)0x00800000)			/*!<Receiver In Active Status Flag (Read Only) */
N#define SC_TRSR_TX_ERETRY_F			((uint32_t)0x20000000)			/*!<Transmitter Retry Error (Read Only) */
N#define SC_TRSR_TX_OVER_ERETRY		((uint32_t)0x40000000)			/*!<Transmitter Over Retry Error (Read Only) */
N#define SC_TRSR_TX_ATV				((uint32_t)0x80000000)			/*!<Transmit In Active Status Flag (Read Only) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PINCSR constants definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_PINCSR_POW_EN			((uint32_t)0x00000001)			/*!<SC_POW_EN Pin Signal */
N#define SC_PINCSR_SC_RST			((uint32_t)0x00000002)			/*!<SC_RST Pin Signal */
N#define SC_PINCSR_CD_REM_F			((uint32_t)0x00000004)			/*!<Card Detect Removal Status Of SC_CD Pin (Read Only) */
N#define SC_PINCSR_CD_INS_F			((uint32_t)0x00000008)			/*!<Card Detect Insert Status Of SC_CD Pin (Read Only) */
N#define SC_PINCSR_CD_PIN_ST			((uint32_t)0x00000010)			/*!<Card Detect Status Of SC_CD Pin Status (Read Only) */
N#define SC_PINCSR_CLK_STOP_LEV		((uint32_t)0x00000020)			/*!<SC Clock Stop Level */
N#define SC_PINCSR_CLK_KEEP			((uint32_t)0x00000040)			/*!<SC Clock Enable  */
N#define SC_PINCSR_ADAC_CD_EN		((uint32_t)0x00000080)			/*!<Auto Deactivation When Card Removal */
N#define SC_PINCSR_SC_OEN_ST			((uint32_t)0x00000100)			/*!<SC Data Output Enable Pin Status (Read Only) */
N#define SC_PINCSR_SC_DATA_O			((uint32_t)0x00000200)			/*!<SC Data Output Pin */
N#define SC_PINCSR_CD_LEV			((uint32_t)0x00000400)			/*!<Card Detect Level */
N#define SC_PINCSR_POW_INV			((uint32_t)0x00000800)			/*!<SC_POW Pin Inverse */
N#define SC_PINCSR_SC_DATA_I_ST		((uint32_t)0x00010000)			/*!<SC Data Input Pin Status (Read Only) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  SC_TMR0/1/2 Internal Timer Control Mode constants definitions                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_TMR_MODE0_DC				    ((uint32_t)0x00000000)	/*!<Timer0/1/2 Operation Mode 0. 
N                                                                    Down Counter start from trigger timer and end to TMR_CNT equal to 0.*/
N#define SC_TMR_MODE1_TIMER_DC_S_TO		((uint32_t)0x01000000)	/*!<Timer0/1/2 Operation Mode 1. 
N                                                                    Down Counter start from first start bit and end to time-out.*/
N#define SC_TMR_MODE2_DC_RX_S_TO		    ((uint32_t)0x02000000)	/*!<Timer0/1/2 Operation Mode 2. 
N                                                                    Down Counter start from first reception start bit and end to time-out.*/
N#define SC_TMR_MODE3_DC_INITIAL_END	    ((uint32_t)0x03000000)	/*!<Timer0 Operation Mode 3. Timer1/2 don't support Operation Mode 3. 
N                                                                    Down Counter start from asserting SC_RST and end to time-out*/
N#define SC_TMR_MODE4_DC_RELOAD			((uint32_t)0x04000000)	/*!<Timer0/1/2 Operation Mode 4. 
N                                                                    Down Counter start from trigger timer and end to TMR_CNT equal to 0 
N                                                                    if DC count to 0, timer will reload and re-count*/
N#define SC_TMR_MODE5_DC_RELOAD_S_TO	    ((uint32_t)0x05000000)	/*!<Timer0/1/2 Operation Mode 5. 
N                                                                    Down Counter start from first start bit and end to time-out 
N                                                                    if DC count to 0, timer will reload and re-count*/
N#define SC_TMR_MODE6_DC_RELOAD_RX_S_TO	((uint32_t)0x06000000)	/*!<Timer0/1/2 Operation Mode 6.  
N                                                                    Down Counter start from first reception start bit and end to time-out
N                                                                    if DC count to 0, timer will reload and re-count. */
N#define SC_TMR_MODE7_DC_RELOAD_S_S		((uint32_t)0x07000000)	/*!<Timer0/1/2 Operation Mode 7.  
N                                                                    Down Counter start from first start bit and end to next start bit
N                                                                    if DC does NOT count to 0 and receive the first start bit, timer will reload and re-count.*/
N#define SC_TMR_MODE8_UC				    ((uint32_t)0x08000000)	/*!<Timer0/1/2 Operation Mode 8.
N                                                                    Up Counter start from trigger timer and end to stop timer.*/
N
N
N#define SC_MIN_BUFFER_SIZE             271// 288
N#define SC_ATR_ERR_UNRECOGNIZED_MEDIA		-150
N#define SC_ATR_ERR_INVALID_PARAMETER		-149
N#define SC_ATR_ERR_INVALID_TCK				-148
N
N#define SC_PROTOCOL_T0_OK					0			/* Command OK  */
N#define SC_PROTOCOL_T0_ICC_ERROR			-1000		/* ICC comunication error */
N#define SC_PROTOCOL_T0_ERROR				-1001		/* T=0 Protocol Error */
N
N#define SC_PROTOCOL_PPS_INVALID			-147
N
N#define SC_PROTOCOL_UNDEFINED		0x00000000  // There is no active protocol.
N#define SC_PROTOCOL_T0				0x00000001  // T=0 is the active protocol.
N#define SC_PROTOCOL_T1				0x00000002  // T=1 is the active protocol.
N#define SC_PROTOCOL_T15				0x00008000  // T=15 is the active protocol.
N#define SC_PROTOCOL_RAW				0x00010000  // Raw is the active protocol.
N
N#define SC_STAUS_UNKNOWN			0x0001	/*!< Card status is Unknown state */
N#define SC_STAUS_ABSENT			    0x0002	/*!< Card status is absent */
N#define SC_STAUS_PRESENT			0x0004	/*!< Card status is present */
N#define SC_STAUS_SWALLOWED		    0x0008	/*!< Card status is not powered */
N#define SC_STAUS_POWERED			0x0010	/*!< Card status is powered */
N#define SC_STAUS_NEGOTIABLE		    0x0020	/*!< Card status is ready for PTS */
N#define SC_STAUS_SPECIFIC		    0x0040	/*!< Card status is PTS has been set */
N
N#define SC_T1_BLOCK_MAX_SIZE		259
N#define SC_T1_BLOCK_INF_MAX_SIZE	254
N
N/* PCBs */
N#define SC_T1_BLOCK_I                0x00
N#define SC_T1_BLOCK_R                0x80
N#define SC_T1_BLOCK_S                0xC0
N//
N// constants for the T=1 i/o function
N//
N#define SC_T1_INIT				0
N#define SC_T1_START			    1
N#define SC_T1_I_BLOCK			2
N#define SC_T1_R_BLOCK			3
N#define SC_T1_RESTART			4
N
N#define SC_T1_BLOCK_S_RESYNCH_REQ		0xC0
N#define SC_T1_BLOCK_S_RESYNCH_RES		0xE0
N#define SC_T1_BLOCK_S_IFS_REQ			0xC1
N#define SC_T1_BLOCK_S_IFS_RES			0xE1
N#define SC_T1_BLOCK_S_ABORT_REQ			0xC2
N#define SC_T1_BLOCK_S_ABORT_RES			0xE2
N#define SC_T1_BLOCK_S_WTX_REQ			0xC3
N#define SC_T1_BLOCK_S_WTX_RES			0xE3
N#define SC_T1_BLOCK_S_VPP_ERR			0xE4
N/*****************************************************************************
N*
N*****************************************************************************/
N#define SC_PROTOCOL_T1_OK					0          		/* Command OK  */
N#define SC_PROROCOL_T1_P_ERR_NOTICE		    2000			/* T=1 Parity Error Notice */
N#define SC_PROTOCOL_T1_ICC_ERROR			-2000       	/* ICC comunication error */
N#define SC_PROTOCOL_T1_ERROR				-2001       	/* T=1 Protocol Error */
N#define SC_T1_ABORT_RECEIVED				-2002
N#define SC_T1_RESYNCH_RECEIVED			    -2003
N#define SC_T1_VPP_ERROR_RECEIVED			-2004
N#define SC_T1_WTXRES_RECEIVED				-2005
N#define SC_T1_IFSRES_RECEIVED				-2006
N#define SC_T1_ABORTRES_RECEIVED			    -2007
N
N//
N// Information field size the lib uses
N//
N#define SC_T1_IFSD             254
N
N//
N// Maximum attempts to resend a block in T1
N//
N#define SC_T1_MAX_RETRIES      2
N
N//
N// Bit that indenticates if there are more data to send
N//
N#define SC_T1_MORE_DATA        0x20
N
N//
N// T1 Error values
N//
N#define SC_T1_ERROR_CHKSUM		-1002
N#define SC_T1_ERROR_OTHER		-1003
N#define SC_T1_ERROR_LENGTH		-1004
N
N//
N// Error detection bit as defined by ISO 
N//
N#define SC_T1_CRC_CHECK        1
N
N//
N// Character waiting integer default value as definded by ISO
N//
N#define SC_T1_CWI_DEFAULT      13
N
N//
N// Block waiting integer default value as definded by ISO
N//
N#define SC_T1_BWI_DEFAULT      4
N
N//
N// Receiving an ATR shall have a duration of less than or equal to initial etus
N//
N#define SC_ATR_TOTAL_TIME		20050
N
N
N#define SC_ERR_ID        0xffff2000
N
N#define SC_MAX_ATR_LEN					(33)
N#define SC_MAX_BUF_LEN					(500)
N#define SC_MAX_CMD_LEN					(262)	/* header : 5, data : 256(max), le : 1, plus all 262 */
N
N
N/* iso7816 operation class */
N#define SC_ISO_OPERATIONCLASS_AUTO			(0x00)
N#define SC_ISO_OPERATIONCLASS_A				(0x01)
N#define SC_ISO_OPERATIONCLASS_B				(0x02)
N#define SC_ISO_OPERATIONCLASS_C				(0x03)
N
N// Current card operation in ISR
N#define SC_OP_NOP					(0x00)
N#define SC_OP_ATR_READ			    (0x01)
N#define SC_OP_READ					(0x02)
N#define SC_OP_WRITE				    (0x03)
N
N// status successful
N#define SC_STATUS_SUCCESS               0
N
N// error code 
N#define SC_ERR_CARD_REMOVED			-120
N#define SC_ERR_OVER_RUN				-119
N#define SC_ERR_PARITY_ERROR			-118
N#define SC_ERR_NO_STOP				-117
N#define SC_ERR_SILENT_BYTE			-116
N#define SC_ERR_CMD				    -115
N#define SC_ERR_UNSUPPORTEDCARD		-114
N#define SC_ERR_READ					-113
N#define SC_ERR_WRITE			    -112
N#define SC_ERR_TIME0OUT            	-111
N#define SC_ERR_TIME1OUT            	-110
N#define SC_ERR_TIME2OUT            	-109
N#define SC_ERR_AUTOCONVENTION    	-108
N#define SC_ERR_BGTIMEOUT		   	-107
N
N
N// These are the error code actually returns to user application
N#define SC_EIO							(1| SC_ERR_ID)
N#define SC_ENODEV						(2| SC_ERR_ID)
N#define SC_ENOMEM						(3| SC_ERR_ID)
N#define SC_EBUSY						(4| SC_ERR_ID)
N#define SC_ENOTTY						(5| SC_ERR_ID)
N#define SC_EPROTOCOL					(6| SC_ERR_ID)  
N#define SC_EPARAMETER					(7| SC_ERR_ID)
N
N
N
N/* ATRIB = A(nswer) T(o) R(eset) I(nterface) B(yte) */
N#define SC_ATR_INTERFACE_BYTE_TA		0	/* Interface byte TAi */
N#define SC_ATR_INTERFACE_BYTE_TB		1	/* Interface byte TBi */
N#define SC_ATR_INTERFACE_BYTE_TC		2	/* Interface byte TCi */
N#define SC_ATR_INTERFACE_BYTE_TD		3	/* Interface byte TDi */
N
N// Reset type
N#define SC_COLDRESET                (0x1)
N#define SC_WARMRESET                (0x2)
N
N#define SC_GET_ONE_BYTE()		                ((SC->RBR & 0xff))
N#define SC_PUT_ONE_BYTE(data)		            (SC->THR = data)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define parameter checking                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SC_CHECK_SC_PORT(port)				((port==SC0) || (port==SC1) || (port==SC2))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define EMV checking                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N//#define SC_EMV_ATR_CHECK		1		/* 1: Enable to check integrity of ATR for EMV */
N
N//#define SC_DEBUG_ENABLE_ENTER_LEAVE
N//#define SC_IST_DEBUG				/* IST information check in SC.c */
N//#define SC_ATR_DEBUG				/* ATR information check in SC.c */
N//#define SC_RD_DEBUG				/* Send/Receive check in SC_Reader.c */
N//#define SC_T1_DEBUG				/* T1 protocol check in SC_Protocol.c */
N
N#ifdef SC_DEBUG_ENABLE_ENTER_LEAVE
S#define SC_ENTER()					printf("[%-20s] : Enter...\n", __func__)
S#define SC_LEAVE()					printf("[%-20s] : Leave...\n", __func__)
N#else
N#define SC_ENTER()
N#define SC_LEAVE()
N#endif
N
N
N#ifdef SC_ATR_DEBUG
S#define SC_DEBUG     printf
N#else
N#define SC_DEBUG(...)
N#endif
N
N
N#ifdef SC_IST_DEBUG
S#define SC_ISTDEBUG     printf
N#else
N#define SC_ISTDEBUG(...)
N#endif
N
N
N#ifdef SC_RD_DEBUG
S#define SC_RDDEBUG     printf
N#else
N#define SC_RDDEBUG(...)
N#endif
N
N
N#ifdef SC_T1_DEBUG
S#define SC_T1DEBUG     printf
N#else
N#define SC_T1DEBUG(...)
N#endif
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Smart Card data type conversion structure                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef union {
N    
N    struct {
N
N        unsigned long   l0;
N
N    } l;
N
N    struct {
N
N        uint8_t   b0;
N        uint8_t   b1;
N        uint8_t   b2;
N        uint8_t   b3;
N    } b;
N
N} S_SC_LENGTH;
N
N
Ntypedef struct {
N
N    // Number of data bytes in this request
N    int32_t   Lc;
N
N    // Number of expected bytes from the card
N    int32_t   Le;
N
N} S_SC_T0_DATA;
N
N
Ntypedef struct {
N
N    // Current information field size that can be transmitted
N    uint8_t   IFSC;
N
N    // Current information field size we can receive
N    uint8_t   IFSD;
N
N	// Record if received I-block was sent correctly from ICC
N	uint8_t   IBLOCK_REC;
N
N    // The 'number' of received I-Blocks
N    uint8_t   RSN;
N
N    // The 'number' of sent I-Blocks as defined in ISO 7816-3
N    uint8_t   SSN;
N
N    //
N    // Waiting time extension requested by the smart card
N    // This value should be used by the driver to extend block waiting time.
N    //
N    uint8_t   Wtx;
N
N} S_SC_T1_DATA;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* This struct is used by the lib for T1 I/O                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct {  
N    uint8_t   Nad;
N    uint8_t   Pcb;
N    uint8_t   Len;
N    uint8_t *  Inf;
N} S_SC_T1_BLOCK_FRAME;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Clock rate conversion table according to ISO structure                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct {
N
N    const unsigned long F;
N    const unsigned long fs; 
N
N} S_SC_CLOCK_RATE_CONVERSION;
N
N//
N// Bit rate adjustment factor 
N// The layout of this table has been slightly modified due to 
N// the unavailibility of floating point math support in the kernel.
N// The value D has beed devided into a numerator and a divisor.
N//
Ntypedef struct {
N    const unsigned long DNumerator;
N    const unsigned long DDivisor;
N} S_SC_BIT_RATE_ADJUSTMENT;
N
N//
N// The clock rate conversion table itself.
N// All R(eserved)F(or Future)U(se) fields MUST be 0
N//
Nstatic S_SC_CLOCK_RATE_CONVERSION ClockRateConversion[] = {
N
N        { 372,  4000000     }, 
N        { 372,  5000000     }, 
N        { 558,  6000000     }, 
N        { 744,  8000000     }, 
N        { 1116, 12000000    }, 
N        { 1488, 16000000    },
N        { 1860, 20000000    },
N        { 0,    0            },
N        { 0,    0            },
N        { 512,  5000000     },
N        { 768,  7500000     },
N        { 1024, 10000000    },
N        { 1536, 15000000    },
N        { 2048, 20000000    },
N        { 0,    0            },
N        { 0,    0            }
N};      
N
N//
N// The bit rate adjustment table itself.
N// All R(eserved)F(or)U(se) fields MUST be 0
N//
Nstatic S_SC_BIT_RATE_ADJUSTMENT BitRateAdjustment[] = {
N
N    { 0,    0   },
N    { 1,    1   },
N    { 2,    1   },
N    { 4,    1   },
N    { 8,    1   },
N    { 16,   1   },
N    { 32,   1   },
N    { 64,   1   },
N    { 12,   1   },
N    { 20,   1   },
N    { 0,    0   },
N    { 0,    0   },
N    { 0,    0   },
N    { 0,    0   },
N    { 0,    0   },
N    { 0,    0   }
N};
N
N
N//
N// This struct holds information for the card currently in use
N// The driver must store a received ATR into the ATR struct which is
N// part of this struct. The lib will get all other information 
N// out of the ATR.
N//
Ntypedef struct{
N
N    // Flag that indicates that the current card uses invers convention
N    bool InversConvention;
X    _Bool InversConvention;
N
N    // Calculated etu 
N    unsigned long   etu;        // micro-second unit ; etu = F/D * 1/f
N      
N    //
N    // Answer To Reset string returned by card.
N    // Use OsData->SpinLock to access this member
N    //
N    struct {
N
N        uint8_t Buffer[64];
N        uint8_t Length;
N
N    } ATR;
N
N    struct {
N
N        uint8_t Buffer[16];
N        uint8_t Length;
N
N    } HistoricalChars;
N
N    // !!! DO NOT MODIFY ANY OF THE BELOW VALUES
N    // OTHERWISE THE LIBRARY WON'T WORK PROPERLY
N
N    // Clock rate conversion 
N    uint8_t Fl;
N
N    // Bit rate adjustment
N    uint8_t Dl;
N
N    // Maximum programming current      // not understand how to use it???
N    uint8_t II;
N
N    // Programming voltage in .1 Volts  // not understand how to use it???
N    uint8_t P;
N
N    // Extra guard time in etu 
N    uint8_t N;
N
N    // Calculated guard time in micro seconds
N    unsigned long GT;
N
N    struct {
N
N		// This is a bit mask of the supported protocols
N		unsigned long Supported;
N		// The currently selected protocol
N		unsigned long Selected;
N
N    } Protocol;
N
N    // T=0 specific data
N    struct {
N
N        // Waiting integer
N        uint8_t WI;
N
N        // Waiting time in micro seconds
N        unsigned long WT;
N
N    } T0;
N
N    // T=1 specific data
N    struct {
N
N        // Information field size of card
N        uint8_t IFSC;
N
N        // Character waiting integer and block waiting integer
N        uint8_t CWI;
N        uint8_t BWI;
N
N        // Error detection code
N        uint8_t EDC;
N
N        // Character and block waiting time in micro seconds
N        unsigned long CWT;
N        unsigned long BWT;
N
N        // Block guarding time in micro seconds
N        unsigned long BGT;
N
N    } T1;
N
N} S_SC_SCARD_CARD_CAPABILITIES;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* SmartCard Data Structure                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N  
Ntypedef struct 
N{
N	SC_T *base /*, num*/;
N	volatile uint32_t op_state;		/* 0 - everything goes well, 1 - some error occured */
N	volatile int32_t errno;
N	volatile uint32_t openflag;
N	volatile uint32_t clock;			/* frequence in KHz */
N	uint32_t clock_stop_level;
N	volatile uint32_t etu; 			/* in millisecond */
N	volatile uint32_t voltage;
N	volatile int8_t ActivePowerPin;		/* 1: active High 0: active Low */
N
N    // Capabilities of the current inserted card
N    S_SC_SCARD_CARD_CAPABILITIES CardCapabilities;
N
N    //
N    // Current state of reader (card present/removed/activated)
N    // Use OsData->SpinLock to access this member
N    // (mandatory)
N    // use for PPS
N    unsigned long   CurrentState;
N
N	uint8_t *snd_buf, *rcv_buf;  
N	volatile int32_t snd_pos, snd_len;
N    volatile int32_t rcv_len, rcv_pos;
N	volatile int32_t rcv_cnt;  // cnt is current received data number in write stage read index in read stage
N	volatile uint32_t bCardRemoved /* , bCardChanged */;
N	int8_t pps_complete; //[20120720]
N
N    // Data for T=0
N    S_SC_T0_DATA T0;
N    
N    // Data for T=1
N    S_SC_T1_DATA T1;
N
N}S_SC_DEV_T;
N
N
Ntypedef void (SC_PFN_CALLBACK)(void);
N  
N
N//  function prototypes: DrvSMARTCARD.c
Nvoid SC_TimerINTEnable(S_SC_DEV_T *dev, uint32_t no);
Nvoid SC_TimerINTDisable(S_SC_DEV_T *dev, uint32_t no);
Nvoid SC_TimerCountSet(S_SC_DEV_T *dev, uint32_t no, uint32_t op_mode, uint32_t cnt);
Nvoid SC_WaitFirstReceivedData(S_SC_DEV_T *dev, uint32_t no, uint32_t op_mode, uint32_t cnt);
Nvoid SC_TimerStop(S_SC_DEV_T *dev, uint32_t no);
Nvoid SC_TimerAllStop(S_SC_DEV_T *dev);
Nvoid SC_TimerStart(S_SC_DEV_T *dev, uint32_t no);
Nvoid SC_TimerSelect(S_SC_DEV_T *dev, uint32_t type);
Nint32_t SC_WarmReset(S_SC_DEV_T *dev);
Nint32_t SC_DoPPS(S_SC_DEV_T *dev, int32_t f, int32_t d, int32_t t);
Nvoid SC_DeactivationCmd(S_SC_DEV_T *dev);
Nvoid SC_ActivationCmd(S_SC_DEV_T *dev);
Nvoid SC_WarmResetCmd(S_SC_DEV_T *dev);
Nvoid SC_SetGuardTime(S_SC_DEV_T *dev);
Nvoid SC_SetBlockGuardTime(S_SC_DEV_T *dev, uint32_t bgt);
Nvoid SC_StartBlockGuardTime( S_SC_DEV_T *dev );
Nvoid SC_StopBlockGuardTime( S_SC_DEV_T *dev );
Nvoid SC_ClearFIFO(S_SC_DEV_T *dev);
Nuint8_t * SC_ErrMsg(long errno);
Nint32_t SC_CheckCardPresent(SC_T *portno);
Nint32_t SC_ColdReset(S_SC_DEV_T *dev);
Nvoid SC_SetClockState(S_SC_DEV_T *dev, int8_t onoff);
Nvoid SC_ClockStopLevel(S_SC_DEV_T *dev);
Nvoid SC_VoltageConfig(S_SC_DEV_T *dev);
Nvoid SC_SetReaderParameter(S_SC_DEV_T *dev);
Nint32_t SC_PowerActiveLevel(SC_T *portno, int8_t active);
Nint32_t SC_IgnoreCardAbsent(SC_T *portno);
Nint32_t SC_CardDetectEdge(SC_T *portno, int8_t edge);
N
Nint32_t SC_UpdateCardCapabilities(S_SC_DEV_T *dev);
N
N
N
Nint32_t SC_Init(SC_T *portno);
Nint32_t SC_Open(SC_T *portno);
Nint32_t SC_Close(SC_T *portno);
Nint32_t SC_GetATRBuffer(SC_T *portno, uint8_t *buf, int16_t length);
Nint32_t SC_InstallCallBack(SC_T *portno, SC_PFN_CALLBACK pfncallback);
N
N/**
N * @brief      Get Smart Card Clock Source Frequency
N *
N * @param[in]  SC             Smart card port 
N *                            - SC0 : Smart Card port 0
N *                            - SC1 : Smart Card port 1
N *                            - SC2 : Smart Card port 2 
N * @return     Smart card clock source frequency
N * @details    Get smart card clock source frequency for specified port.
N * 
N */
N__INLINE uint32_t SC_GetSmartCardClockSourceFreq(SC_T* SC)
X__inline uint32_t SC_GetSmartCardClockSourceFreq(SC_T* SC)
N{
N    uint32_t u32ClkTbl[4] = {__XTAL, 0, 0, __IRC22M};
X    uint32_t u32ClkTbl[4] = {(12000000UL), 0, 0, (22118400UL)};
N    uint32_t u32SCxEngineClk = 0;
N    
N    u32ClkTbl[1] = PllClock;
N    u32ClkTbl[2] = SystemCoreClock;  
N    if((SC)==SC0)
X    if((SC)==((SC_T *) ((( uint32_t)0x40100000) + 0x90000)))
N    {
N        u32SCxEngineClk = SYSCLK->CLKSEL3&SYSCLK_CLKSEL3_SC0_S_Msk;  
X        u32SCxEngineClk = ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL3&(3ul << 0);  
N    }   
N    else if((SC)==SC1)
X    else if((SC)==((SC_T *) ((( uint32_t)0x40100000) + 0x94000)))
N    {
N        u32SCxEngineClk = (SYSCLK->CLKSEL3&SYSCLK_CLKSEL3_SC1_S_Msk)>>SYSCLK_CLKSEL3_SC1_S_Pos;         
X        u32SCxEngineClk = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL3&(3ul << 2))>>2;         
N    }   
N    else if((SC)==SC2)
X    else if((SC)==((SC_T *) ((( uint32_t)0x40100000) + 0x98000)))
N    {
N        u32SCxEngineClk = (SYSCLK->CLKSEL3&SYSCLK_CLKSEL3_SC2_S_Msk)>>SYSCLK_CLKSEL3_SC2_S_Pos;         
X        u32SCxEngineClk = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL3&(3ul << 4))>>4;         
N    }     
N                                           
N    return u32ClkTbl[u32SCxEngineClk];    
N}
N
N
N
N/**
N  * @} End of SMARTCARD Device Function Interface
N  */ 
N
N/**
N  * @} End of NUC200 Function Interface
N  */ 
N
N
N
N#endif		/* __SC_H__ */
N
N/*** (C) COPYRIGHT 2011 Nuvoton Technology Corp. ***/
N
N
N
L 6310 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#include "PS2.h"
L 1 "..\..\LibNUC200Series\StdDriver\inc\PS2.h" 1
N/**************************************************************************//**
N * @file     PS2.h
N * @version  V2.0
N * $Revision: 1 $
N * $Date: 12/08/08 5:39p $
N * @brief    NUC200 Series PS2 Driver Header File
N *
N * @note
N * Copyright (C) 2012 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __PS2_H__
N#define __PS2_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "NUC200Series.h"
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* PS2_PS2CON constant definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PS2_PS2CON_TXFIFODEPTH(x) (((x)-1) << PS2_PS2CON_TXFIFO_DEPTH_Pos) /*!< PS2_CON setting for TX FIFO DEPTH. it could be 0~15 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N * @details    Force PS2DATA Pin Hi 
N */
N
N#define _PS2_FORCE_DATA_PIN_HI() (PS2->PS2CON |= PS2_PS2CON_FPS2DAT_Msk)
N/**
N * @details    Force PS2DATA Pin Lo 
N */
N#define _PS2_FORCE_DATA_PIN_LO() (PS2->PS2CON &= (~PS2_PS2CON_FPS2DAT_Msk))
N
N/**
N * @details    Force PS2CLK Pin Hi 
N */
N#define _PS2_FORCE_CLK_PIN_HI() (PS2->PS2CON |= PS2_PS2CON_FPS2CLK_Msk)
N
N/**
N * @details    Force PS2CLK Pin Lo 
N */
N#define _PS2_FORCE_CLK_PIN_LO() (PS2->PS2CON &= (~PS2_PS2CON_FPS2CLK_Msk))
N
N/**
N * @details    Software Override PS/2 CLK/DATA Pin State.
N */
N#define _PS2_SOFTWARE_OVERRIDE_ENABLE()  (PS2->PS2CON |= PS2_PS2CON_OVERRIDE_Msk)
N 
N/**
N * @details    Internal State Machine Override PS/2 CLK/DATA Pin State.
N */ 
N#define _PS2_SOFTWARE_OVERRIDE_DISABLE() (PS2->PS2CON &= (~PS2_PS2CON_OVERRIDE_Msk))
N
N/**
N * @details    Always Send Acknowledge to Host at 12th clock
N */
N#define _PS2_ACK_ENABLE()	(PS2->PS2CON &= (~PS2_PS2CON_ACK_Msk))
N
N/**
N * @details    If Parity error or Stop bit is Not Received Correctly, Acknowledge will Not be Sent to host at 12th clock
N */
N#define _PS2_ACK_DISABLE()	(PS2->PS2CON |= PS2_PS2CON_ACK_Msk)
N
N/**
N * @details    Configure the Transmit Data FIFO Depth PS/2 port. The x setting can be 1-16.
N */
N#define _PS2_SET_TX_FIFO_DEPTH(x) (PS2->PS2CON = (PS2->PS2CON & ~PS2_PS2CON_TXFIFO_DEPTH_Msk) | PS2_PS2CON_TXFIFODEPTH(x))
N
N/**
N * @details    Enable Receive Interrupt
N */
N#define _PS2_RX_INTERRUPT_ENABLE()  (PS2->PS2CON |= PS2_PS2CON_RXINTEN_Msk)
N
N/**
N * @details    Disable Receive Interrupt
N */
N#define _PS2_RX_INTERRUPT_DISABLE() (PS2->PS2CON &= (~PS2_PS2CON_RXINTEN_Msk))
N
N/**
N * @details    Enable Transmit Interrupt
N */
N#define _PS2_TX_INTERRUPT_ENABLE() (PS2->PS2CON |= PS2_PS2CON_TXINTEN_Msk)
N
N/**
N * @details    Disable Transmit Interrupt
N */
N#define _PS2_TX_INTERRUPT_DISABLE() (PS2->PS2CON &= (~PS2_PS2CON_TXINTEN_Msk))
N
N/**
N * @details    Enable PS/2 Device
N */
N#define _PS2_DEVICE_ENABLE()  (PS2->PS2CON |= PS2_PS2CON_PS2EN_Msk)
N
N/**
N * @details    Disable PS/2 Device
N */
N#define _PS2_DEVICE_DISABLE() (PS2->PS2CON &= (~PS2_PS2CON_PS2EN_Msk))
N
N/**
N * @details    Write Data to Transmit Buffer0
N */					   
N#define _PS2_WRITE_TX_DATA0(x) (PS2->PS2TXDATA0 = (x))
N
N/**
N * @details    Write Data to Transmit Buffer1
N */
N#define _PS2_WRITE_TX_DATA1(x) (PS2->PS2TXDATA1 = (x))
N
N/**
N * @details    Write Data to Transmit Buffer2
N */
N#define _PS2_WRITE_TX_DATA2(x) (PS2->PS2TXDATA2 = (x))
N
N/**
N * @details    Write Data to Transmit Buffer3
N */ 
N#define _PS2_WRITE_TX_DATA3(x) (PS2->PS2TXDATA3 = (x))
N
N/**
N * @details    Get Data from Receive Data Buffer
N */		
N#define _PS2_GET_RX_DATA() (PS2->PS2RXDATA)
N
N/**
N * @details    Get indicates which data byte in transmit data shift register
N */								
N#define _PS2_GET_TXBUF_BYTE_INDEX() ((PS2->PS2STATUS & PS2_PS2STATUS_BYTEIDX_Msk)>>PS2_PS2STATUS_BYTEIDX_Pos)
N
N/**
N * @details    Get the TX FIFO Empty flag
N */				
N#define _PS2_GET_TX_FIFO_EMPTY_FLAG() 	((PS2->PS2STATUS & PS2_PS2STATUS_TXEMPTY_Msk)>>PS2_PS2STATUS_TXEMPTY_Pos) 									
N
N/**
N * @details    Get the Rx Buffer Overwrite flag
N */				
N#define _PS2_GET_RXBUF_OVERWRITE_FLAG() ((PS2->PS2STATUS & PS2_PS2STATUS_RXOVF_Msk)>>PS2_PS2STATUS_RXOVF_Pos)
N
N/**
N * @details    clear the Rx Buffer Overwrite flag
N */ 
N#define _PS2_CLEAR_RX_OVERWRITE_FLAG() (PS2->PS2STATUS = PS2->PS2STATUS|PS2_PS2STATUS_RXOVF_Msk)
N
N/**
N * @details    Get the Device Tx Busy flag
N */				
N#define _PS2_GET_TX_BUSY_FLAG() ((PS2->PS2STATUS & PS2_PS2STATUS_TXBUSY_Msk)>>PS2_PS2STATUS_TXBUSY_Pos)	
N
N/**
N * @details    Get the Device Rx Busy flag
N */				
N#define _PS2_GET_RX_BUSY_FLAG() ((PS2->PS2STATUS & PS2_PS2STATUS_RXBUSY_Msk)>>PS2_PS2STATUS_RXBUSY_Pos)
N
N/**
N * @details    Get the parity bit for the last received data byte (odd parity).
N */				
N#define _PS2_GET_RX_PARITY_FLAG() ((PS2->PS2STATUS & PS2_PS2STATUS_RXPARITY_Msk)>>PS2_PS2STATUS_RXPARITY_Pos)
N
N/**
N * @details    Get the Frame Error flag
N */				
N#define _PS2_GET_FRAME_ERROR_FLAG() ((PS2->PS2STATUS & PS2_PS2STATUS_FRAMERR_Msk)>>PS2_PS2STATUS_FRAMERR_Pos)
N
N/**
N * @details    Clear the Frame Error flag
N */ 
N#define _PS2_CLEAR_FRAME_ERROR_FLAG() (PS2->PS2STATUS = PS2->PS2STATUS|PS2_PS2STATUS_FRAMERR_Msk)
N
N/**
N * @details    Get the Data Pin State flag
N */				
N#define _PS2_GET_DATA_PIN_STATUS() ((PS2->PS2STATUS & PS2_PS2STATUS_PS2DATA_Msk)>>PS2_PS2STATUS_PS2DATA_Pos)
N
N/**
N * @details    Get the Clk Pin State flag
N */				
N#define _PS2_GET_CLK_PIN_STATUS() ((PS2->PS2STATUS & PS2_PS2STATUS_PS2CLK_Msk)>>PS2_PS2STATUS_PS2CLK_Pos)
N
N/**
N * @details    Get the Transmit Interrupt flag
N */
N#define _PS2_GET_TX_INT_FLAG() ((PS2->PS2INTID&PS2_PS2INTID_TXINT_Msk)>>PS2_PS2INTID_TXINT_Pos)
N
N/**
N * @details    Clear the Transmit Interrupt flag
N */
N#define _PS2_CLEAR_TX_INT_FLAG() (PS2->PS2INTID = PS2->PS2INTID|PS2_PS2INTID_TXINT_Msk)
N
N/**
N * @details    Get the Receive Interrupt flag
N */
N#define _PS2_GET_RX_INT_FLAG()	 ((PS2->PS2INTID&PS2_PS2INTID_RXINT_Msk)>>PS2_PS2INTID_RXINT_Pos)
N
N/**
N * @details    Clear the Receive Interrupt flag
N */
N#define _PS2_CLEAR_RX_INT_FLAG() (PS2->PS2INTID = PS2->PS2INTID|PS2_PS2INTID_RXINT_Msk)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* static inline functions                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @details     ADC IP reset 
N */
N__INLINE void PS2_ResetIP()
X__inline void PS2_ResetIP()
N{
N	SYS->IPRSTC2 |=  SYS_IPRSTC2_PS2_RST_Msk;
X	((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |=  (1ul << 23);
N	SYS->IPRSTC2 &= ~SYS_IPRSTC2_PS2_RST_Msk;
X	((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(1ul << 23);
N}
N/**
N * @details     Clear TX FIFO
N */
Nstatic __INLINE void PS2_CLEAR_TX_FIFO()
Xstatic __inline void PS2_CLEAR_TX_FIFO()
N{
N    (PS2->PS2CON |= PS2_PS2CON_CLRFIFO_Msk);
X    (((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON |= (1ul << 8));
N    (PS2->PS2CON &= (~PS2_PS2CON_CLRFIFO_Msk));
X    (((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON &= (~(1ul << 8)));
N}
N#endif
N
L 6311 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\NUC200Series.h" 2
N#endif
N                                                                                                 
L 8 "..\..\LibNUC200Series\CMSIS\CM0\DeviceSupport\Nuvoton\NUC200Series\system_NUC200Series.c" 2
N
N
N/*----------------------------------------------------------------------------
N  Clock Variable definitions
N *----------------------------------------------------------------------------*/
Nuint32_t SystemCoreClock  = __HSI;   /*!< System Clock Frequency (Core Clock) */
Xuint32_t SystemCoreClock  = (50000000UL);    
Nuint32_t CyclesPerUs      = (__HSI / 1000000); /* Cycles per micro second */
Xuint32_t CyclesPerUs      = ((50000000UL) / 1000000);  
Nuint32_t PllClock         = __HSI;              /*!< PLL Output Clock Frequency          */
Xuint32_t PllClock         = (50000000UL);               
Nuint32_t gau32ClkSrcTbl[] = {__XTAL, __RTC_XTAL, __HSI, __IRC10K, __IRC22M};
Xuint32_t gau32ClkSrcTbl[] = {(12000000UL), (32768UL), (50000000UL), (10000UL), (22118400UL)};
N
N/*----------------------------------------------------------------------------
N  Clock functions
N  This function is used to update the variable SystemCoreClock 
N  and must be called whenever the core clock is changed.
N *----------------------------------------------------------------------------*/
Nvoid SystemCoreClockUpdate (void)            /* Get Core Clock Frequency      */
N{
N    uint32_t u32Freq, u32ClkSrc;
N    uint32_t u32HclkDiv;
N
N    /* Update PLL Clock */
N    PllClock = DrvSYS_GetPLLClockFreq();
N 
N    u32ClkSrc = SYSCLK->CLKSEL0 & SYSCLK_CLKSEL0_HCLK_S_Msk;
X    u32ClkSrc = ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL0 & (7ul << 0);
N
N    if(u32ClkSrc != SYSCLK_CLKSEL0_HCLK_PLL)
X    if(u32ClkSrc != 0x02UL)
N    {
N        /* Use the clock sources directly */
N        u32Freq = gau32ClkSrcTbl[u32ClkSrc];
N    }
N    else
N    {
N        /* Use PLL clock */
N        u32Freq = PllClock;
N    }
N 
N    u32HclkDiv = (SYSCLK->CLKDIV & SYSCLK_CLKDIV_HCLK_N_Msk) + 1; 
X    u32HclkDiv = (((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKDIV & (0xFul << 0)) + 1; 
N    
N    /* Update System Core Clock */
N    SystemCoreClock = u32Freq/u32HclkDiv;
N
N    CyclesPerUs = (SystemCoreClock + 500000) / 1000000;
N}
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function: SystemInit                                                                                    */
N/*                                                                                                         */
N/* Parameters:                                                                                             */
N/*      None                                                                                               */
N/*                                                                                                         */
N/* Returns:                                                                                                */
N/*      None                                                                                               */
N/*                                                                                                         */
N/* Description:                                                                                            */
N/*      The necessary initializaiton of systerm.                                                           */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid SystemInit (void)
N{
N#ifdef INIT_SYSCLK_AT_BOOTING
N    int32_t i32TimeoutCnt;
N    uint32_t u32HclkSelect;
N    int8_t i8IsPllEn;
N
N    PllClock = 0;
N    i8IsPllEn = 0;
N    u32HclkSelect = SYSCLK->CLKSEL0 & SYSCLK_CLKSEL0_HCLK_S_Msk;
X    u32HclkSelect = ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL0 & (7ul << 0);
N    if(u32HclkSelect == SYSCLK_CLKSEL0_HCLK_XTAL)
X    if(u32HclkSelect == 0x00UL)
N    {
N        /* Set to 50MHz system clock frequency when clock source is from external 12MHz */
N        SYSCLK->PLLCON = SYSCLK_PLLCON_50MHz_XTAL;       
X        ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON = (0x00000000UL | (((3)-2)<<9) | ((25)-2) | 0x4000UL);       
N        
N        /* Waiting for PLL ready */
N        i32TimeoutCnt = (__XTAL / 1000); /* Timeout is about 1ms */
X        i32TimeoutCnt = ((12000000UL) / 1000);  
N        while((SYSCLK->CLKSTATUS & SYSCLK_CLKSTATUS_PLL_STB_Msk) == 0 )
X        while((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSTATUS & (1ul << 2)) == 0 )
N        {
N            if(i32TimeoutCnt-- <= 0)
N                break;    
N        }
N
N        i8IsPllEn = 1;
N    }
N    else if(u32HclkSelect == SYSCLK_CLKSEL0_HCLK_IRC22M)
X    else if(u32HclkSelect == 0x07UL)
N    {
N        /* Set to 50.1918MHz system clock frequency when clock source is from internal 22.1184MHz RC clock */
N        SYSCLK->PLLCON = SYSCLK_PLLCON_50MHz_IRC22M;       
X        ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON = (0x00080000UL | (((13)-2)<<9) | ((59)-2) | 0x4000UL);       
N        
N        /* Waiting for PLL ready */
N        i32TimeoutCnt = (__IRC22M / 1000); /* Timeout is about 1ms */
X        i32TimeoutCnt = ((22118400UL) / 1000);  
N        while((SYSCLK->CLKSTATUS & SYSCLK_CLKSTATUS_PLL_STB_Msk) == 0 )
X        while((((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSTATUS & (1ul << 2)) == 0 )
N        {
N            if(i32TimeoutCnt-- <= 0)
N                break;    
N        }
N
N        i8IsPllEn = 1;
N    }
N
N    if(i8IsPllEn)    
N    {
N        /* Set PLL as HCLK clock source (HCLK_S is locked setting)*/
N        SYS_UnlockReg();
N        SYSCLK->CLKSEL0 = SYSCLK_CLKSEL0_HCLK_PLL;
X        ((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL0 = 0x02UL;
N        SYS_LockReg();
N    }
N#endif
N}
